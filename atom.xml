<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>七路灯</title>
  
  <subtitle>人的一生应当有许多停靠站，但愿每一个站台都有一盏雾中的灯。</subtitle>
  <link href="http://www.lights8080.com/atom.xml" rel="self"/>
  
  <link href="http://www.lights8080.com/"/>
  <updated>2021-11-30T08:37:42.000Z</updated>
  <id>http://www.lights8080.com/</id>
  
  <author>
    <name>七路灯</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>阿里云网络产品</title>
    <link href="http://www.lights8080.com/p/26e0d0d9.html"/>
    <id>http://www.lights8080.com/p/26e0d0d9.html</id>
    <published>2021-11-29T16:00:00.000Z</published>
    <updated>2021-11-30T08:37:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>介绍：专有网络 VPC、弹性公网IP（EIP）、NAT网关、负载均衡 SLB等</p><span id="more"></span><h2 id="1-专有网络-VPC"><a href="#1-专有网络-VPC" class="headerlink" title="1. 专有网络 VPC"></a>1. 专有网络 VPC</h2><p><a href="https://www.aliyun.com/product/vpc">https://www.aliyun.com/product/vpc</a><br>专有网络是您专有的云上私有网络。您可以完全掌控自己的专有网络，例如选择IP地址范围、配置路由表和网关等。<br>每个专有网络都由至少一个私网网段、一个路由器和至少一个交换机组成。</p><p><img src="https://help-static-aliyun-doc.aliyuncs.com/assets/img/zh-CN/2448327361/p241558.png" alt="专有网络和交换机"></p><h3 id="1-1-路由器"><a href="#1-1-路由器" class="headerlink" title="1.1 路由器"></a>1.1 路由器</h3><p>路由器（vRouter）是专有网络的枢纽。作为专有网络中重要的功能组件，它可以连接专有网络内的各个交换机，同时也是连接专有网络和其他网络的网关设备。每个专有网络创建成功后，系统会自动创建一个路由器。每个路由器关联一张路由表。</p><h3 id="1-2-交换机"><a href="#1-2-交换机" class="headerlink" title="1.2 交换机"></a>1.2 交换机</h3><p>交换机（vSwitch）是组成专有网络的基础网络设备，用来连接不同的云资源。创建专有网络后，您可以通过创建交换机为专有网络划分一个或多个子网。同一专有网络内的不同交换机之间内网互通。您可以将应用部署在不同可用区的交换机内，提高应用的可用性。</p><h3 id="1-3-VPC连接"><a href="#1-3-VPC连接" class="headerlink" title="1.3 VPC连接"></a>1.3 VPC连接</h3><p>阿里云提供了丰富的解决方案以满足VPC内的云产品实例与公网（Internet）、其他VPC、或本地数据中心（IDC）互连的需求。<br>连接公网，分为：ECS固定公网IP、弹性公网IP（EIP）、NAT网关、负载均衡<br>连接VPC，分为：云企业网、VPN网关</p><h3 id="1-4-访问控制"><a href="#1-4-访问控制" class="headerlink" title="1.4 访问控制"></a>1.4 访问控制</h3><p>专有网络VPC不仅可以通过网络ACL实现访问控制，还可以依赖各个云产品的访问控制能力来实现安全访问，例如云服务器ECS通过设置安全组来进行访问控制，负载均衡SLB和云数据库RDS通过白名单来进行访问控制。</p><h3 id="1-5-高可用虚拟IP"><a href="#1-5-高可用虚拟IP" class="headerlink" title="1.5 高可用虚拟IP"></a>1.5 高可用虚拟IP</h3><p>高可用虚拟IP（High-Availability Virtual IP Address，简称HaVip）是一种可以独立创建和释放的私网IP资源。HaVip可以与高可用软件（例如Keepalived）配合使用，搭建高可用主备服务，提高业务的可用性。</p><h2 id="2-弹性公网IP（EIP）"><a href="#2-弹性公网IP（EIP）" class="headerlink" title="2. 弹性公网IP（EIP）"></a>2. 弹性公网IP（EIP）</h2><p><a href="https://help.aliyun.com/product/61789.html">https://help.aliyun.com/product/61789.html</a><br>弹性公网IP（Elastic IP Address，简称EIP）是可以独立购买和持有的公网IP地址资源。EIP支持绑定到专有网络类型的ECS实例、专有网络类型的私网SLB实例、专有网络类型的辅助弹性网卡、NAT网关和高可用虚拟IP上。<br>EIP是一种NAT IP，它实际位于阿里云的公网网关上，通过NAT方式映射到被绑定的云资源上。当EIP和云资源绑定后，云资源可以通过EIP与公网通信。<br>EIP可以随时和ECS实例绑定和解绑。可以使用共享带宽和共享流量包，降低公网成本。</p><h2 id="3-NAT网关"><a href="#3-NAT网关" class="headerlink" title="3. NAT网关"></a>3. NAT网关</h2><p><a href="https://help.aliyun.com/product/44413.html">https://help.aliyun.com/product/44413.html</a><br>NAT网关（NAT Gateway）可以提供网络地址转换服务，分为公网NAT网关和VPC NAT网关。公网NAT网关提供公网地址转换服务，而VPC NAT网关提供私网地址转换服务。<br>NAT网关和EIP的核心区别是NAT网关可用于多台VPC ECS实例和公网通信，而EIP只能用于一台VPC ECS实例和公网通信。</p><ul><li>公网NAT网关：公网NAT网关是一款企业级针对公网访问的安全网关产品，提供NAT代理（SNAT和DNAT）功能，具有100 Gbps的转发能力及跨可用区的容灾能力。</li></ul><p><img src="https://help-static-aliyun-doc.aliyuncs.com/assets/img/zh-CN/1283214061/p4440.png" alt="公网NAT网关"></p><ul><li>VPC NAT网关：VPC NAT网关能够为VPC内的ECS实例提供网络地址转换服务，使多个ECS实例可以通过中转私网地址（即NAT IP地址）访问您的本地IDC或其他VPC。ECS实例也可以通过使用VPC NAT网关的中转私网地址对外提供私网访问服务。</li></ul><p><img src="https://help-static-aliyun-doc.aliyuncs.com/assets/img/zh-CN/4614119261/p305145.png" alt="VPC NAT网关"></p><h2 id="4-负载均衡-SLB"><a href="#4-负载均衡-SLB" class="headerlink" title="4. 负载均衡 SLB"></a>4. 负载均衡 SLB</h2><p><a href="https://www.aliyun.com/product/slb">https://www.aliyun.com/product/slb</a><br>负载均衡SLB（Server Load Balancer）是一种对流量进行按需分发的服务，通过将流量分发到不同的后端服务来扩展应用系统的服务吞吐能力，并且可以消除系统中的单点故障，提升应用系统的可用性。<br>阿里云负载均衡SLB分为两类：传统型负载均衡CLB和应用型负载均衡ALB。</p><ul><li>ALB（Application Load Balancer）：专门面向七层，提供超强的业务处理性能，例如HTTPS卸载能力。</li><li>CLB（Classic Load Balancer）：支持TCP、UDP、HTTP和HTTPS协议，具备强大的四层处理能力，以及基础的七层处理能力。</li></ul><h2 id="5-ECS-弹性网卡"><a href="#5-ECS-弹性网卡" class="headerlink" title="5. ECS - 弹性网卡"></a>5. ECS - 弹性网卡</h2><p><a href="https://help.aliyun.com/document_detail/58496.htm">https://help.aliyun.com/document_detail/58496.htm</a><br>弹性网卡ENI（Elastic Network Interface）是一种可以绑定到专有网络VPC类型ECS实例上的虚拟网卡。通过弹性网卡，您可以实现高可用集群搭建、低成本故障转移和精细化的网络管理。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍：专有网络 VPC、弹性公网IP（EIP）、NAT网关、负载均衡 SLB等&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://www.lights8080.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="阿里云" scheme="http://www.lights8080.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
    <category term="网络" scheme="http://www.lights8080.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Sentinel</title>
    <link href="http://www.lights8080.com/p/1408c19.html"/>
    <id>http://www.lights8080.com/p/1408c19.html</id>
    <published>2021-11-24T16:00:00.000Z</published>
    <updated>2021-11-26T10:46:45.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote></blockquote><span id="more"></span><h2 id="Sentinel（分布式系统的流量防卫兵）"><a href="#Sentinel（分布式系统的流量防卫兵）" class="headerlink" title="Sentinel（分布式系统的流量防卫兵）"></a>Sentinel（分布式系统的流量防卫兵）</h2><p>Sentinel 是面向分布式服务架构的轻量级流量控制组件，主要以流量为切入点，从限流、流量整形、熔断降级、系统负载保护等多个维度来帮助您保障微服务的稳定性。<br><a href="https://sentinelguard.io/zh-cn/index.html">https://sentinelguard.io/zh-cn/index.html</a></p><h3 id="Sentinel-核心类解析"><a href="#Sentinel-核心类解析" class="headerlink" title="Sentinel 核心类解析"></a>Sentinel 核心类解析</h3><p><a href="https://github.com/alibaba/Sentinel/wiki/Sentinel-%E6%A0%B8%E5%BF%83%E7%B1%BB%E8%A7%A3%E6%9E%90">https://github.com/alibaba/Sentinel/wiki/Sentinel-%E6%A0%B8%E5%BF%83%E7%B1%BB%E8%A7%A3%E6%9E%90</a></p><p>包括Context、Entry、Node（统计节点）、Slot（插槽）。</p><p>链路、来源怎么理解？</p><ul><li>链路：查询商品业务逻辑，在查询订单和创建订单业务中都有调用，既查询商品有两个调用链路。</li><li>来源：上例中查询订单业务，支持web查询和app查询，既有两个来源。</li></ul><p>Node 的分类</p><ul><li>StatisticNode：最为基础的统计节点，包含秒级和分钟级两个滑动窗口结构。</li><li>DefaultNode：链路节点，用于统计调用链路上某个资源的数据，维持树状结构。</li><li>EntranceNode：入口节点，特殊的链路节点，对应某个 Context 入口的所有调用数据。</li><li>ClusterNode：簇点，用于统计每个资源全局的数据（不区分调用链路），以及存放该资源的按来源区分的调用数据（响应时间、QPS、block 数目、线程数、异常数等）。</li></ul><p>Node 的维度</p><ul><li>EntranceNode 的维度是 context</li><li>ClusterNode 的维度是 resource</li><li>DefaultNode 的维度是 resource * context</li></ul><p>Slot 的分类</p><ul><li>NodeSelectorSlot：负责收集资源的路径，并将这些资源的调用路径以树状结构存储起来，用于根据调用路径进行流量控制。</li><li>ClusterBuilderSlot：用于构建资源的 ClusterNode 以及调用来源节点，用作为多维度限流，降级的依据。</li><li>StatisticSlot 是 Sentinel 的核心功能插槽之一，用于统计实时的调用数据。</li></ul><p>规则的种类及属性：<br><a href="https://github.com/alibaba/Sentinel/wiki/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8#%E8%A7%84%E5%88%99%E7%9A%84%E7%A7%8D%E7%B1%BB">https://github.com/alibaba/Sentinel/wiki/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8#%E8%A7%84%E5%88%99%E7%9A%84%E7%A7%8D%E7%B1%BB</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="技术" scheme="http://www.lights8080.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Sentinel" scheme="http://www.lights8080.com/tags/Sentinel/"/>
    
  </entry>
  
  <entry>
    <title>ELK-EQL-20211108</title>
    <link href="http://www.lights8080.com/p/b8b4da5.html"/>
    <id>http://www.lights8080.com/p/b8b4da5.html</id>
    <published>2021-11-07T16:00:00.000Z</published>
    <updated>2021-11-08T08:41:03.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote></blockquote><span id="more"></span><h2 id="1-other-bucket"><a href="#1-other-bucket" class="headerlink" title="1. other_bucket"></a>1. other_bucket</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">GET /unififi-nginx-api/_search?pretty&amp;ignore_unavailable=<span class="literal">true</span>&amp;size=<span class="number">0</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;percentage_match_aggs&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;filters&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;filters&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;match_bucket&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;must&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;request_time&quot;</span>: &#123;</span><br><span class="line">                      <span class="attr">&quot;from&quot;</span>: <span class="number">0</span>,</span><br><span class="line">                      <span class="attr">&quot;to&quot;</span>: <span class="number">3</span></span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;other_bucket&quot;</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;filter&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;must&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;@timestamp&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;gt&quot;</span>: <span class="string">&quot;2021-10-17T15:35:00+08:00&quot;</span>,</span><br><span class="line">                  <span class="attr">&quot;lte&quot;</span>: <span class="string">&quot;2021-10-17T15:36:00+08:00&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-时间查询-amp-排序-amp-分页"><a href="#2-时间查询-amp-排序-amp-分页" class="headerlink" title="2. 时间查询&amp;排序&amp;分页"></a>2. 时间查询&amp;排序&amp;分页</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">GET unififi-transaction-engine/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;@timestamp&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;gte&quot;</span>: <span class="string">&quot;2021-05-15 00:00:00&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;lte&quot;</span>: <span class="string">&quot;2021-05-15 00:00:59&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;format&quot;</span>: <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;time_zone&quot;</span>:<span class="string">&quot;+08:00&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,<span class="attr">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;@timestamp&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;order&quot;</span>: <span class="string">&quot;desc&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;from&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /unififi-nginx-api/_search?pretty&amp;ignore_unavailable=<span class="literal">true</span>&amp;size=<span class="number">0</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;counts&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;status&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;min_doc_count&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;size&quot;</span>: <span class="number">10</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;filter&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;must&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;@timestamp&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;gt&quot;</span>: <span class="string">&quot;2021-06-17T09:29:03.757125Z&quot;</span>,</span><br><span class="line">                  <span class="attr">&quot;lte&quot;</span>: <span class="string">&quot;2021-06-17T09:29:30.781333Z&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;query_string&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;query&quot;</span>: <span class="string">&quot;status: 200&quot;</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-多字段分组-amp-排序-amp-分页"><a href="#3-多字段分组-amp-排序-amp-分页" class="headerlink" title="3. 多字段分组&amp;排序&amp;分页"></a>3. 多字段分组&amp;排序&amp;分页</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">GET /unififi-order/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;gmtCreate&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;gte&quot;</span>: <span class="string">&quot;2021-05-06 00:00:00&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;lte&quot;</span>: <span class="string">&quot;2021-05-06 23:59:59&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;format&quot;</span>: <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;time_zone&quot;</span>:<span class="string">&quot;+08:00&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;group_by_fields&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;composite&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;sources&quot;</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;supplierCid&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;supplierCid&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;min_doc_count&quot;</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">&quot;size&quot;</span>: <span class="number">20</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,&#123;</span><br><span class="line">            <span class="attr">&quot;ipcc&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;ipcc&quot;</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;size&quot;</span>: <span class="number">50</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;sum_totalApiAmount&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;sum&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;totalApiAmount&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;order_count&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;value_count&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;id&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;sales_bucket_sort&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;bucket_sort&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;sort&quot;</span>: [</span><br><span class="line">              &#123; <span class="attr">&quot;order_count&quot;</span>: &#123; <span class="attr">&quot;order&quot;</span>: <span class="string">&quot;asc&quot;</span> &#125; &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;from&quot;</span>: <span class="number">0</span>, </span><br><span class="line">            <span class="attr">&quot;size&quot;</span>: <span class="number">10</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /unififi-order/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;gmtCreate&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;gte&quot;</span>: <span class="string">&quot;2021-03-01 00:00:00&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;lte&quot;</span>: <span class="string">&quot;2021-06-01 00:00:00&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;format&quot;</span>: <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;time_zone&quot;</span>:<span class="string">&quot;+08:00&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;table&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;composite&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;sources&quot;</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">          <span class="attr">&quot;stk1&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;terms&quot;</span>: &#123;<span class="attr">&quot;field&quot;</span>: <span class="string">&quot;fromCityMore.country_code&quot;</span>&#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;stk2&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;terms&quot;</span>: &#123;<span class="attr">&quot;field&quot;</span>: <span class="string">&quot;toCityMore.country_code&quot;</span>&#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;size&quot;</span>: <span class="number">5000</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;totalAdultNumber&quot;</span>:&#123;</span><br><span class="line">          <span class="attr">&quot;sum&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;adultNumber&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;totalPasengerNumber&quot;</span>:&#123;</span><br><span class="line">          <span class="attr">&quot;sum&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;script&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;source&quot;</span>: <span class="string">&quot;(doc.adultNumber.value + doc.childNumber.value)&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;segmentNumber&quot;</span>:&#123;</span><br><span class="line">          <span class="attr">&quot;sum&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;segmentCount&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;totalSegmentNumber&quot;</span>:&#123;</span><br><span class="line">          <span class="attr">&quot;sum&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;script&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;source&quot;</span>: <span class="string">&quot;(doc.adultNumber.value + doc.childNumber.value) * doc.segmentCount.value&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-字段查询及不包含查询"><a href="#4-字段查询及不包含查询" class="headerlink" title="4. 字段查询及不包含查询"></a>4. 字段查询及不包含查询</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">GET unififi-order/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;must&quot;</span>: [</span><br><span class="line">        &#123;<span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;orderNo&quot;</span>: <span class="string">&quot;21050116198164008165460&quot;</span></span><br><span class="line">        &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /unififi-transaction-engine/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;must_not&quot;</span>: [</span><br><span class="line">        &#123;<span class="attr">&quot;exists&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;data_source&quot;</span></span><br><span class="line">        &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="技术" scheme="http://www.lights8080.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="ELK" scheme="http://www.lights8080.com/tags/ELK/"/>
    
  </entry>
  
  <entry>
    <title>数据安全</title>
    <link href="http://www.lights8080.com/p/445271f9.html"/>
    <id>http://www.lights8080.com/p/445271f9.html</id>
    <published>2021-11-02T16:00:00.000Z</published>
    <updated>2021-11-03T07:47:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>数据安全相关</p><span id="more"></span><h2 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h2><p>数据安全怎么做——数据跨境的思考<br><a href="https://xie.infoq.cn/article/5507aea47185998b4f47c8506">https://xie.infoq.cn/article/5507aea47185998b4f47c8506</a><br>《数据安全法》加码数据出境安全，跨国公司该如何应对？<br><a href="https://www.freebuf.com/articles/database/282002.html">https://www.freebuf.com/articles/database/282002.html</a></p><h4 id="信息安全、网络安全、数据安全"><a href="#信息安全、网络安全、数据安全" class="headerlink" title="信息安全、网络安全、数据安全"></a>信息安全、网络安全、数据安全</h4><ul><li>当需要强调安全管理体系，或强调信息及信息系统的保密性、完整性、可用性，或 内容合规，或 DLP(防止内部人为的信息泄露)，或强调对静态信息的保护(比如存储系 统、光盘上的信息)等场景时，“信息安全”一词多被使用。 </li><li>当需要强调网络边界和安全域，或网络入侵防御，或网络通信系统或传输安全，或 网络空间等场景时，“网络安全”一词多被使用。 </li><li>当需要强调全生命周期中的数据保护，或数据作为生产力，或强调数据主权、数据 主体权利、长臂管辖权、隐私保护等场景时，“数据安全”一词多被使用。 </li></ul><h4 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h4><p>方向一、在美国的业务完全独立（思路类似一企两制）：本地化管控包含人员本地化招聘、系统本地化部署和数据本地化存储<br>方向二、在美国的系统完全独立：将敏感数据的模块，从整体的系统中剥离出来，独立形成一套系统，美国CDN企业专线，完成跨国数据传输<br>方向三、在美国的数据完全独立：敏感数据的获取和存储，依托第三方公司完成<br>方向四、放弃美国合规要求的隐私数据：匿名化处理，删除相关数据</p><h2 id="数据保护法律咨询"><a href="#数据保护法律咨询" class="headerlink" title="数据保护法律咨询"></a>数据保护法律咨询</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">数据安全：个人信息匿名化处理（脱敏是目的，匿名化是处理方式之一，还有去标识，加密等等）</span><br><span class="line">他说是法律上的匿名化就是删除的意思，存储时需要加密处理。</span><br><span class="line">问：</span><br><span class="line">1. “姓名：张三，身份证：12345****，性别：男，年龄：22，…，” 这个例子把关键信息匿名，是否合规？</span><br><span class="line">2. 比如我们个人数据保存期限3年，但不想删除，定期把3年前数据按上面的方式匿名化，是否合规？</span><br><span class="line">3. 乘客行程也属于个人敏感信息，如果把个人信息匿名了，行程信息还算是敏感信息吗？</span><br><span class="line"></span><br><span class="line">答：</span><br><span class="line">嗯嗯，第一，上面1中的字段屏蔽属于个人信息的去标识化，应该不属于匿名化的措施（匿名化的是不可识别且不能复原的状态，因此对于已经屏蔽的关键字段，结合其他信息，仍有可能复原原本的信息，进而识别到个人）；第二，因为不属于匿名化的措施，因此按照上述方式的处理，不能被认为是进行了匿名化或者删除，存在违反存储期限最小必要的风险。因此，我们建议，不仅通过字段屏蔽，而且也可以通过MD5、差分隐私等的加密方式，辅之以数据库管理上的逻辑隔离或者物理隔离，不让数据进行融合以重新识别到个人，通过这种方式来实现匿名化的目标；第三，乘客行程如果将个人信息屏蔽，在信息敏感度上会降低，在不存在与其他的信息结合识别特定乘客行程的情形，也可能不会被视为“个人敏感信息”。因此，我们理解，在采取数据分隔存储使用的，并辅之以信息屏蔽或者加密技术的措施，可以降低个人信息的敏感程度。</span><br><span class="line"></span><br><span class="line">问：</span><br><span class="line">嗯嗯 脱敏是目的，匿名化和去标识化都是处理方式之一，只要做到结合所有信息，进而识别不到是具体个人，我理解就合规了对吧</span><br><span class="line">保守的做法还是加密和物理隔离 比较稳妥哈</span><br><span class="line">答：</span><br><span class="line">嗯嗯，因为法律上是要求是结合所有的信息，而不仅仅是姓名、性别、年龄这些信息，因此仅仅的字段屏蔽可能是不够的。最好还是能有一些技术上的加密措施，以及管理上的隔离。</span><br><span class="line"></span><br><span class="line">问：</span><br><span class="line">为了服务客户要保存历史订单超过10年，订单中的包括乘客的个人信息。这种情况有什么好的建议吗？</span><br><span class="line">答：</span><br><span class="line">嗯嗯，建议可以将这种存储情形在隐私政策中披露，并征得用户的授权同意。同时，内部制度上也规定这种情形的存储期限，并做到到期后的删除或者匿名化。</span><br><span class="line"></span><br><span class="line">问：</span><br><span class="line">上次说到 加密或者隔离管理来达到对个人信息的保护，这个主要是为了防止被拖库造成的数据泄露，对吧</span><br><span class="line">答：</span><br><span class="line">嗯嗯，一方面是保证数据的安全，另一方面也是防止数据的重识别，也就是通过结合其他的信息，再重新识别到个人。如果做到结合所有信息无法识别到个人，且不能复原，可以被认为实现匿名化。</span><br><span class="line"></span><br><span class="line">问：</span><br><span class="line">如果通过加密存储，结合其他信息无法识别到个人，通过程序可以复原，这算是实现匿名化吗</span><br><span class="line">答：</span><br><span class="line">如果通过程序可以复原，不算实现匿名化的。有些加密加盐的技术可以实现无法复原到数据的原值的，例如MD5加密后，无法恢复到原值，仅得出一串哈希值；除此之外，差分隐私、K-匿名模型也是实践中会用到的匿名化技术。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;数据安全相关&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://www.lights8080.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="数据安全" scheme="http://www.lights8080.com/tags/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>凤凰架构-不可变基础设施</title>
    <link href="http://www.lights8080.com/p/1751902f.html"/>
    <id>http://www.lights8080.com/p/1751902f.html</id>
    <published>2021-11-02T16:00:00.000Z</published>
    <updated>2021-11-12T02:01:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>周志明《凤凰架构：构建可靠的大型分布式系统》<br><a href="https://icyfenix.cn/">https://icyfenix.cn/</a></p><p>围绕“不可变基础设施”的相关话题，以容器、编排系统和服务网格的发展为主线，介绍虚拟化容器与服务网格是如何模糊掉软件与硬件之间的界限，如何在基础设施与通讯层面上帮助微服务隐藏复杂性，以此解决原本只能由程序员通过软件编程来解决的分布式问题。</p><span id="more"></span><h2 id="1-从微服务到云原生"><a href="#1-从微服务到云原生" class="headerlink" title="1. 从微服务到云原生"></a>1. 从微服务到云原生</h2><h3 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h3><p>云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式 API。<br>这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更。</p><h3 id="不可变基础设施"><a href="#不可变基础设施" class="headerlink" title="不可变基础设施"></a>不可变基础设施</h3><p>而在云原生基金会定义的“云原生”概念中，“不可变基础设施”提升到了与微服务平级的重要程度。此时，它的内涵已经不再局限于只是方便运维、程序升级和部署的手段，而是升华为了向应用代码隐藏分布式架构复杂度、让分布式架构得以成为一种能够普遍推广的普适架构风格的必要前提。</p><h3 id="虚拟化的目标与类型"><a href="#虚拟化的目标与类型" class="headerlink" title="虚拟化的目标与类型"></a>虚拟化的目标与类型</h3><p>容器的首要目标是让软件分发部署的过程，从传统的发布安装包、靠人工部署，转变为直接发布已经部署好的、包含整套运行环境的虚拟化镜像。</p><p>一个计算机软件要能够正确运行，需要通过以下三方面的兼容性来共同保障：</p><ul><li>ISA 兼容：目标机器指令集兼容性，比如 ARM 架构的计算机无法直接运行面向 x86 架构编译的程序。</li><li>ABI 兼容：目标系统或者依赖库的二进制兼容性，比如 Windows 系统环境中无法直接运行 Linux 的程序，又比如 DirectX 12 的游戏无法运行在 DirectX 9 之上。</li><li>环境兼容：目标环境的兼容性，比如没有正确设置的配置文件、环境变量、注册中心、数据库地址、文件系统的权限等等，当任何一个环境因素出现错误，都会让你的程序无法正常运行。</li></ul><h3 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h3><ul><li>指令集虚拟化：指令集虚拟化就是仿真，它提供了几乎完全不受局限的兼容性，甚至能做到直接在 Web 浏览器上运行完整操作系统这种令人惊讶的效果。但是，由于每条指令都要由软件来转换和模拟，它也是性能损失最大的虚拟化技术。</li><li>硬件抽象层虚拟化：即以软件或者直接通过硬件来模拟处理器、芯片组、内存、磁盘控制器、显卡等设备的工作过程。如果没有预设语境，一般人们所说的“虚拟机”就是指这一类虚拟化技术。</li><li>操作系统层虚拟化：不会提供真实的操作系统，而是会采用隔离手段，使得不同进程拥有独立的系统资源和资源配额，这样看起来它好像是独享了整个操作系统一般，但其实系统的内核仍然是被不同进程所共享的。操作系统层虚拟化的另一个名字，就是“容器化”。</li><li>运行库虚拟化：运行库虚拟化选择使用软件翻译的方法来模拟系统，它是以一个独立进程来代替操作系统内核，来提供目标软件运行所需的全部能力。如：WINE(在 Linux 下运行 Windows 程序的软件)。</li><li>语言层虚拟化：即由虚拟机将高级语言生成的中间代码，转换为目标机器可以直接执行的指令，代表为 Java 的 JVM 和.NET 的 CLR。</li></ul><h2 id="2-容器化技术"><a href="#2-容器化技术" class="headerlink" title="2. 容器化技术"></a>2. 容器化技术</h2><p>容器技术和思想的起源：chroot 命令，这是计算机操作系统中最早的成规模的隔离技术。</p><h3 id="隔离访问：namespaces"><a href="#隔离访问：namespaces" class="headerlink" title="隔离访问：namespaces"></a>隔离访问：namespaces</h3><p><img src="https://static001.geekbang.org/resource/image/cf/77/cff464f7a2c3b32e5c0194bae3b28177.jpg" alt="namespaces"></p><h3 id="隔离资源：cgroups"><a href="#隔离资源：cgroups" class="headerlink" title="隔离资源：cgroups"></a>隔离资源：cgroups</h3><p><img src="https://static001.geekbang.org/resource/image/e4/1a/e4cab52f2143e17bfc300d62afef2a1a.jpg" alt="cgroups"></p><p>namespaces 和 cgroups 对资源访问与资源配额的隔离，它们不仅是容器化技术的基础，在现代 Linux 操作系统中也已经成为了无可或缺的基石。</p><h3 id="封装系统：LXC-VS-封装应用：Docker"><a href="#封装系统：LXC-VS-封装应用：Docker" class="headerlink" title="封装系统：LXC VS 封装应用：Docker"></a>封装系统：LXC VS 封装应用：Docker</h3><p>Linux 容器（LinuX Containers，LXC），一种封装系统的轻量级虚拟机。以封装系统为出发点，如果仍然是按照先装系统再装软件的思路，就永远无法做到一两分钟甚至十几秒钟就构造出一个合乎要求的软件运行环境。<br>Docker，一种封装应用的技术手段，短短数年Docker就已经成为了软件开发、测试、分发、部署等各个环节都难以或缺的基础支撑。</p><p>为什么要用 Docker 而不是 LXC：跨机器的绿色部署、以应用为中心的封装、自动构建、多版本支持、组件重用、共享、工具生态。</p><h3 id="开放容器交互标准（Open-Container-Initiative，OCI）"><a href="#开放容器交互标准（Open-Container-Initiative，OCI）" class="headerlink" title="开放容器交互标准（Open Container Initiative，OCI）"></a>开放容器交互标准（Open Container Initiative，OCI）</h3><p>在 Docker 的主导和倡议下，多家公司联合制定了OCI，这是一个关于容器格式和运行时的规范文件，其中包含了运行时标准（runtime-spec ）、容器镜像标准（image-spec）和镜像分发标准（distribution-spec，分发标准还未正式发布）。</p><ul><li>运行时标准定义了应该如何运行一个容器、如何管理容器的状态和生命周期、如何使用操作系统的底层特性（namespaces、cgroup、pivot_root 等）；</li><li>容器镜像标准规定了容器镜像的格式、配置、元数据的格式，你可以理解为对镜像的静态描述；</li><li>镜像分发标准则规定了镜像推送和拉取的网络交互过程。</li></ul><h4 id="runC-libcontainer"><a href="#runC-libcontainer" class="headerlink" title="runC / libcontainer"></a>runC / libcontainer</h4><p>Docker 开源了自己用 Golang 开发的libcontainer，这是一个越过 LXC 直接操作 namespaces 和 cgroups 的核心模块，有了 libcontainer 以后，Docker 就能直接与系统内核打交道，不必依赖 LXC 来提供容器化隔离能力了。</p><p>为了符合 OCI 标准，Docker 将 libcontainer 独立出来，封装重构成 runC 项目，并捐献给了 Linux 基金会管理。</p><h4 id="containerd"><a href="#containerd" class="headerlink" title="containerd"></a>containerd</h4><p>这是一个负责管理容器执行、分发、监控、网络、构建、日志等功能的核心模块，其内部会为每个容器运行时创建一个 containerd-shim 适配进程，默认与 runC 搭配工作，但也可以切换到其他 OCI Runtime 实现上（然而实际并没做到，最后 containerd 仍是紧密绑定于 runC）。</p><p>为了能够兼容所有符合标准的 OCI Runtime 实现，Docker 进一步重构了 Docker Daemon 子系统，把其中与运行时交互的部分抽象为了containerd 项目。2016年，Docker 把 containerd 捐献给了 CNCF 管理。</p><p><img src="https://static001.geekbang.org/resource/image/f7/9d/f77990ab74fc001a49997465d070709d.jpg" alt="Docker"></p><h3 id="封装集群：Kubernetes"><a href="#封装集群：Kubernetes" class="headerlink" title="封装集群：Kubernetes"></a>封装集群：Kubernetes</h3><p>它的前身是 Google 内部已经运行多年的集群管理系统 Borg，在 2014 年 6 月使用 Golang 完全重写后开源。</p><p>如果说以 Docker 为代表的容器引擎，是把软件的发布流程从分发二进制安装包，转变为了直接分发虚拟化后的整个运行环境，让应用得以实现跨机器的绿色部署；那以 Kubernetes 为代表的容器编排框架，就是把大型软件系统运行所依赖的集群环境也进行了虚拟化，让集群得以实现跨数据中心的绿色部署，并能够根据实际情况自动扩缩。</p><p><img src="https://static001.geekbang.org/resource/image/d1/05/d1fb0e199a77f621c4034827160b5d05.jpg" alt="Kubernetes"></p><ul><li>kubelet：集群节点中的代理程序，负责与管理集群的 Master 通信。</li><li>容器运行时接口（Container Runtime Interface，CRI）：Kubernetes 1.5 版本开始引入，这是一个定义容器运行时应该如何接入到 kubelet 的规范标准，从此 Kubernetes 内部的 DockerManager，就被更为通用的 KubeGenericRuntimeManager 所替代了。</li><li>DockerShim：由于 CRI 是在 Docker 之后才发布的规范，Docker 是肯定不支持 CRI 的，所以 Kubernetes 又提供了 DockerShim 服务作为 Docker 与 CRI 的适配层，由它与 Docker Engine 以 HTTP 形式通信，从而实现了原来 DockerManager 的全部功能。</li><li>容器运行时接口协调器（Container Runtime Interface Orchestrator，CRI-O）：完全遵循 CRI 规范来实现的，它可以支持所有符合 OCI 运行时标准的容器引擎，默认仍然是与 runC 搭配工作的。</li></ul><h4 id="Kubernetes-是如何一步步与-Docker-解耦的："><a href="#Kubernetes-是如何一步步与-Docker-解耦的：" class="headerlink" title="Kubernetes 是如何一步步与 Docker 解耦的："></a>Kubernetes 是如何一步步与 Docker 解耦的：</h4><ul><li>开源早起，Kubernetes 1.5 之前，通过DockerManager 向 Docker Engine 以 HTTP 方式发送指令：<br>Kubernetes Master → kubelet → DockerManager → Docker Engine → containerd → runC</li><li>2016年，Kubernetes 1.5 开始引入CRI，被更为通用的 KubeGenericRuntimeManager：<br>Kubernetes Master → kubelet → KubeGenericRuntimeManager → DockerShim → Docker Engine → containerd → runC</li><li>2017年，CRI-O发布，支持所有符合 OCI 运行时标准的容器引擎：<br>Kubernetes Master → kubelet → KubeGenericRuntimeManager → CRI-O → runC</li><li>2018年，containerd在CNCF孵化发布1.1版本，完美地支持了 CRI 标准：<br>Kubernetes Master → kubelet → KubeGenericRuntimeManager → containerd → runC</li></ul><h2 id="3-以容器构建系统"><a href="#3-以容器构建系统" class="headerlink" title="3. 以容器构建系统"></a>3. 以容器构建系统</h2><h3 id="Pod-的含义与职责"><a href="#Pod-的含义与职责" class="headerlink" title="Pod 的含义与职责"></a>Pod 的含义与职责</h3><p>扮演容器组的角色，满足容器共享名称空间的需求，是 Pod 两大最基本的职责之一，同处于一个 Pod 内的多个容器，相互之间会以超亲密的方式协作。Pod 的另一个基本职责是实现原子性调度。<br>Pod 是隔离与调度的基本单位，也是我们接触的第一种 Kubernetes 资源。</p><p>超亲密的协作，是特指多个容器位于同一个 Pod 这种特殊关系，它们将默认共享以下名称空间，UTS 名称空间、网络名称空间、IPC 名称空间、时间名称空间，只有 PID 名称空间和文件名称空间默认是隔离的。</p><p><img src="https://static001.geekbang.org/resource/image/c8/5b/c8a5c9337c340cef5fcfd62c60f9815b.jpg" alt="Kubernetes的计算资源"></p><ul><li>容器（Container）：延续了自 Docker 以来一个容器封装一个应用进程的理念，是镜像管理的最小单位。</li><li>生产任务（Pod）：补充了容器化后缺失的与进程组对应的“容器组”的概念，Pod 中的容器共享 UTS、IPC、网络等名称空间，是资源调度的最小单位。</li><li>节点（Node）：对应于集群中的单台机器，这里的机器既可以是生产环境中的物理机，也可以是云计算环境中的虚拟节点，节点是处理器和内存等资源的资源池，是硬件单元的最小单位。</li><li>集群（Cluster）：对应于整个集群，Kubernetes 提倡的理念是面向集群来管理应用。当你要部署应用的时候，只需要通过声明式 API 将你的意图写成一份元数据（Manifests），把它提交给集群即可，而无需关心它具体分配到哪个节点、如何实现 Pod 间通信、如何保证韧性与弹性，等等，所以集群是处理元数据的最小单位。</li><li>集群联邦（Federation）：对应于多个集群，通过联邦可以统一管理多个 Kubernetes 集群，联邦的一种常见应用是支持跨可用区域多活、跨地域容灾的需求。</li></ul><h3 id="控制回路"><a href="#控制回路" class="headerlink" title="控制回路"></a>控制回路</h3><p><img src="https://static001.geekbang.org/resource/image/5e/33/5e3b11dc1ecb84c7d0b7dbac0c9cd733.jpg" alt="控制回路"></p><p>通过描述清楚这些资源的期望状态，由 Kubernetes 中对应监视这些资源的控制器，来驱动资源的实际状态逐渐向期望状态靠拢，才能够达成自己的目的，这种交互风格就被叫做 Kubernetes 的声明式 API。</p><p>资源与控制器是贯穿整个 Kubernetes 的两大设计理念。</p><p>Kubernetes 已内置支持相当多的资源对象，与资源相对应的，只要是实际状态有可能发生变化的资源对象，就通常都会由对应的控制器进行追踪，每个控制器至少会追踪一种类型的资源。</p><p>为了管理众多资源控制器，Kubernetes 设计了统一的控制器管理框架（kube-controller-manager）来维护这些控制器的正常运作，并设计了统一的指标监视器（kube-apiserver），用于在控制器工作时，为它提供追踪资源的度量数据。</p><h2 id="4-以应用为中心的封装"><a href="#4-以应用为中心的封装" class="headerlink" title="4. 以应用为中心的封装"></a>4. 以应用为中心的封装</h2><p>云原生基础设施的其中一个重要目标，是接管掉业务系统复杂的非功能特性，这会让业务研发与运维工作变得足够简单，不受分布式的牵绊。<br>然而，Kubernetes 被诟病得最多的就是复杂，不仅在于繁琐，还在于要想写出合适的元数据描述文件，你既需要懂开发，又需要懂运维，有时候还需要懂平台，一般企业根本找不到合适的角色来为它管理、部署和维护应用。以上提到的复杂性不能说是 Kubernetes 带来的，而是分布式架构本身的原罪。</p><h3 id="Kustomize-和-Helm"><a href="#Kustomize-和-Helm" class="headerlink" title="Kustomize 和 Helm"></a>Kustomize 和 Helm</h3><p>Kustomize 和 Helm，它们是封装“无状态应用”的典型代表。</p><h4 id="Kustomize"><a href="#Kustomize" class="headerlink" title="Kustomize"></a>Kustomize</h4><p>Kustomize 的主要价值是根据环境来生成不同的部署配置。只要建立多个 Kustomization 文件，开发人员就能以基于基准进行派生（Base and Overlay）的方式，对不同的模式（比如生产模式、调试模式）、不同的项目（同一个产品对不同客户的客制化）定制出不同的资源整合包。</p><p>Kustomize 只能简化产品针对不同情况的重复配置，它其实并没有真正解决应用管理复杂的问题，要做的事、要写的配置，最终都没有减少，只是不用反复去写罢了。</p><h4 id="Helm"><a href="#Helm" class="headerlink" title="Helm"></a>Helm</h4><p>如果说 Kubernetes 是云原生操作系统的话，那 Helm 就要成为这个操作系统上面的应用商店与包管理工具。</p><p>Helm 模拟的 Linux 下的包管理工具和封装格式，它提出了与 Linux 包管理直接对应的 Chart 格式和 Repository 应用仓库，另外针对 Kubernetes 中特有的一个应用经常要部署多个版本的特点，也提出了 Release 的专有概念。</p><p>Helm 提供了应用全生命周期、版本、依赖项的管理能力，同时，Helm 还支持额外的扩展插件，能够加入 CI/CD 或者其他方面的辅助功能</p><h3 id="Operator-和-OAM"><a href="#Operator-和-OAM" class="headerlink" title="Operator 和 OAM"></a>Operator 和 OAM</h3><p>有状态应用的两种封装方法，包括 Operator 和 OAM。</p><h4 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h4><p>Operator不应当被称作是一种工具或者系统，它应该算是一种封装、部署和管理 Kubernetes 应用的方法，尤其是针对最复杂的有状态应用去封装运维能力的解决方案。</p><p>Operator 是通过 Kubernetes 1.7 开始支持的自定义资源（Custom Resource Definitions，CRD，此前曾经以 TPR，即 Third Party Resource 的形式提供过类似的能力），把应用封装为另一种更高层次的资源，再把 Kubernetes 的控制器模式从面向内置资源，扩展到了面向所有自定义资源，以此来完成对复杂应用的管理。</p><p>例如 Elasticsearch Operator 提供了一种kind: Elasticsearch的自定义资源，在它的帮助下，只需要十行代码，将用户的意图是“部署三个版本为 7.9.1 的 ES 集群节点”说清楚，就能实现跟前面 StatefulSet 那一大堆配置相同甚至是更强大的效果。</p><h4 id="开放应用模型（Open-Application-Model，OAM）"><a href="#开放应用模型（Open-Application-Model，OAM）" class="headerlink" title="开放应用模型（Open Application Model，OAM）"></a>开放应用模型（Open Application Model，OAM）</h4><p>OAM 思想的核心是将开发人员、运维人员与平台人员的关注点分离，开发人员关注业务逻辑的实现，运维人员关注程序的平稳运行，平台人员关注基础设施的能力与稳定性。</p><p>OAM 对云原生应用的定义是：“由一组相互关联但又离散独立的组件构成，这些组件实例化在合适的运行时上，由配置来控制行为并共同协作提供统一的功能”。</p><h2 id="5-Linux网络虚拟化"><a href="#5-Linux网络虚拟化" class="headerlink" title="5. Linux网络虚拟化"></a>5. Linux网络虚拟化</h2><h3 id="Linux-系统下的网络通信模型"><a href="#Linux-系统下的网络通信模型" class="headerlink" title="Linux 系统下的网络通信模型"></a>Linux 系统下的网络通信模型</h3><p><img src="https://static001.geekbang.org/resource/image/16/ab/16a2c5b7133827bc83f9af9c3d262dab.jpg" alt="Linux系统下的网络通信模型"></p><ul><li>Socket：应用层的程序是通过 Socket 编程接口，来和内核空间的网络协议栈通信的。在这里，应用程序通过读写收、发缓冲区（Receive/Send Buffer）来与 Socket 进行交互。</li><li>TCP/UDP：以 TCP 协议为例，内核发现 Socket 的发送缓冲区中，有新的数据被拷贝进来后，会把数据封装为 TCP Segment 报文，常见的网络协议的报文基本上都是由报文头（Header）和报文体（Body，也叫荷载“Payload”）两部分组成。接着，系统内核将缓冲区中用户要发送出去的数据作为报文体，然后把传输层中的必要控制信息，比如代表哪个程序发、由哪个程序收的源、目标端口号，用于保证可靠通信（重发与控制顺序）的序列号、用于校验信息是否在传输中出现损失的校验和（Check Sum）等信息，封装入报文头中。</li><li>IP：它会把来自上一层（即前面例子中的 TCP 报文）的数据包作为报文体，然后再次加入到自己的报文头中，比如指明数据应该发到哪里的路由地址、数据包的长度、协议的版本号，等等，这样封装成 IP 数据包后再发往下一层。</li><li>Device：Device 即网络设备，它是网络访问层中面向系统一侧的接口。不过这里所说的设备，跟物理硬件设备并不是同一个概念，Device 只是一种向操作系统端开放的接口，它的背后既可能代表着真实的物理硬件，也可能是某段具有特定功能的程序代码，比如即使不存在物理网卡，也依然可以存在回环设备（Loopback Device）。许多网络抓包工具，比如tcpdump、Wirshark就是在此处工作的。Device 主要的作用是抽象出统一的界面，让程序代码去选择或影响收发包出入口，比如决定数据应该从哪块网卡设备发送出去；还有就是准备好网卡驱动工作所需的数据。</li><li>Driver：网卡驱动程序（Driver）是网络访问层中面向硬件一侧的接口，网卡驱动程序会通过DMA把主存中的待发送的数据包，复制到驱动内部的缓冲区之中。数据被复制的同时，也会把上层提供的 IP 数据包、下一跳的 MAC 地址这些信息，加上网卡的 MAC 地址、VLAN Tag 等信息，一并封装成为以太帧（Ethernet Frame），并自动计算校验和。而对于需要确认重发的信息，如果没有收到接收者的确认（ACK）响应，那重发的处理也是在这里自动完成的。</li></ul><h3 id="干预网络通信的-Netfilter-框架"><a href="#干预网络通信的-Netfilter-框架" class="headerlink" title="干预网络通信的 Netfilter 框架"></a>干预网络通信的 Netfilter 框架</h3><p><img src="https://static001.geekbang.org/resource/image/68/e5/688b390674c2de47ce398d2ab8d2a3e5.jpg" alt="应用收、发数据包所经过的Netfilter钩子"></p><ul><li>PREROUTING：来自设备的数据包进入协议栈后，就会立即触发这个钩子。注意，如果 PREROUTING 钩子在进入 IP 路由之前触发了，就意味着只要接收到的数据包，无论是否真的发往本机，也都会触发这个钩子。它一般是用于目标网络地址转换（Destination NAT，DNAT）。</li><li>INPUT：报文经过 IP 路由后，如果确定是发往本机的，将会触发这个钩子，它一般用于加工发往本地进程的数据包。</li><li>FORWARD：报文经过 IP 路由后，如果确定不是发往本机的，将会触发这个钩子，它一般用于处理转发到其他机器的数据包。</li><li>OUTPUT：从本机程序发出的数据包，在经过 IP 路由前，将会触发这个钩子，它一般用于加工本地进程的输出数据包。</li><li>POSTROUTING：从本机网卡出去的数据包，无论是本机的程序所发出的，还是由本机转发给其他机器的，都会触发这个钩子，它一般是用于源网络地址转换（Source NAT，SNAT）。</li></ul><p>以 Netfilter 为基础的应用也有很多，其中使用最广泛的毫无疑问要数 Xtables 系列工具，比如iptables、ebtables、arptables、ip6tables，等等。</p><h3 id="虚拟化网络设备"><a href="#虚拟化网络设备" class="headerlink" title="虚拟化网络设备"></a>虚拟化网络设备</h3><h4 id="网卡：tun-tap、veth"><a href="#网卡：tun-tap、veth" class="headerlink" title="网卡：tun/tap、veth"></a>网卡：tun/tap、veth</h4><p>tun 和 tap 是两个相对独立的虚拟网络设备，其中 tap 模拟了以太网设备，操作二层数据包（以太帧），tun 则是模拟了网络层设备，操作三层数据包（IP 报文）</p><p>使用 tun/tap 设备的目的，其实是为了把来自协议栈的数据包，先交给某个打开了/dev/net/tun字符设备的用户进程处理后，再把数据包重新发回到链路中。这里你可以通俗地理解为，这块虚拟化网卡驱动一端连接着网络协议栈，另一端连接着用户态程序，而普通的网卡驱动则是一端连接着网络协议栈，另一端连接着物理网卡。</p><p>VPN 应用程序：<br><img src="https://static001.geekbang.org/resource/image/3b/ab/3b88a0148da9a84bd782a7e0a0c384ab.jpg?wh=1504*809" alt="VPN中数据流动示意图"></p><p>使用 tun/tap 设备来传输数据需要经过两次协议栈，所以会不可避免地产生一定的性能损耗。</p><p>veth 实际上也不是一个设备，而是一对设备，因而它也常被称作 veth pair。我们要使用 veth，就必须在两个独立的网络名称空间中进行才有意义，因为 veth pair 是一端连着协议栈，另一端彼此相连的，在 veth 设备的其中一端输入数据，这些数据就会从设备的另一端原样不动地流出。<br><img src="https://static001.geekbang.org/resource/image/cd/67/cd90382e98805d560810b23f4f273367.jpg?wh=553*336" alt="veth pair工作示意图"></p><p>两个容器之间采用 veth 通信，不需要反复多次经过网络协议栈，这就让 veth 比起 tap/tun 来说，具备了更好的性能，也让 veth pair 的实现变得十分简单。</p><h4 id="交换机：Linux-Bridge"><a href="#交换机：Linux-Bridge" class="headerlink" title="交换机：Linux Bridge"></a>交换机：Linux Bridge</h4><p>二层转发、泛洪、STP、MAC 学习、地址转发表，等等。<br>它与普通的物理交换机也还是有一点差别的，普通交换机只会单纯地做二层转发，Linux Bridge 却还支持把发给它自身的数据包，接入到主机的三层协议栈中。</p><p><img src="https://static001.geekbang.org/resource/image/9b/af/9bb747d54574ee8cbd9c4e22d16124af.jpg?wh=682*534" alt="Linux Bridge构建单IP容器网络"></p><h4 id="网络：VXLAN"><a href="#网络：VXLAN" class="headerlink" title="网络：VXLAN"></a>网络：VXLAN</h4><p>软件定义网络（Software Defined Network，SDN）的需求在云计算和分布式时代，就变得前所未有地迫切。SDN 的核心思路是在物理的网络之上，再构造一层虚拟化的网络，把控制平面和数据平面分离开来，实现流量的灵活控制，为核心网络及应用的创新提供良好的平台。</p><p>SDN 里，位于下层的物理网络被称为 Underlay，它着重解决网络的连通性与可管理性；位于上层的逻辑网络被称为 Overlay，它着重为应用提供与软件需求相符的传输服务和网络拓扑。以 VXLAN 为例，给你介绍 Overlay 网络的原理。</p><p>为了解决 VLAN 的两个明显的缺陷（VLAN Tag 的设计、跨数据中心传递），IETF 定义了 VXLAN 规范，这是三层虚拟化网络（Network Virtualization over Layer 3，NVO3）的标准技术规范之一，是一种典型的 Overlay 网络。</p><p>VXLAN 对网络基础设施的要求很低，不需要专门的硬件提供特别支持，只要三层可达的网络就能部署 VXLAN。<br>VXLAN 带来了很高的灵活性、扩展性和可管理性，VXLAN也带来了额外的复杂度和性能开销（传输效率的下降、传输性能的下降）</p><h4 id="副本网卡：MACVLAN"><a href="#副本网卡：MACVLAN" class="headerlink" title="副本网卡：MACVLAN"></a>副本网卡：MACVLAN</h4><p>两个 VLAN 之间位于独立的广播域，是完全二层隔离的，要通信就只能通过三层设备。而最简单的三层通信就是靠单臂路由了。单臂路由那把路由器上的两个接口分别设置不同的 IP 地址，然后用两条网线分别连接到交换机上，也勉强算是一个解决办法，但 VLAN 最多可以支持 4096 个 VLAN，那如果要接四千多条网线就太离谱了。因此为了解决这个问题，802.1Q 规范中专门定义了子接口（Sub-Interface）的概念，它的作用是允许在同一张物理网卡上，针对不同的 VLAN 绑定不同的 IP 地址。</p><p>MACVLAN 就借用了 VLAN 子接口的思路，并且在这个基础上更进一步，不仅允许对同一个网卡设置多个 IP 地址，还允许对同一张网卡上设置多个 MAC 地址，这也是 MACVLAN 名字的由来。</p><p><img src="https://static001.geekbang.org/resource/image/17/da/177318346dbc945526c064cf618f30da.jpg?wh=1696*1125" alt="MACVLAN原理"></p><p>虽然容器间的网络方案多种多样，但通信主体都是固定的，不外乎没有物理设备的虚拟主体（容器、Pod、Service、Endpoints 等等）、不需要跨网络的本地主机、以及通过网络连接的外部主机三种层次。所有的容器网络通信问题，其实都可以归结为本地主机内部的多个容器之间、本地主机与内部容器之间，以及跨越不同主机的多个容器之间的通信问题。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;周志明《凤凰架构：构建可靠的大型分布式系统》&lt;br&gt;&lt;a href=&quot;https://icyfenix.cn/&quot;&gt;https://icyfenix.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;围绕“不可变基础设施”的相关话题，以容器、编排系统和服务网格的发展为主线，介绍虚拟化容器与服务网格是如何模糊掉软件与硬件之间的界限，如何在基础设施与通讯层面上帮助微服务隐藏复杂性，以此解决原本只能由程序员通过软件编程来解决的分布式问题。&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="技术" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="凤凰架构" scheme="http://www.lights8080.com/tags/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>凤凰架构-分布式基石</title>
    <link href="http://www.lights8080.com/p/846371ce.html"/>
    <id>http://www.lights8080.com/p/846371ce.html</id>
    <published>2021-10-25T16:00:00.000Z</published>
    <updated>2021-11-03T07:49:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>周志明《凤凰架构：构建可靠的大型分布式系统》<br><a href="https://icyfenix.cn/">https://icyfenix.cn/</a></p><p>包括：分布式共识、服务发现、网关、负载均衡、服务容错、限流、零信任网络安全、可观测性</p><span id="more"></span><h2 id="1-分布式共识"><a href="#1-分布式共识" class="headerlink" title="1. 分布式共识"></a>1. 分布式共识</h2><h3 id="可靠与可用、共识与一致"><a href="#可靠与可用、共识与一致" class="headerlink" title="可靠与可用、共识与一致"></a>可靠与可用、共识与一致</h3><p>状态转移（State Transfer）：以同步为代表的数据复制方法。这类方法属于比较符合人类思维的可靠性保障手段，但通常要以牺牲可用性为代价。<br>操作转移（Operation Transfer）：在分布式系统里主流的数据复制方法是，通过某种操作，把源状态转换为目标状态。</p><p>让系统各节点不受局部的网络分区、机器崩溃、执行性能或者其他因素影响，能最终表现出整体一致的过程，就是各个节点的协商共识（Consensus）。<br>共识（Consensus）与一致性（Consistency）是有区别的：一致性指的是数据不同副本之间的差异，而共识是指达成一致性的方法与过程。</p><h3 id="Paxos-算法"><a href="#Paxos-算法" class="headerlink" title="Paxos 算法"></a>Paxos 算法</h3><p>Paxos 算法：一种基于消息传递的协商共识算法，几乎就是“共识”这两字的代名词了。<br>Paxos 算法将分布式系统中的节点分为提案节点、决策节点和记录节点三类，包括“准备（Prepare）”和“批准（Accept）”两个阶段。</p><h3 id="Raft-算法"><a href="#Raft-算法" class="headerlink" title="Raft 算法"></a>Raft 算法</h3><p>Multi Paxos 对 Basic Paxos 的核心改进是，增加了“选主”的过程。<br>以上这种把共识问题分解为“Leader Election”、“Entity Replication”和“Safety”三个问题来思考、解决的解题思路，就是Raft 算法。</p><p><a href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a></p><h3 id="Gossip-协议"><a href="#Gossip-协议" class="headerlink" title="Gossip 协议"></a>Gossip 协议</h3><p>Paxos、Raft、ZAB 等分布式算法经常会被称作是“强一致性”的分布式共识协议。<br>强一致性的意思是“尽管系统内部节点可以存在不一致的状态，但从系统外部看来，不一致的情况并不会被观察到，所以整体上看系统是强一致性的”。<br>Gossip 协议，是一种很有代表性的“最终一致性”的分布式共识协议。</p><h2 id="2-服务发现"><a href="#2-服务发现" class="headerlink" title="2. 服务发现"></a>2. 服务发现</h2><p>如何确定目标方法的确切位置，便是与编译链接有着等同意义的问题，解决该问题的过程，就被叫做“服务发现”（Service Discovery）。服务发现要解决注册、维护和发现三大功能问题。</p><p>因为远程服务的多样性，导致了“服务发现”也会有两种不同的理解：<br>一种是以 UDDI 为代表的“百科全书式”的服务发现。<br>另一种是类似于 DNS 这样的“门牌号码式”的服务发现。(主流地位)</p><h3 id="服务发现需要有效权衡一致性与可用性的矛盾"><a href="#服务发现需要有效权衡一致性与可用性的矛盾" class="headerlink" title="服务发现需要有效权衡一致性与可用性的矛盾"></a>服务发现需要有效权衡一致性与可用性的矛盾</h3><p>对系统的可用性和可靠性的取舍不同，对服务发现框架的具体实现也有着决定性的影响。</p><p>第一类：在分布式 K/V 存储框架上自己实现的服务发现：<br>Etcd 采用的是我们学习过的 Raft 算法，ZooKeeper 采用的是 ZAB 算法。</p><p>第二类：以基础设施（主要是指 DNS 服务器）来实现服务发现<br>Kubernetes 1.3 之后，SkyDNS 不再是默认的 DNS 服务器：AP。</p><p>第三类：专门用于服务发现的框架和工具<br>Consul：CP，Eureka：AP，Nacos：同时支持CP和AP(二选一)。</p><h2 id="3-网关"><a href="#3-网关" class="headerlink" title="3. 网关"></a>3. 网关</h2><p>网关 = 路由器（基础职能） + 过滤器（可选职能）<br>在“路由”这个基础职能里，服务网关主要考虑的是能够支持路由的“网络层次与协议”和“性能与可用性”两方面的因素。</p><p>BFF（Backends for Frontends）：网关不必为所有的前端提供无差别的服务，而是应该针对不同的前端，聚合不同的服务，提供不同的接口和网络访问协议支持。</p><h3 id="网络层次与协议"><a href="#网络层次与协议" class="headerlink" title="网络层次与协议"></a>网络层次与协议</h3><p>负载均衡器与服务网关的区别在于，前者是为了根据均衡算法对流量进行平均地路由，后者是为了根据流量中的某种特征进行正确地路由。</p><h3 id="性能与可用性"><a href="#性能与可用性" class="headerlink" title="性能与可用性"></a>性能与可用性</h3><p>我们可以把网络 I/O 模型总结为两类、五种模型。两类是指同步 I/O 与异步 I/O；五种是指在同步 I/O 中又划分出了阻塞 I/O、非阻塞 I/O、多路复用 I/O 和信号驱动 I/O 四种细分模型。</p><p>多路复用 I/O 还可以细分 select、epoll、kqueue 等不同实现。<br>信号驱动 I/O 与异步 I/O 的区别是“从缓冲区获取数据”这个步骤的处理，</p><p>在网关的可用性方面，我们应该考虑到以下几点：网关应尽可能轻量、应该尽可能选择较成熟的产品实现、在网关之前部署负载均衡器或者等价路由器（ECMP）。</p><h2 id="4-负载均衡"><a href="#4-负载均衡" class="headerlink" title="4. 负载均衡"></a>4. 负载均衡</h2><p>分为集中式的负载均衡（Nginx）、客户端负载均衡器（Netflix Ribbon）、代理客户端负载均衡器（Service Mesh）</p><h3 id="Region"><a href="#Region" class="headerlink" title="Region"></a>Region</h3><p>Region 是地域的意思，比如华北、东北、华东、华南，这些都是地域范围。不同的地域之间是没有内网连接的。</p><h3 id="Zone"><a href="#Zone" class="headerlink" title="Zone"></a>Zone</h3><p>Zone 是区域的意思，它是可用区域（Availability Zones）的简称。区域的意思是在地理上位于同一地域内，但电力和网络是互相独立的物理区域，比如在华东的上海、杭州、苏州的不同机房，就是同一个地域的几个可用区域。同一个地域的区域之间具有内网连接，流量不占用公网带宽，因此区域是微服务集群内，流量能够触及的最大范围。</p><p>异地容灾和异地双活的差别：容灾是非实时的同步，而双活是实时或者准实时的，跨地域或者跨区域做容灾都可以，但只能一般只能跨区域做双活，当然你也可以将它们结合起来同时使用，即“两地三中心”模式。</p><h2 id="5-服务容错"><a href="#5-服务容错" class="headerlink" title="5. 服务容错"></a>5. 服务容错</h2><p>容错策略，指的是“面对故障，我们该做些什么”；而容错设计模式，指的是“要实现某种容错策略，我们该如何去做”。</p><h3 id="容错策略"><a href="#容错策略" class="headerlink" title="容错策略"></a>容错策略</h3><p>7 种常见的容错策略，包括故障转移、快速失败、安全失败、沉默失败、故障恢复、并行调用和广播调用。</p><p><img src="https://static001.geekbang.org/resource/image/da/7c/da6e01c336443bd125ff94bb4be3997c.jpg" alt="容错策略"></p><h3 id="容错设计模式"><a href="#容错设计模式" class="headerlink" title="容错设计模式"></a>容错设计模式</h3><p>微服务中常见的断路器模式、舱壁隔离模式和超时重试模式等，以及流量控制模式，比如滑动时间窗模式、漏桶模式、令牌桶模式，等等。</p><h4 id="断路器模式"><a href="#断路器模式" class="headerlink" title="断路器模式"></a>断路器模式</h4><p>断路器一般可以设置为 CLOSED、OPEN 和 HALF OPEN 三种状态。</p><p>服务熔断和服务降级之间的联系与差别：</p><ul><li>断路器做的事情是自动进行服务熔断，属于一种快速失败的容错策略的实现方法。</li><li>服务降级是上游服务必须能够主动处理调用失败的后果，也不一定是在出现错误后才被动执行的，我们在很多场景中谈论的降级更可能是指，需要主动迫使服务进入降级逻辑的情况。</li></ul><h4 id="舱壁隔离模式"><a href="#舱壁隔离模式" class="headerlink" title="舱壁隔离模式"></a>舱壁隔离模式</h4><p>服务隔离，就是避免某一个远程服务的局部失败影响到全局，而设置的一种止损方案。</p><h4 id="重试模式"><a href="#重试模式" class="headerlink" title="重试模式"></a>重试模式</h4><p>我们判断是否应该且是否能够对一个服务进行重试时，要看是否同时满足下面 4 个条件。</p><ol><li>仅在主路逻辑的关键服务上进行同步的重试</li><li>仅对由瞬时故障导致的失败进行重试</li><li>仅对具备幂等性的服务进行重试</li><li>重试必须有明确的终止条件，常用的终止条件有超时终止和次数终止两种</li></ol><h2 id="6-限流"><a href="#6-限流" class="headerlink" title="6. 限流"></a>6. 限流</h2><p>任何一个系统的运算、存储、网络资源都不是无限的，当系统资源不足以支撑外部超过预期的突发流量时，就应该要有取舍，建立面对超额流量自我保护的机制，而这个机制就是微服务中常说的“限流”。</p><h3 id="流量统计指标"><a href="#流量统计指标" class="headerlink" title="流量统计指标"></a>流量统计指标</h3><p>每秒事务数（Transactions per Second，TPS）：是衡量信息系统吞吐量的最终标准，逻辑上具备原子性的业务操作。(最希望的限流指标)<br>每秒请求数（Hits per Second，HPS）：每秒从客户端发向服务端的请求数。(首选的限流指标，相对容易观察统计)<br>每秒查询数（Queries per Second，QPS）：一台服务器能够响应的查询次数。</p><p>限流设计模式包括流量计数器、滑动时间窗、漏桶和令牌桶。</p><h2 id="7-零信任网络安全"><a href="#7-零信任网络安全" class="headerlink" title="7. 零信任网络安全"></a>7. 零信任网络安全</h2><h3 id="基于边界的安全模型"><a href="#基于边界的安全模型" class="headerlink" title="基于边界的安全模型"></a>基于边界的安全模型</h3><p>边界安全着重检查的是经过网络区域边界的流量，而对可信任区域（内网）内部机器之间的流量，会给予直接信任、或者至少是较为宽松的处理策略，这样就减小了安全设施对整个应用系统复杂度的影响，以及网络传输性能的额外损耗。如VPN、DMZ、防火墙、内网、外网，这些概念，都是基于边界的安全模型。</p><h3 id="零信任安全模型"><a href="#零信任安全模型" class="headerlink" title="零信任安全模型"></a>零信任安全模型</h3><p>零信任安全的中心思想是不应当以某种固有特征来自动信任任何流量，除非明确得到了能代表请求来源（不一定是人，更可能是另一台服务）的身份凭证，否则一律不会有默认的信任关系。</p><p><img src="https://static001.geekbang.org/resource/image/36/f9/363a4d538e4d4a3a15d87258dyy59ef9.jpg" alt="传统的基于边界的网络安全模型，与云原生时代下基于零信任网络的安全模型之间的差异"></p><h3 id="建立信任"><a href="#建立信任" class="headerlink" title="建立信任"></a>建立信任</h3><ul><li>单向 TLS 认证：只需要服务端提供证书，客户端通过服务端证书验证服务器的身份，但服务器并不验证客户端的身份。单向 TLS 用于公开的服务，即任何客户端都被允许连接到服务进行访问，它保护的重点是客户端免遭冒牌服务器的欺骗。</li><li>双向 TLS 认证：客户端、服务端双方都要提供证书，双方各自通过对方提供的证书来验证对方的身份。双向 TLS 用于私密的服务，即服务只允许特定身份的客户端访问，它除了保护客户端不连接到冒牌服务器外，也保护服务端不遭到非法用户的越权访问。</li></ul><p>认证分为两种类型，一种是以机器作为认证对象，即访问服务的流量来源是另外一个服务，这被叫做服务认证（Peer Authentication，直译过来是“节点认证”）；另一种是以人类作为认证对象，即访问服务的流量来自于最终用户，这被叫做请求认证（Request Authentication）。</p><h4 id="服务认证"><a href="#服务认证" class="headerlink" title="服务认证"></a>服务认证</h4><ul><li>Istio：无需改动任何代码，启用 mTLS 认证，且提供了宽容模式，宽容模式为普通微服务向服务网格迁移提供了良好的灵活性。</li><li>spring cloud：在应用层面去实现，使用OAuth 2.0协议进行认证。客户端在调用服务时，会先使用该密钥向认证服务器申请到 JWT 令牌，然后通过令牌证明自己的身份，最后访问服务。</li></ul><h4 id="请求认证"><a href="#请求认证" class="headerlink" title="请求认证"></a>请求认证</h4><ul><li>Istio：能够自动根据配置中的JWKS验证验证请求中附带的 JWT 是否合法，整个认证过程不需要应用程序参与。JWKS 就是一组 JWK 的集合。支持 JWKS 的系统，能通过 JWT 令牌 Header 中的 KID（Key ID）自动匹配出应该使用哪个 JWK 来验证签名。</li><li>spring cloud：Spring Security 已经做好了认证所需的绝大部分工作，真正要开发者去编写的代码就是令牌的具体实现。</li></ul><h4 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h4><p>经过认证之后，合法的调用者就有了可信任的身份，此时就不再需要区分调用者到底是机器（服务）还是人类（最终用户）了，只需要根据其身份角色来进行权限访问控制就行，即我们常说的 RBAC。分别针对来自“服务”和“用户”的流量来控制权限和访问范围。</p><ul><li>Istio：便捷性、安全性、无侵入、统一管理</li><li>spring cloud：一种是使用ExpressionUrlAuthorizationConfigurer，通过编码进行集中配置，第二种是使用@RolesAllowed、@PreAuthorize，以注解的形式分散写到每个服务甚至是每个方法中。</li></ul><h2 id="8-可观测性"><a href="#8-可观测性" class="headerlink" title="8. 可观测性"></a>8. 可观测性</h2><p>可观测性原本的含义是“可以由系统的外部输出推断其内部状态的程度”。不过实际上，计算机科学中关于可观测性的研究内容已经有了很多年的实践积累。通常，人们会把可观测性分解为三个更具体的方向进行研究，分别是：日志收集、链路追踪和聚合度量。</p><h3 id="日志（Logging）"><a href="#日志（Logging）" class="headerlink" title="日志（Logging）"></a>日志（Logging）</h3><p>日志主要是用来记录系统运行期间发生过的离散事件。<br>在日志领域，日志收集和分析大多被统一到了 Elastic Stack（ELK）技术栈上。<br>ELK 在一定程度上也可以代替度量和追踪系统，实现它们的部分职能，对于大型系统，建议还是让专业的工具去做专业的事情。</p><h4 id="日志的记录"><a href="#日志的记录" class="headerlink" title="日志的记录"></a>日志的记录</h4><p>好的日志要能够毫无遗漏地记录信息、格式统一、内容恰当，而“恰当”的真正含义是指日志中不该出现的内容不要有，而该有的不要少。</p><ul><li>“不应该有”的日志内容：避免打印敏感信息、避免引用慢操作、避免打印追踪诊断信息、避免误导他人。</li><li>“不应该少”的日志内容：处理请求时的 TraceID、系统运行过程中的关键事件、启动时输出配置信息</li></ul><h4 id="分布式系统处理日志"><a href="#分布式系统处理日志" class="headerlink" title="分布式系统处理日志"></a>分布式系统处理日志</h4><p>分布式系统处理一个请求要跨越多个服务节点，因此当每个节点输出日志到文件后，就必须要把日志文件统一收集起来，集中存储、索引，而这正是日志收集器需要做的工作。此外，日志收集器还要尽力保证日志数据的连续性。</p><h4 id="日志的查询、统计、聚合等操作"><a href="#日志的查询、统计、聚合等操作" class="headerlink" title="日志的查询、统计、聚合等操作"></a>日志的查询、统计、聚合等操作</h4><p>由于日志是非结构化数据，因此我们需要进行加工，把日志行中的非结构化数据转换为结构化数据，以便针对不同的数据项来建立索引，进行条件查询、统计、聚合等操作。</p><ul><li>一种解决方案是通过 Elasticsearch 本身的处理能力做实时的聚合统计，应对于即席查询。</li><li>另一种解决方案是在收集日志后自动生成某些常用的、固定的聚合指标，这种聚合就会在 Logstash 中通过聚合插件来完成，更多是用于应对固定查询。</li></ul><h3 id="追踪（Tracing）"><a href="#追踪（Tracing）" class="headerlink" title="追踪（Tracing）"></a>追踪（Tracing）</h3><p>从广义上讲，一个完整的分布式追踪系统，应该由数据收集、数据存储和数据展示三个相对独立的子系统构成；而从狭义上讲，则就只是特指链路追踪数据的收集部分。比如Spring Cloud Sleuth就属于狭义的追踪系统，通常会搭配 Zipkin 作为数据展示，搭配 Elasticsearch 作为数据存储来组合使用。</p><p>所有业界有名的追踪系统，无论是国外 Twitter 的Zipkin、Naver 的Pinpoint，还是国内阿里的鹰眼、大众点评的CAT、个人开源的SkyWalking（后来进入 Apache 基金会孵化毕业），都受到了 Dapper 论文（Google 在 2010 年发表）的直接影响。</p><p>Dapper 提出了“追踪”（Trace）与“跨度”（Span）两个概念，每一次 Trace 都是由若干个有顺序、有层级关系的 Span 所组成一颗“追踪树”（Trace Tree）</p><p>数据收集的三种主流实现方式：基于日志的追踪、基于服务的追踪、基于边车代理的追踪。</p><h4 id="基于日志的追踪"><a href="#基于日志的追踪" class="headerlink" title="基于日志的追踪"></a>基于日志的追踪</h4><p>日志追踪对网络消息完全没有侵入性，对应用程序只有很少量的侵入性，对性能的影响也非常低。<br>缺点是直接依赖于日志归集过程，由于日志归集不及时或者精度丢失，导致日志出现延迟或缺失记录，进而产生追踪失真的情况。<br>日志追踪的代表产品是 Spring Cloud Sleuth。</p><h4 id="基于服务的追踪"><a href="#基于服务的追踪" class="headerlink" title="基于服务的追踪"></a>基于服务的追踪</h4><p>是目前最为常见的追踪实现方式，实现思路是通过某些手段给目标应用注入追踪探针。<br>基于服务的追踪会比基于日志的追踪消耗更多的资源，也具有更强的侵入性，而换来的收益就是追踪的精确性与稳定性都有所保证，不必再依靠日志归集来传输追踪数据。<br>Zipkin、SkyWalking、Pinpoint 等主流追踪系统广泛采用。</p><h4 id="基于边车代理的追踪"><a href="#基于边车代理的追踪" class="headerlink" title="基于边车代理的追踪"></a>基于边车代理的追踪</h4><p>基于边车代理的追踪是服务网格的专属方案，也是最理想的分布式追踪模型，它对应用完全透明，无论是日志还是服务本身，都不会有任何变化。<br>市场占有率最高的边车代理Envoy就提供了相对完善的追踪功能。</p><h4 id="追踪规范化"><a href="#追踪规范化" class="headerlink" title="追踪规范化"></a>追踪规范化</h4><p>当初 Google 发表的 Dapper 只是论文，而不是有约束力的规范标准，它只提供了思路，并没有规定细节。<br>为了推进追踪领域的产品标准化，2016 年 11 月，CNCF 技术委员会接受了 OpenTracing 作为基金会的第三个项目。<br>Google 在这个时候出来表示反对，并提出了与 OpenTracing 目标类似的 OpenCensus 规范，随后又得到了巨头 Microsoft 的支持和参与。<br>2019 年，OpenTracing 和 OpenCensus 又忽然宣布握手言和，它们共同发布了可观测性的终极解决方案OpenTelemetry，并宣布会各自冻结 OpenTracing 和 OpenCensus 的发展。</p><h3 id="度量（Metrics）"><a href="#度量（Metrics）" class="headerlink" title="度量（Metrics）"></a>度量（Metrics）</h3><p>度量（Metrics）的目的是揭示系统的总体运行状态，更重要目的是监控（Monitoring）和预警（Alert）。<br>度量就是用经过聚合统计后的高维度信息，以最简单直观的形式来总结复杂的过程，为监控、预警提供决策支持。<br>在总体上，度量可以分为客户端的指标收集、服务端的存储查询以及终端的监控预警三个相对独立的过程，每个过程在系统中一般也会设置对应的组件来实现。</p><h4 id="指标收集"><a href="#指标收集" class="headerlink" title="指标收集"></a>指标收集</h4><p>如何定义指标？数据类型（Metrics Types）：</p><ul><li>计数度量器（Counter）：对有相同量纲、可加减数值的合计量</li><li>瞬态度量器（Gauge）：表示某个指标在某个时点的数值</li><li>吞吐率度量器（Meter）：用于统计单位时间的吞吐量，即单位时间内某个事件的发生次数</li><li>直方图度量器（Histogram）：二维统计图，它的两个坐标分别是统计样本和该样本对应的某个属性的度量，以长条图的形式记录具体数值</li><li>采样点分位图度量器（Quantile Summary）：通过比较各分位数的分布情况的工具，主要用来验证实际值与理论值的差距，评估理论值与实际值之间的拟合度</li></ul><p>如何将这些指标告诉服务端？<br>通常有两种解决方案：拉取式采集（Pull-Based Metrics Collection）和推送式采集（Push-Based Metrics Collection）</p><p>Prometheus 在基于 Pull 架构的同时，还能够有限度地兼容 Push 式采集。</p><h4 id="存储查询"><a href="#存储查询" class="headerlink" title="存储查询"></a>存储查询</h4><p>时序数据库：时序数据库是用于存储跟随时间而变化的数据，并且以时间（时间点或者时间区间）来建立索引的数据库。它具有不变性、唯一性、有序性。时序数据库同时具有数据结构简单、数据量大的特点。</p><p>Prometheus 服务端自己就内置了一个强大的时序数据库实现，在DB-Engines中近几年它的排名就在不断提升。</p><h4 id="监控预警"><a href="#监控预警" class="headerlink" title="监控预警"></a>监控预警</h4><p>广义上的度量系统由面向目标系统进行指标采集的客户端，负责调度、存储和提供查询能力的服务端，以及面向最终用户的终端组成。<br>狭义上的度量系统就只包括客户端和服务端，不包含终端。</p><p>大多是 Prometheus 配合 Grafana 来进行展示的，这是 Prometheus 官方推荐的组合方案。</p><p>良好的可视化能力对于提升度量系统的产品力也非常重要，长期趋势分析、对照分析、故障分析等分析工作，既需要度量指标的持续收集、统计，往往还需要对数据进行可视化，这样才能让人更容易地从数据中挖掘规律，毕竟数据最终还是要为人类服务的。</p><p>传统监控和可观测性之间的关键区别在于：可观测性是系统或服务内在的固有属性，而不是在系统之外对系统所做出的额外增强，后者是传统监控的处理思路。</p><p>Prometheus 提供了专门用于预警的 Alert Manager。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;周志明《凤凰架构：构建可靠的大型分布式系统》&lt;br&gt;&lt;a href=&quot;https://icyfenix.cn/&quot;&gt;https://icyfenix.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;包括：分布式共识、服务发现、网关、负载均衡、服务容错、限流、零信任网络安全、可观测性&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="技术" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="凤凰架构" scheme="http://www.lights8080.com/tags/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>凤凰架构-架构安全性</title>
    <link href="http://www.lights8080.com/p/ac30aed0.html"/>
    <id>http://www.lights8080.com/p/ac30aed0.html</id>
    <published>2021-10-20T16:00:00.000Z</published>
    <updated>2021-10-25T09:34:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>周志明《凤凰架构：构建可靠的大型分布式系统》<br><a href="https://icyfenix.cn/">https://icyfenix.cn/</a></p><p>包括：认证、授权、凭证、保密、传输、验证</p><span id="more"></span><p>系统安全，不仅包括“防御系统被黑客攻击”这样狭隘的安全，还包括一些与管理、运维、审计等领域主导的相关安全性问题，比如说安全备份与恢复、安全审计、防治病毒，等等。</p><p>软件架构安全，主要包括（但不限于）以下这些问题的具体解决方案：认证、授权、凭证、保密、传输、验证。</p><p>这些问题基本上也都是与具体系统、具体业务无关的通用性问题，这就意味着它们往往会存在一些业界通行的、已经被验证过是行之有效的解决方案，乃至已经形成了行业标准，不需要我们再从头去构思如何解决。</p><h2 id="认证（Authentication）"><a href="#认证（Authentication）" class="headerlink" title="认证（Authentication）"></a>认证（Authentication）</h2><blockquote><p>系统如何正确分辨出操作用户的真实身份？</p></blockquote><p>认证（Authentication）、授权（Authorization）和凭证（Credentials）这三项可以说是一个系统中最基础的安全设计了。<br>信息系统在为用户提供服务之前，总是希望先弄清楚“你是谁？”（认证）、“你能干什么？”（授权）以及“你如何证明？”（凭证）这三个基本问题的答案。</p><p>架构安全性的经验原则：以标准规范为指导、以标准接口去实现，严格遵循标准就是最恰当的安全设计。</p><h4 id="基于通讯协议：HTTP-认证"><a href="#基于通讯协议：HTTP-认证" class="headerlink" title="基于通讯协议：HTTP 认证"></a>基于通讯协议：HTTP 认证</h4><p>IETF 在RFC 7235中定义了 HTTP 协议的通用认证框架，要求所有支持 HTTP 协议的服务器，当未授权的用户意图访问服务端保护区域的资源时，应返回 401 Unauthorized 的状态码，同时要在响应报文头里，附带以下两个分别代表网页认证和代理认证的 Header 之一，告知客户端应该采取哪种方式，产生能代表访问者身份的凭证信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WWW-Authenticate: &lt;认证方案&gt; realm=&lt;保护区域的描述信息&gt;</span><br><span class="line">Proxy-Authenticate: &lt;认证方案&gt; realm=&lt;保护区域的描述信息&gt;</span><br></pre></td></tr></table></figure><p>客户端必须遵循服务端指定的认证方案，在请求资源的报文头中加入身份凭证信息，服务端核实通过后才会允许该请求正常返回，否则将返回 403 Forbidden。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Authorization: &lt;认证方案&gt; &lt;凭证内容&gt;</span><br><span class="line">Proxy-Authorization: &lt;认证方案&gt; &lt;凭证内容&gt;</span><br></pre></td></tr></table></figure><p><em>HTTP 认证框架提出的认证方案，是希望能把认证“要产生身份凭证”的目的，与“具体如何产生凭证”的实现给分开来。</em></p><p>认证方案：</p><ul><li>Basic：是一种以演示为目的的认证方案，Basic 认证产生用户身份凭证的方法是让用户输入用户名和密码，经过 Base64 编码“加密”后作为身份凭证。</li><li>Digest：HTTP 摘要认证，可以把它看作是 Basic 认证的改良版本，针对 Base64 明文发送的风险，Digest 认证把用户名和密码加盐后，再通过 MD5/SHA 等哈希算法取摘要发送出去。</li><li>Bearer：基于 OAuth 2.0 规范来完成认证，OAuth 2.0 是一个同时涉及到认证与授权的协议。</li><li>HOBA：一种基于自签名证书的认证方案。</li><li>其他：很多厂商也扩展了自己的认证方案，如AWS4-HMAC-SHA256、Twitter Basic等。</li></ul><h4 id="基于通讯内容：Web-认证"><a href="#基于通讯内容：Web-认证" class="headerlink" title="基于通讯内容：Web 认证"></a>基于通讯内容：Web 认证</h4><p>但目前的信息系统，直接采用 HTTP 认证框架的比例其实是非常低的。以 HTTP 协议为基础的认证框架，也只能面向传输协议而不是具体传输内容来设计。</p><p>如果用户访问信息系统中的具体服务，身份认证肯定希望是由系统本身的功能去完成的，而不是由 HTTP 服务器来负责认证。</p><p>这种依靠内容而不是传输协议来实现的认证方式，被称为“Web 认证”，由于在实现形式上，登录表单占了绝对的主流，因此它通常也被称为“表单认证”。</p><p><em>表单认证与 HTTP 认证不见得是完全对立的，它们分别有不同的关注点，可以结合使用。</em></p><h4 id="WebAuthn"><a href="#WebAuthn" class="headerlink" title="WebAuthn"></a>WebAuthn</h4><p>万维网联盟批准了由FIDO（Fast IDentity Online，一个安全、开放、防钓鱼、无密码认证标准的联盟）领导起草的世界首份 Web 内容认证的标准“WebAuthn”。</p><p>Web 表单长什么样，没有什么行业标准可循，允许做的五花八门，用户名密码、扫码、图形验证码等，都可以自行决定认证的全套交互细节。这些登录表单提交之前进行必要的表单校验，确实不太可能定义在规范上。<br>所以，WebAuthn 彻底抛弃了传统的密码登录方式，改为直接采用生物识别（指纹、人脸、虹膜、声纹）或者实体密钥（以 USB、蓝牙、NFC 连接的物理密钥容器）来作为身份凭证。</p><h2 id="授权（-Authorization）"><a href="#授权（-Authorization）" class="headerlink" title="授权（ Authorization）"></a>授权（ Authorization）</h2><blockquote><p>系统如何控制一个用户该看到哪些数据、能操作哪些功能？</p></blockquote><p>授权涉及到两个相对独立的问题<br>1）确保授权的过程可靠，主要有OAuth 2.0 和 SAML 2.0<br>2）确保授权的结果可控，对资源的访问控制模型，主要有RBAC、ABAC</p><h3 id="OAuth-2-0"><a href="#OAuth-2-0" class="headerlink" title="OAuth 2.0"></a>OAuth 2.0</h3><p>OAuth 2.0 解决的是第三方服务中涉及的安全授权问题，是面向于解决第三方应用（Third-Party Application）的认证授权协议。</p><p>可参考阮一峰老师讲解：<a href="https://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html">https://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html</a></p><p>OAuth 2.0 提出了四种不同的授权方式，包括授权码模式、简化模式、密码模式、客户端模式。</p><h4 id="授权码模式（Authorization-Code）"><a href="#授权码模式（Authorization-Code）" class="headerlink" title="授权码模式（Authorization Code）"></a>授权码模式（Authorization Code）</h4><p>授权码模式是四种模式中最严谨的，第三方应用必须有应用服务器，要求服务器地址必须与注册时提供的地址一致。<br>先发放授权码，然后第三方服务器使用授权码获取令牌，避免令牌在传输转向过程中被泄漏的风险。 </p><p><img src="https://gitee.com/lights8080/lights8080-oss/raw/master/2021/10/NCzNMZ.png" alt="授权码模式，简易流程图"></p><h4 id="简化模式（Implicit）"><a href="#简化模式（Implicit）" class="headerlink" title="简化模式（Implicit）"></a>简化模式（Implicit）</h4><p>隐式授权省略掉了通过授权码换取令牌的步骤，整个授权过程都不需要服务端的支持。授权服务器不会再去验证第三方应用的身份，因为已经没有应用服务器了。</p><p>特别强调了令牌必须是“通过 Fragment 带回”的，Fragment 是不会跟随请求被发送到服务端的，只能在客户端通过 Script 脚本来读取。<br>尽最大努力地避免了令牌从操作代理到第三方服务之间的链路，存在被攻击而泄露出去的可能性。</p><h4 id="密码模式（Resource-Owner-Password-Credentials）"><a href="#密码模式（Resource-Owner-Password-Credentials）" class="headerlink" title="密码模式（Resource Owner Password Credentials）"></a>密码模式（Resource Owner Password Credentials）</h4><p>密码模式里，认证和授权就被整合成了同一个过程。仅限于在用户对第三方应用是高度可信任的场景中使用，因为用户需要把密码明文提供给第三方应用，第三方以此向授权服务器获取令牌。</p><h4 id="客户端模式（Client-Credentials）"><a href="#客户端模式（Client-Credentials）" class="headerlink" title="客户端模式（Client Credentials）"></a>客户端模式（Client Credentials）</h4><p>在微服务架构中，其实并不提倡同一个系统的各服务间有默认的信任关系，所以服务之间的调用也需要先进行认证授权，然后才能通讯。客户端模式便是一种常用的服务间认证授权的解决方案。</p><h3 id="RBAC（基于角色的访问控制，Role-Based-Access-Control）。"><a href="#RBAC（基于角色的访问控制，Role-Based-Access-Control）。" class="headerlink" title="RBAC（基于角色的访问控制，Role-Based Access Control）。"></a>RBAC（基于角色的访问控制，Role-Based Access Control）。</h3><p>所有的访问控制模型，实质上都是在解决同一个问题：谁（User）拥有什么权限（Authority）去操作（Operation）哪些资源（Resource）。</p><p>为避免对每一个用户设定权限，RBAC 提出了角色和许可等概念，角色为的是解耦用户与权限之间的多对多关系，而许可为的是解耦操作与资源之间的多对多关系。<br>RBAC-1 模型的角色权限继承关系，RBAC-2 模型的角色职责分离关系。</p><p>建立访问控制模型的基本目的就是为了管理垂直权限和水平权限。垂直权限即功能权限，水平权限则是数据权限，它很难抽象与通用。</p><h2 id="凭证（Credentials）"><a href="#凭证（Credentials）" class="headerlink" title="凭证（Credentials）"></a>凭证（Credentials）</h2><blockquote><p>系统如何保证它与用户之间的承诺是双方当时真实意图的体现，是准确、完整且不可抵赖的？</p></blockquote><h3 id="Cookie-Session"><a href="#Cookie-Session" class="headerlink" title="Cookie-Session"></a>Cookie-Session</h3><p>Set-Cookie 指令：这个指令的含义是以键值对的方式向客户端发送一组信息，在此后一段时间内的每次 HTTP 请求中，这组信息会附带着名为 Cookie 的 Header 重新发回给服务端，以便服务器区分来自不同客户端的请求。</p><p>Cookie-Session 也就是最传统的，但在今天依然广泛应用于大量系统中的、由服务端与客户端联动来完成的状态管理机制。</p><p>Cookie-Session 的优点是，实现足够简单，服务端有主动的状态管理的能力，适用于单节点的单体服务环境中。缺点是，服务器水平扩展成多节点时，状态管理收到存在CAP的局限。</p><h3 id="JWT（JSON-Web-Token）"><a href="#JWT（JSON-Web-Token）" class="headerlink" title="JWT（JSON Web Token）"></a>JWT（JSON Web Token）</h3><p>解决认证授权问题的无状态方案。是目前广泛使用的一种令牌格式，尤其经常与 OAuth 2.0 配合应用于分布式的、涉及多方的应用系统中。</p><p>JWT 默认的签名算法 HMAC SHA256 是一种带密钥的哈希摘要算法，加密与验证过程都只能由中心化的授权服务来提供，所以这种方式一般只适合于授权服务与应用服务处于同一个进程中的单体应用。<br>在多方系统，或者是授权服务与资源服务分离的分布式应用当中，通常会采用非对称加密算法来进行签名。这时候，除了授权服务端持有的可以用于签名的私钥以外，还会对其他服务器公开一个公钥。<br>不过，这个公钥不能用来签名，但它能被其他服务用于验证签名是否由私钥所签发的。这样，其他服务器就也能不依赖授权服务器、无需远程通讯，即可独立判断 JWT 令牌中的信息的真伪了。</p><p>JWT 只解决防篡改的问题，并不解决防泄露的问题，所以令牌默认是不加密的，需要时自行实现。JWT 缺点有：令牌难以主动失效，相对更容易遭受重放攻击，只能携带相当有限的数据，必须考虑令牌在客户端如何存储。</p><h2 id="保密（Confidentiality）"><a href="#保密（Confidentiality）" class="headerlink" title="保密（Confidentiality）"></a>保密（Confidentiality）</h2><blockquote><p>系统如何保证敏感数据无法被包括系统管理员在内的内外部人员所窃取、滥用？</p></blockquote><p>根据需要保密信息所处的不同环节，将其划分为“信息在客户端时的保密”，“信息在传输时的保密”和“信息在服务端时的保密”。</p><p>保密的强度：(逐步升级的保密措施，更高的安全强度同时也意味着要付出更多的代价)</p><ol><li>以摘要代替明文：不能防止弱密码被彩虹表攻击</li><li>先加盐值再做哈希是应对弱密码的常用方法：不能阻止加密结果被监听</li><li>将盐值变为动态值能有效防止冒认：协商出盐值的过程将变得极为复杂，每次协商只能保护一次操作</li><li>加入动态令牌防止重放攻击：流量公共位置建立校验逻辑，服务器要付出分发令牌信息代价</li><li>启用 HTTPS 来应对因嗅探而导致的信息泄露问题：客户端或服务端被攻破风险</li><li>进一步提升保密强度的不同手段：独立于客户端存储的物理设备-U盾、独立于网络的信息通道-手机验证码、与公网物理隔离的专用内部网络</li></ol><h3 id="信息在客户端时的保密"><a href="#信息在客户端时的保密" class="headerlink" title="信息在客户端时的保密"></a>信息在客户端时的保密</h3><p>为了保证信息不被黑客窃取而去做客户端加密，其实没有太大意义，对绝大多数的信息系统来说，启用 HTTPS 可以说是唯一的实际可行的方案。</p><p>但是！为了保证密码不在服务端被滥用（密码明文被写入数据库、被输出到日志中），而在客户端就开始加密的做法，还是很有意义的。</p><p>客户端无论是否动态加盐，都不可能代替 HTTPS。真正防御性的密码加密存储应该在服务端中进行，但这是为了防御服务端被攻破而批量泄露密码的风险，并不是为了增强传输过程的安全性。</p><p>客户端并不提倡在盐值上做动态化，更理想的方式是引入慢哈希函数来解决，增加破解密码的难度。<br>如果我们控制BCrypt的执行时间大概是 0.1 秒完成一次哈希计算的话，要算完所有的 10 位大小写字母和数字组成的弱密码，就大概需要 P(26<em>2+10,10)/(3600</em>24*365)/0.1=1,237,204,169 年的时间。</p><h3 id="信息在客户端时的保密-1"><a href="#信息在客户端时的保密-1" class="headerlink" title="信息在客户端时的保密"></a>信息在客户端时的保密</h3><p>“普通安全强度”的意思是，在具有一定保密安全性的同时，避免消耗过多的运算资源，这样验证起来也相对便捷。毕竟对多数信息系统来说，只要配合一定的密码规则约束，比如密码要求长度、特殊字符等等，再配合 HTTPS 传输，就已经足够防御大多数风险了。即使是用户采用了弱密码、客户端通讯被监听、服务端被拖库、泄露了存储的密文和盐值等问题同时发生，也能够最大限度地避免用户明文密码被逆推出来。</p><p>防御服务端被拖库后，针对固定盐值的批量彩虹表攻击。具体做法是为每一个密码（指客户端传来的哈希值）产生一个随机的盐值。（建议使用CSPRNG来生成一个长度与哈希值相等的随机字符串）</p><p>把动态盐值混入客户端传来的哈希值，再做一次哈希，产生出最终的密文。<br>把“最终的密文”和“随机的盐值”一起写入到数据库记录中。<br>服务端验证过程，取出登录用户对应的密文和盐值，采用相同的哈希算法，针对客户端传来的哈希值、服务端存储的盐值计算摘要结果，比较结果和数据库储存的“最终的密文”是否相同。</p><h2 id="传输（Transport-Security）"><a href="#传输（Transport-Security）" class="headerlink" title="传输（Transport Security）"></a>传输（Transport Security）</h2><blockquote><p>系统如何保证通过网络传输的信息无法被第三方窃听、篡改和冒充？</p></blockquote><p>摘要与加密和签名的本质区别：<br><img src="https://gitee.com/lights8080/lights8080-oss/raw/master/2021/10/87Lb7x.jpg" alt="摘要、对称机密、非对称加密的区别"></p><p>非对称加密算法：<br>公钥加密，私钥解密，这种就是加密：向私钥所有者发送信息，这个信息可能被他人篡改，但是无法被他人得知。<br>私钥加密，公钥解密，这种就是签名：防止私钥所有者发布的内容被篡改，不用来保证内容不被他人获得。</p><p>What is a Digital Signature?<br><a href="http://www.youdzone.com/signature.html">http://www.youdzone.com/signature.html</a></p><h2 id="验证（Verification）"><a href="#验证（Verification）" class="headerlink" title="验证（Verification）"></a>验证（Verification）</h2><blockquote><p>系统如何确保提交到每项服务中的数据是合乎规则的，不会对系统稳定性、数据一致性、正确性产生风险？</p></blockquote><p>Java Bean Validation。是比较提倡的做法，那就是把校验行为从分层中剥离出来，不是在哪一层做，而是在 Bean 上做。</p><p>采用 Bean Validation 也便于我们统一处理校验结果不满足时的提示信息。比如提供默认值、提供国际化支持（这里没做）、提供统一的客户端返回格式（创建一个用于 ConstraintViolationException 的异常处理器来实现），以及批量执行全部校验。</p><p>对于 Bean 与 Bean 校验器，两条关于编码的建议：<br>第一条建议是，要对校验项预置好默认的提示信息，这样当校验不通过时，用户能获得明确的修正提示。<br>第二条建议是，要把不带业务含义的格式校验注解放到 Bean 的类定义之上，把带业务逻辑的校验放到 Bean 的类定义的外面。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;周志明《凤凰架构：构建可靠的大型分布式系统》&lt;br&gt;&lt;a href=&quot;https://icyfenix.cn/&quot;&gt;https://icyfenix.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;包括：认证、授权、凭证、保密、传输、验证&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="技术" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="凤凰架构" scheme="http://www.lights8080.com/tags/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>2109-4-不要为了运动而运动</title>
    <link href="http://www.lights8080.com/p/57bfb88c.html"/>
    <id>http://www.lights8080.com/p/57bfb88c.html</id>
    <published>2021-09-23T16:00:00.000Z</published>
    <updated>2021-09-24T08:04:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>如题</p><span id="more"></span><h2 id="话题：不要为了运动而运动"><a href="#话题：不要为了运动而运动" class="headerlink" title="话题：不要为了运动而运动"></a>话题：不要为了运动而运动</h2><p>现在这个天气比较舒适，中午经常有一伙儿人在楼下打羽毛球，我有时间都会在楼下趴会儿。<br>我有个同事想法就不一样，他觉得运动就是跑跑跳跳，多累啊，出一身汗，还要换衣服在上班，还不如上去睡会儿觉。<br>我不能说他说的有毛病，运动确实很累人，出一身汗，很麻烦。</p><p>我现在每周坚持游泳，游完确实很累，不想动，心想累死我了，再也不去了。练了这么久自由泳还总是呛水，太难受了。<br>但转天总有一股劲儿逼迫着你去坚持，虽然身体很酸爽，但心里总痒痒。</p><p>“””<br>啊呀快累死了<br>没时间啊<br>忘记了<br>之前没有弄过啊不会<br>“””<br>据我有限的观察，一些善于找借口的人从不热爱运动，反过来说就是热爱运动的人遇到问题，更愿意思考，承担责任，去提高自己。<br>当然我没有查任何的理论依据，随意反驳。<br>你可以说找借口是一种自我保护的方法，不背锅。我认同，但我真觉得这对个人成长来说没有任何好处。</p><p>村上春树说：今天不想跑，所以才去跑。</p><p>刘翔从小训练都是8步上栏，但为了加强前面三栏的速度，改为7步上栏，这比重新开始学跨栏还要难，为了追求快那0.01秒的速度。<br>之前看过一个2020年的残奥会比赛剪辑，当你想要放弃的时候看一看，看看他们面对困难，面对竞争，是如何做的。</p><p>不运动的理由有千万种，但运动的理由就一个坚持，永不放弃，突破自我的精神。<br>运动的魅力，就是通过每天提高一点点，追求最好的自己的过程。</p><p>运动的目的是追求最好的自己，不要为了运动而运动，你坚持不下来。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如题&lt;/p&gt;</summary>
    
    
    
    <category term="weekly" scheme="http://www.lights8080.com/categories/weekly/"/>
    
    
    <category term="weekly" scheme="http://www.lights8080.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>大数据框架汇总</title>
    <link href="http://www.lights8080.com/p/f2ce654.html"/>
    <id>http://www.lights8080.com/p/f2ce654.html</id>
    <published>2021-09-17T16:00:00.000Z</published>
    <updated>2021-09-18T11:09:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>大数据平台相关框架汇总。<br>包括：Hadoop、Hbase、Pig、Hive、Spark、Strom、Flink、Presto、Atlas、SuperSet、Cassandra、ClickHouse等</p><span id="more"></span><h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h2><p>Hadoop是一个开源框架，允许使用简单的编程模型在跨计算机集群的分布式环境中存储和处理大数据。</p><p>Hadoop框架包括以下四个模块：</p><ul><li>Hadoop Common： 这些是其他Hadoop模块所需的Java库和实用程序。这些库提供文件系统和操作系统级抽象，并包含启动Hadoop所需的必要Java文件和脚本。</li><li>Hadoop YARN： 这是作业调度和群集资源管理的框架。</li><li>Hadoop分布式文件系统（HDFS）： 一种分布式文件系统，可提供对应用程序数据的高吞吐量访问。</li><li>Hadoop MapReduce： 这是用于并行处理大型数据集的基于YARN的系统。</li></ul><h2 id="Hbase"><a href="#Hbase" class="headerlink" title="Hbase"></a>Hbase</h2><p>HBase是一个数据模型，基于 Apache Hadoop 和 BigTable 概念的宽列存储，旨在提供对大量结构化数据的快速随机访问。<br>HBase是一个面向列的建立在HDFS之上的非关系型数据库，利用了Hadoop文件系统（HDFS）提供的容错功能。<br>面向列的数据库是为巨大的表而设计的，对半结构化和结构化数据很有用，适用于在线分析处理（OLAP）。</p><h2 id="Flume"><a href="#Flume" class="headerlink" title="Flume"></a>Flume</h2><p>Apache Flume是一种分布式，高可靠和高可用的服务，可以有效采集、聚合和传输大量的日志数据。</p><p>Flume具有可调的可靠性机制和许多故障转移和恢复机制，主要用于将各种源的流数据传输到HDFS。</p><h2 id="Pig"><a href="#Pig" class="headerlink" title="Pig"></a>Pig</h2><p>由Yahoo开发，Apache Pig是对MapReduce的一种抽象。可以处理结构化，非结构化和半结构化的数据，分析结构化和半结构化的数据，并将结果存储在HDFS中。</p><p>Pig提供了一种称为 Pig Latin 的高级语言，不需要编译，执行时，每个操作符都在内部转换为MapReduce作业。</p><p>它提供了许多操作符来执行连接、排序、文件管理等操作，还提供了其他编程语言的自定义函数（UDF）功能，嵌入到Pig脚本中。</p><h2 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h2><p>由Facebook开发，Hive是一个数据仓库基础设施工具，用于处理Hadoop中的结构化数据。它位于Hadoop的顶部，用于汇总大数据，并使查询和分析变得轻松。</p><p>Hive提供用于查询的SQL类型语言，称为HiveQL或HQL，内部将HQL查询转换为执行MapReduce操作。</p><h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><p>Apache Spark是一款快速集群计算，专为快速计算而设计。它建立在Hadoop MapReduce之上，它扩展了MapReduce模型以有效地使用更多类型的计算，其中包括交互式查询和流处理。</p><p>Spark的主要特点是其内存集群计算 ，通过减少对磁盘的读/写操作，将中间处理数据存储在内存中，提高应用程序的处理速度。</p><p>包括以下四个组件：</p><ul><li>Apache Spark Core：Spark平台的基础通用执行引擎，其所有其他功能都是基于该平台执行的</li><li>Spark SQL：提供了对结构化和半结构化数据的支持</li><li>Spark Streaming：利用Spark Core的快速调度功能来执行流式分析</li><li>MLlib：分布式机器学习框架</li><li>GraphX：分布式图形处理框架</li></ul><p>弹性分布式数据集（RDD）是Spark的基础数据结构，它是一个不可变的分布式对象集合。<br>Spark利用RDD的概念来实现更快更高效的MapReduce操作。</p><p>Apache Spark是用 Scala编程语言 编写的。为了用Spark支持Python，Apache Spark社区发布了一个工具PySpark。</p><h2 id="Storm"><a href="#Storm" class="headerlink" title="Storm"></a>Storm</h2><p>Apache Storm是一个分布式实时大数据处理系统。Storm设计用于以容错和水平可伸缩方法处理大量数据。虽然Storm是无状态的，但它通过Apache ZooKeeper管理分布式环境和集群状态。</p><p>Hadoop和Storm框架用于分析大数据，Storm执行除持久性以外的所有操作，而Hadoop擅长于一切，但缺乏实时计算。</p><h2 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h2><p>Apache Flink是一个同时面向数据流处理和批量数据处理的开源框架和分布式处理引擎，具有高吞吐、低延迟、高扩展、支持容错等特性，用于对无界和有界数据流进行有状态计算。</p><p>可以运行在包括 YARN、 Mesos、Kubernetes 在内的多种资源管理框架上。</p><h3 id="Flink-常见的几类应用"><a href="#Flink-常见的几类应用" class="headerlink" title="Flink 常见的几类应用"></a>Flink 常见的几类应用</h3><p>事件驱动型应用、数据分析应用、数据管道应用</p><h4 id="事件驱动型应用"><a href="#事件驱动型应用" class="headerlink" title="事件驱动型应用"></a>事件驱动型应用</h4><p>事件驱动型应用是一类具有状态的应用，它从一个或多个事件流提取数据，并根据到来的事件触发计算、状态更新或其他外部动作。</p><p>事件驱动型应用是在计算存储分离的传统应用基础上进化而来。在传统架构中，应用需要读写远程事务型数据库。</p><p>典型的事件驱动型应用实例：反欺诈、异常检测、基于规则的报警、业务流程监控</p><h4 id="数据分析应用"><a href="#数据分析应用" class="headerlink" title="数据分析应用"></a>数据分析应用</h4><p>数据分析任务需要从原始数据中提取有价值的信息和指标。传统的分析方式通常是利用批查询，或将事件记录下来并基于此有限数据集构建应用来完成。</p><p>Flink 为持续流式分析和批量分析都提供了良好的支持。内置了SQL接口，将批、流查询的语义统一起来。</p><h4 id="数据管道应用"><a href="#数据管道应用" class="headerlink" title="数据管道应用"></a>数据管道应用</h4><p>提取-转换-加载（ETL）是一种在存储系统之间进行数据转换和迁移的常用方法。ETL 作业通常会周期性地触发，将数据从事务型数据库拷贝到分析型数据库或数据仓库。</p><p>Flink 为多种数据存储系统（如：Kafka、Kinesis、Elasticsearch、JDBC数据库系统等）内置了连接器</p><h2 id="mapReduce、pig-hive、spark-storm、flink"><a href="#mapReduce、pig-hive、spark-storm、flink" class="headerlink" title="mapReduce、pig/hive、spark/storm、flink"></a>mapReduce、pig/hive、spark/storm、flink</h2><p>第一代计算引擎 mapReduce：<br>用于批处理，是计算引擎的先驱，开发效率低，开发时间成本太大</p><p>第二代计算引擎 pig/hive：<br>对hadoop进行了嵌套，其存储基于hdfs，计算基于mr，降低了mr的编写编写成本<br>pig有自己的脚本语言，可以处理非结构化、半结构化和结构化数据，比hive更加的灵活<br>hive属于类sql语法，仅支持处理结构化数据</p><p>第三代计算引擎 spark/storm：<br>解决实时处理的需求，低延迟高吞吐量。</p><p>第四代计算引擎 flink：<br>为流式计算而生属于每一条数据触发计算，在性能的消耗低于storm，吞吐量高于storm，延时低于storm，并且比storm更加易于编写</p><h2 id="Sqoop"><a href="#Sqoop" class="headerlink" title="Sqoop"></a>Sqoop</h2><p>它用于在HDFS和RDBMS之间导入和导出数据。</p><h2 id="Presto"><a href="#Presto" class="headerlink" title="Presto"></a>Presto</h2><p>Presto是Facebook开源的分布式SQL查询引擎，规模可以支持GB到PB级，主要应用于处理秒级的查询场景。内存中计算。优点是快，跨数据源查询</p><p>Hive针对查询吞吐量进行了优化，而Presto针对延迟进行了优化。<br>Presto受最大内存限制，如果超过最大内存，查询就会失败。<br>对于交互式查询可以接受，对于必须可靠运行的日报/周报，他是不合适的，Hive会更好。</p><h2 id="Atlas"><a href="#Atlas" class="headerlink" title="Atlas"></a>Atlas</h2><p>Apache Atlas提供了开放元数据管理和治理能力，以建立其数据资产目录，对这些资产进行分类和治理。</p><p>开箱即用的元数据源集成：HBase、Hive、Sqoop、Storm、Kafka</p><h2 id="SuperSet"><a href="#SuperSet" class="headerlink" title="SuperSet"></a>SuperSet</h2><p>Apache Superset 是一个现代数据探索和可视化平台。<br>是一个现代轻量级的BI分析工具，功能强大且易于使用、轻量级且可扩展、与现代数据库集成、丰富的可视化和仪表板。</p><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p>Apache Kafka 是一个开源分布式事件流平台，高吞吐量、弹性扩展、永久存储、高可用。</p><h2 id="Cassandra"><a href="#Cassandra" class="headerlink" title="Cassandra"></a>Cassandra</h2><p>由Facebook开发，Cassandra是一套开源分布式NoSQL数据库系统，基于 BigTable 和 DynamoDB 思想的宽列存储。</p><p>HBase vs Cassandra<br><a href="https://appinventiv.com/blog/hbase-vs-cassandra/">https://appinventiv.com/blog/hbase-vs-cassandra/</a></p><p>当你需要分析大数据或执行聚合时请使用HBase，如果强调交互式数据和实时事务处理，可以使用 Cassandra。</p><h2 id="ClickHouse"><a href="#ClickHouse" class="headerlink" title="ClickHouse"></a>ClickHouse</h2><p>ClickHouse是一个快速的开源 OLAP 数据库管理系统，它是面向列的，允许使用 SQL 查询实时生成分析报告。</p><h2 id="ETL"><a href="#ETL" class="headerlink" title="ETL"></a>ETL</h2><p>ETL是将业务系统的数据经过抽取（Extract）、清洗转换（Transform）之后加载（Load）到数据仓库的过程，目的是将企业中的分散、零乱、标准不统一的数据整合到一起，为企业的决策提供分析依据。</p><h2 id="ELK"><a href="#ELK" class="headerlink" title="ELK"></a>ELK</h2><p>ElasticSearch<br>Kibana<br>Logstash<br>Beats</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;大数据平台相关框架汇总。&lt;br&gt;包括：Hadoop、Hbase、Pig、Hive、Spark、Strom、Flink、Presto、Atlas、SuperSet、Cassandra、ClickHouse等&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://www.lights8080.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="大数据" scheme="http://www.lights8080.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>2109-3-小情境与大情境</title>
    <link href="http://www.lights8080.com/p/1db6c142.html"/>
    <id>http://www.lights8080.com/p/1db6c142.html</id>
    <published>2021-09-15T16:00:00.000Z</published>
    <updated>2021-09-17T01:40:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>如题</p><span id="more"></span><h2 id="话题：小情境与大情境"><a href="#话题：小情境与大情境" class="headerlink" title="话题：小情境与大情境"></a>话题：小情境与大情境</h2><p>最近在读一本书《李诞脱口秀工作手册》，还没有读完，其中有一个观点很有启发，小情境与大情境。<br>小情境就是你的一个又一个段子，大情境就是你的主持。</p><p>“””<br>请思考一个问题，我们上台演出的目的是什么？是为了伺候好那一场，那一天的观众吗？</p><p>我们当然要为演出效果负责，但是你上台的出发点不该是这个，而是要拉长时间看——目的始终是成为更强的脱口秀演员。<br>目的是通过逗笑观众磨砺自己，而不是逗笑观众。</p><p>不停上开放麦，不停演出的目的，是练自己，不是炸场。<br>最终你会变成一个在舞台上游刃有余，什么状况都能接住的演员，你会场场都炸。<br>但你的出发点不该是练这个，如果你一出发就去练怎么炸场，你也不太可能变成一个炸场演员。<br>你的上限太低了，你的上限就是一天又一天迎来送往的观众，你会慢慢发现，炸场其实挺容易的，你会收获一天又一天无意义的成功。</p><p>这也能解释从线下到线上的不适，你能练成伺候一百人的能力，你能伺候好一千万人吗？</p><p>不是你去找观众，而是要让观众来找你。狠狠地操练自己，你越强，找到你的观众越多。<br>而不是你能讨好的人越多，你的观众越多。<br>炸场是副产品，正如名利也是副产品。<br>追求炸场，追求名利，你会一无所获，或者更惨，你会变成一个庸人，甚至一个坏人。</p><p>人是目的，不是手段。<br>“””</p><p>他说很多朋友从线下转到线上，都要问这么一个问题，“我是该看观众还是该看镜头？”</p><p>这确实是一个很好的问题，在职场中类似的问题有一堆，“如何应对三十五岁危机？”，“如何跟老板搞好关系？”，“如何管理员工？”。</p><p>这些看似是很麻烦的问题，其实都是假问题。</p><p>脱口秀表演，如果你把重点放在与观众的关系上，你在台上很容易不知所措，后果就是注意力分散，或者更加悲惨，演砸了。<br>职场工作，如果你把重点放在搞好领导同事之间的关系上，那就是拿自己当手段不是目的，后果就是焦虑，工作做不好，在专业上不专业了。</p><p>过度去讨好观众，就算这场观众笑了；过度搞好同事关系，就算这几年升职加薪了，那也是无意义的成功。<br>用发展的眼光看问题，这是一份终身职业，一份与你的一切不能分割的工作，有意义的失败远远比无意义的成功有价值。</p><p>人生的目的就是成为更好的自己，狠狠地操练自己。</p><p>另外，我觉得每个人都应该学会识别生活中的小情境与大情境。<br>我们必须习惯用发展的眼光看问题，人生不是几把牌，赢了就赢了，人生是个牌局，想散都散不了的那种，输赢不在一把两把。</p><p>塞翁失马焉知非福。</p><p>说到这里，我认为在孩子教育的事情上，是非常非常需要用发展的眼光。<br>有时候会因为一些小事儿，跟孩子生气，跟他气完后，就反过来跟自己生气，“我为什么生气了？”。</p><p>教育不应该是控制，应该是高度控制下的失控。<br>教育是目的，不是手段。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如题&lt;/p&gt;</summary>
    
    
    
    <category term="weekly" scheme="http://www.lights8080.com/categories/weekly/"/>
    
    
    <category term="weekly" scheme="http://www.lights8080.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>2109-2-马猴来了</title>
    <link href="http://www.lights8080.com/p/9dc87d4e.html"/>
    <id>http://www.lights8080.com/p/9dc87d4e.html</id>
    <published>2021-09-09T16:00:00.000Z</published>
    <updated>2021-09-17T01:40:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>如题</p><span id="more"></span><h2 id="话题：马猴来了"><a href="#话题：马猴来了" class="headerlink" title="话题：马猴来了"></a>话题：马猴来了</h2><p>书接上文：<br>我之前一直都不认可这样的主播，认为其对社会没有任何价值。没有什么能耐，就靠嘴皮子，吸引一些脑残粉而已。</p><p>但我也被马猴所吸引了，至少在想休闲的时候会想到他的直播。<br>除了PK惩罚比较好玩意外，更喜欢的是他那真实的态度。<br>大多数主播，会迎合讨好粉丝，说话有时嗲嗲的，显得很做作。<br>马猴的直播算得上是一股清流，姿态放的很低，虽然是靠直播挣钱，但不刻意迎合粉丝，不说假话，自然真实，敢玩。<br>没有什么显眼才艺，但这就是他的风格。</p><p>非常敢玩游戏，除了吃东西不玩，其他的基本都敢接。<br>看过他往睡觉的床上泼一盆水，蒙眼跳蹬子，墩屁墩，墙上凿坑，脸上抹泥…<br>隔天再进他的直播间发现灯泡捅坏了，一扇门拆了，后面的背景阿里路亚抠的只剩路亚了。</p><p>直播中，粉丝问啥，他也从不遮遮掩掩。<br>比如直播挣多少钱啊，女主播内幕啊。<br>他透露自己<br>“””<br>曾经当过煤矿工人，一年就挣2w块钱。<br>赌博输掉20w，媳妇闹离婚。<br>我自己啥能耐没有，我去在外面，一个月挣个两三千到头了。<br>做主播现在好点，每个月挣6w差不多，一开始那会儿一月能有一两千不错了。<br>已经从直播中挣了差不多300w+，现在住的别墅，二楼单独弄了个直播间，给大家展示下子粉丝送的东西（好烟好酒）。<br>咱说实在的，给朋友随红包也就三五百块钱。哪天我的大哥开播了，我刷礼物就得一万多，少了拿不出手，是不是。<br>做PL直播的都没有一个好东西，都得有点啥事，正常上班的人干不了主播。<br>就现在的全网的这些PK主播都是些烂七八糟的人，真话。包括我自己，但是我没偷，没骗，没抢。你觉得自己过的不错你就刷点，觉得过的一般的看着就行了。<br>那些给女主播刷礼物的，好几万好几万的，你以为是情怀啊，屁！<br>……<br>“””</p><p>他自称是一个正能量主播，我觉得他也做到了。<br>PK哪怕输的一塌糊涂，气势上也一点不输，输多少次，依然当游戏欢笑面对。<br>真实、自信、不做作，这就是他给我传递的正能量！<br>分享直播生活和内幕，分享过往经历，能让人从中吸取一些经验教训，了解到不同人的生活方式，那也是价值。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如题&lt;/p&gt;</summary>
    
    
    
    <category term="weekly" scheme="http://www.lights8080.com/categories/weekly/"/>
    
    
    <category term="weekly" scheme="http://www.lights8080.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>数据仓库项目实战</title>
    <link href="http://www.lights8080.com/p/78ecf609.html"/>
    <id>http://www.lights8080.com/p/78ecf609.html</id>
    <published>2021-09-05T16:00:00.000Z</published>
    <updated>2021-09-08T08:53:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>读书笔记-《大数据分析：数据仓库项目实战》</p><span id="more"></span><h2 id="大数据和数据仓库概论"><a href="#大数据和数据仓库概论" class="headerlink" title="大数据和数据仓库概论"></a>大数据和数据仓库概论</h2><h4 id="大数据概论"><a href="#大数据概论" class="headerlink" title="大数据概论"></a>大数据概论</h4><p><img src="https://gitee.com/lights8080/lights8080-oss/raw/master/2021/09/mBx4zQ.jpg" alt="大数据生态圈的层次及其应用举例"></p><ul><li>数据采集层：多数据源，非结构化数据采集</li><li>数据计算层：分为离线数据计算和实时数据计算</li><li>数据应用层：最终提供给用户使用</li></ul><h4 id="数据仓库概论"><a href="#数据仓库概论" class="headerlink" title="数据仓库概论"></a>数据仓库概论</h4><p>数据仓库（Data Warehouse，DW）：为企业所有级别的决策制度过程，提供数据资源集合，出于分析性报告和决策支持目的而创建。是未面向分析的集成化数据环境。</p><p>数据仓库的特点：</p><ul><li>数据是面向主题的：具有更高的数据抽象级别</li><li>数据是集成的：数据源于不同的联机系统，进入仓库前必须经过统一和综合</li><li>数据是不可更新的</li><li>数据是随时间不断变化的</li></ul><h2 id="数据仓库建模"><a href="#数据仓库建模" class="headerlink" title="数据仓库建模"></a>数据仓库建模</h2><h4 id="范式理论"><a href="#范式理论" class="headerlink" title="范式理论"></a>范式理论</h4><p>使用范式的根本目的包括：</p><ul><li>减少数据冗余，尽量让每个数据只出现一次</li><li>保证数据的一致性</li></ul><p>联机事务处理(On-Line Transaction Processing，OLTP)：传统关系数据库的主要应用，保证数据的一致性及避免冗余。<br>联机分析处理(On-Line Analytical Processing，OLAP)：数据仓库系统主要应用，通常以某一张事实表为中心进行表的组织，面向业务，可能存在数据的冗余，通常采用维度模型建模。</p><p>维度模型：包括星型模型、雪花模型、星座模型</p><h4 id="表的分类"><a href="#表的分类" class="headerlink" title="表的分类"></a>表的分类</h4><p>事实表：每行数据代表一个业务事件。”事实”这个术语表示的是业务事件的度量值。如：订单金额</p><p>事实表分类：</p><ul><li>事务型事实表（每个事务或事件产生一行数据）</li><li>周期型快照事实表（保留固定时间间隔的数据）</li><li>累积型快照事实表（用于跟踪业务事实的变化）</li></ul><p>维度表：指对业务状态编码的解释表，又称为码表。如：订单状态表、商品分类</p><h4 id="逻辑分层"><a href="#逻辑分层" class="headerlink" title="逻辑分层"></a>逻辑分层</h4><p>分层：</p><ul><li>ODS（原始数据层，Operational Data Store）：加载原始日志</li><li>DWD（明细数据层，Data Warehouse Detail ）：结构和粒度与ODS保持一致，对数据进行清洗、维度退化、脱敏、数据压缩等（仅关注事实表的相关维度及度量值字段）</li><li>DWS（服务数据层，Data Warehouse Service ）：宽表化手段构建公共指标数据，不同的主题按天进行轻度汇总</li><li>DWT（主题数据层，Data Warehouse Topic）：按主题进行汇总，获得每个主题的全量数据表</li><li>ADS（应用数据层，Application Data Store）：面向实际的数据需求，为各统计报表提供数据</li></ul><p>好处：</p><ul><li>【易维护】高效的数据组织形式，清洗和过滤，规范化，血缘追踪</li><li>【高性能】时间价值，数据集合，维度汇总，查询效率</li><li>【简单化】集成价值，多维度数据整合，多角度多层次的数据分析</li><li>【历史性】历史数据，回溯历史，预测未来</li></ul><p>DWD构建维度模型的四个步骤：</p><ol><li>选择业务过程：一条业务线对应一张事实表。如：下单业务，支付业务</li><li>声明粒度：精确定义事实表中一行数据所表示的内容，尽可能选择最细粒度</li><li>确定维度：主要作用是描述业务事实，表示的是”谁、何处、何时”等信息。如时间维度，用户维度</li><li>确定事实：指的是业务中的度量值，如订单件数，订单金额等</li></ol><p>得出业务总线矩阵：将维度表进行退化，地区表和省份表退化为地区维度表，商品类目退化为商品维度表等<br><img src="https://gitee.com/lights8080/lights8080-oss/raw/master/2021/09/d4oJdU.jpg" alt="业务总线矩阵"></p><p>DWS、DWT层都是按照主题来创建宽表的，而主题相当于观察问题的角度，不同的维度表意味着不同的角度。<br><img src="https://gitee.com/lights8080/lights8080-oss/raw/master/2021/09/rxAni4.jpg"></p><p>DWS层用于统计各主题对象的当天行为，服务于DWT层的主题宽表，宽表字段是站在不同维度的视角去看事实表的，重点关注事实表的度量值。<br><img src="https://gitee.com/lights8080/lights8080-oss/raw/master/2021/09/4onPTr.jpg"></p><p>DWT层以分析的主题对象为建模驱动，基于上层应用和产品指标需求，构建主题对象的全量宽表。<br><img src="https://gitee.com/lights8080/lights8080-oss/raw/master/2021/09/puooTc.jpg"></p><p>ADS层分别对不同的主题进行指标分析。</p><h2 id="技术选型和架构选型"><a href="#技术选型和架构选型" class="headerlink" title="技术选型和架构选型"></a>技术选型和架构选型</h2><p>技术选型：<br>数据采集与传输：Flume、Kafka、Sqoop<br>数据存储：MySQL、HDFS<br>数据计算：Hive、Tez<br>任务调度：Azkaban<br>即席查询：Presto、Druid、Kylin<br>元数据管理：Atlas</p><p>框架选型：<br>Apache：可以自由定制所需功能组件，运维过程烦琐，组件间的兼容性需要自己调研<br>CDH：国内使用较多，不开源，不用担心组件兼容问题<br>HDP：开源，但没有CDH稳定，使用较少</p><h2 id="数据集市"><a href="#数据集市" class="headerlink" title="数据集市"></a>数据集市</h2><p>数据集市本质上是一个数据交易市场，就像宜家楼上的展厅，这是一个面向最终用户的数据市场。数据（家具）以一种更加容易被业务人员接受的方式组合在一起。<br>数据集市提供数据交易服务的最终实现，为用户提供各种数据服务支持。</p><p>特征：</p><ul><li>有特定的应用主题</li><li>业务部门管理和维护</li><li>聚焦具体领域，要满足低延迟，高并发的数据查询要求</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;读书笔记-《大数据分析：数据仓库项目实战》&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="技术" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="读书笔记" scheme="http://www.lights8080.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="大数据" scheme="http://www.lights8080.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    <category term="数据仓库" scheme="http://www.lights8080.com/tags/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>2109-1-对面大哥都是我祖宗</title>
    <link href="http://www.lights8080.com/p/342ac289.html"/>
    <id>http://www.lights8080.com/p/342ac289.html</id>
    <published>2021-09-02T16:00:00.000Z</published>
    <updated>2021-09-17T01:40:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>如题</p><span id="more"></span><h2 id="话题：对面大哥都是我祖宗"><a href="#话题：对面大哥都是我祖宗" class="headerlink" title="话题：对面大哥都是我祖宗"></a>话题：对面大哥都是我祖宗</h2><p>最近这几天在微信直播关注了一个逗比主播，分享一下这其中的故事。<br>晚上无事，打开手机漫无目的的乱滑着。进到一个直播间，两个人正在PK，热度和观看人数都很高。<br>出于好奇心，就持续看了下去。</p><p>左面是凡达（后面看粉丝说凡家主播占了微信直播的一半流量），右面是马猴。<br>PK期间，热度低的一方要不停的喊出一句话“对面的大哥都是我祖宗”（他们约定的游戏规则）。<br>PK结束，右边马猴小优势获胜。然后就是惩罚阶段，左边凡达撅着拿铁盆扣在屁股，用脚踢铁盆50下。<br>凡达各种挑衅问对面敢不敢再开一局，双方你一句我一句谁也让谁，又开了一局。（现在想想，PK主播想要的就是这种直播效果，线下可以是朋友，线上那就是损友）<br>这局凡达以碾压式的优势获胜。<br>马猴虽然输了，但整个状态就跟赢了对面十万票似的，连喊“对面的大哥都是我祖宗！！！”都底气十足。<br>惩罚是剪掉一个裤腿，也一样干净利索，说话气势态度上甚至比对面还强势。<br>我心想你都输成这样了，看你后面还咋直播，转而进了他的直播间。</p><p>俩人连线结束后不一会儿，一个大哥就上来语音连线了，后面就称他为X吧。（应该是经常给马猴打赏的粉丝）</p><p>X说：<br>“””<br>你这样还咋玩儿啊，你第一局赢了，你的粉丝大哥们这么支持你，给你刷礼物为啥啊？<br>你认为你把把都能赢凡达啊，人家多少粉丝什么级别，你这一局赢的就是侥幸，你知道吧。<br>我们这么给你刷礼物，就是要让你赢一次，他是大号，让他没有面子，后面才有机会再打，多吸引点他的粉丝过来，你才能火啊。<br>他为啥要各种刺激你，非要跟你打第二局啊，他要找回面子来的啊。<br>结果呢，你被他一刺激就开打了，你没有看你的聊天啊，都刷屏了让你别打！别打！<br>你鸟他干嘛啊，你对他那么实在有鸟用，你就照顾好你的粉丝就行了。<br>你看第二局打的，说真的，你这多伤你直播间儿大哥的心啊。<br>“””</p><p>这时候马猴的气势和心态都蔫了，他说：<br>我没想那么多，我就是玩儿，打的时候我说了，赢他凡达一次就够了，输多少次我都赢了。<br>如果伤害了直播间的大哥，我道歉，对不起。<br>我就是一个小主播，没法跟人家凡达比。<br>你说我没啥才艺，不会唱歌跳舞，我就是个PK主播，不PK那我主播什么，别的我也不会。<br>这是实话，真的。</p><p>X说：<br>“””<br>就你实在。<br>你赢了，第二局你不跟他打了，你放心第二天他肯定会主动找你连麦的。<br>他要找机会出气啊，他房间的大哥要给他撑腰啊，给他的粉丝要回面子啊。<br>你这样又打输了，他面子也找回去了，人家还会找你连麦吗？<br>就你这智商，连点战术都没有，你怎么火的起来哦，打仗不是光靠拼的。<br>“””</p><p>这时，又有人找他连麦PK。聊了一会儿，马猴说等会儿，我开个会。</p><p>X说：<br>“””<br>不要跟他开打，这人就是凡家的小弟。<br>你赢了一局，他还是咽不下这口气，找个小弟过来PK侮辱你的。<br>你就跟他磨嘴皮子，没话说了就撂下一句话，先打赢你师傅再来找我打。<br>我跟你讲，如果这次你连他小弟都打输了，你就再没机会了。<br>你放心，只有这样凡达才会再找你连麦，连这个都看不明白吗？<br>你照顾好你房间的大哥就行了，你对他那么实在干嘛。<br>“””</p><p>细品X说的这些话，真是战术大师，对方心理琢磨的透透的。<br>直播中还有这么多门道，这是我没有想到的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如题&lt;/p&gt;</summary>
    
    
    
    <category term="weekly" scheme="http://www.lights8080.com/categories/weekly/"/>
    
    
    <category term="weekly" scheme="http://www.lights8080.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>2108-4-企业文化</title>
    <link href="http://www.lights8080.com/p/7fc5d86f.html"/>
    <id>http://www.lights8080.com/p/7fc5d86f.html</id>
    <published>2021-08-26T16:00:00.000Z</published>
    <updated>2021-09-02T02:03:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>如题</p><span id="more"></span><h2 id="话题：企业文化"><a href="#话题：企业文化" class="headerlink" title="话题：企业文化"></a>话题：企业文化</h2><p>相信大部分人都非常向往大厂的企业文化吧。<br>比如：扁平化管理、没有考勤管理和休假制度、没有主管和考核、不建立统一技术规范、没有测试团队等。<br>天啊！很难想象这样的制度，公司怎样运营？</p><p>那大厂为什么会这样，且还能运营的很好？又是如何组织上万人朝着同一个目标前进呢。<br>我觉得关键是公司里是一群什么样的人。大厂的竞争实际是人才的竞争，而公司的企业文化就是要保证吸引和留住人才。<br>”“”<br>对于程序型的工作，顶级员工的输出量是一般员工的2倍。<br>对于创新型/创意型的工作，顶级员工的输出量是一般员工的10倍!<br>”“”</p><p>工程师人天生带有一种工匠式的图腾崇拜精神，奉行达者为师，不迷信管理他们的人，但充分尊重能够指导他们的人。<br>他们都非常的自律性，有目标，有责任感。企业里有这样一群优秀的人，还需要管理吗？</p><p>优秀的人从来不怕麻烦，如果是一个好的方案，大家就会趋同。所以不设立统一的技术规范，反而进化迭代出更好的规范。</p><p>公司的目标靠产品驱动，落实到人，分配给团队，团队就需要对自己做出来的东西负责任。<br>团队内有不同意见时，听谁的呢？<br>那就是谁对这个产品负责就听谁的，一旦负责人决定了，团队内不同意见的人，要迅速调整。</p><p>能力差的，不认可公司文化和价值观的人，最终会被淘汰掉，或主动离职。<br>所以企业文化和有这样一群人是密不可分的。<br>有这样的文化，没有这样一群优秀的人，是支撑不了企业成长的；<br>没有这样的文化，即使有这样一群优秀的人，最终也会人才流失。<br>大厂为啥热衷于要搞开源？互联网企业技术就是核心价值，这不是帮助同业成长吗？<br>核心还是建立行业标准和最佳实践，建立技术品牌，留住和吸引顶级工程师，并从共享生态中获得反馈输入受益。</p><p>多美好，相辅相成，但小厂照搬过来，大概率是行不通的。<br>原因是小厂没有能力招到一群优秀的人。基本都是一个大牛，带一堆小兵。<br>是小兵也就意味着能力水平和意识，都达不到水平，只能靠管理，靠规范，靠大牛的指导，才能朝着目标前进。</p><h2 id="语录"><a href="#语录" class="headerlink" title="语录"></a>语录</h2><ol><li>如果你想造一艘船，先不要雇人去收集木头， 也不要给他们分配任何任务，而是去激发他们对浩瀚汪洋的渴望。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;如题&lt;/p&gt;</summary>
    
    
    
    <category term="weekly" scheme="http://www.lights8080.com/categories/weekly/"/>
    
    
    <category term="weekly" scheme="http://www.lights8080.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>2108-3-从NBA看职场</title>
    <link href="http://www.lights8080.com/p/418eb76d.html"/>
    <id>http://www.lights8080.com/p/418eb76d.html</id>
    <published>2021-08-19T16:00:00.000Z</published>
    <updated>2021-09-02T02:03:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>如题</p><span id="more"></span><h2 id="话题：从NBA看职场"><a href="#话题：从NBA看职场" class="headerlink" title="话题：从NBA看职场"></a>话题：从NBA看职场</h2><p>球员背景：</p><p>施罗德：<br>市场上没有比施罗德更适合湖人的首发控卫了，从赛季中期湖人的报价来看，确实把施罗德当第三巨头来看待了。<br>施罗德也正是看中了这点，要求球队首发和顶薪，拒绝湖人平均年薪2000w报价的资本。</p><p>霍华德：<br>19-20赛季湖人获得NBA总冠军，霍华德在夺冠道路上也发挥了应有价值，选择续约湖人是自然的事情。<br>湖人从市场签约了小加索尔和哈雷尔，账目实力远大于霍华德，霍华德上场时间被挤没了，只能离队最终一年签约76人。</p><p>库兹马+波普：<br>库兹马、波普都处于合同年，因为19-20赛季在季后赛中发挥作用，提升了市场价值。湖人分别签了平均年薪超千万的长约。<br>但上赛季表现中规中矩，没有达到预期。</p><hr><p>我有时候会想如果我是湖人总经理，面对这个局面，我该如何操作呢？<br>尤其是对施罗德的续约上，顶薪明显是溢价合同，但是市场上又没有更好的选择了。放走施罗德湖人后卫就是问题？</p><p>下面来看看湖人总经理的操作：<br>1。 果断放弃表现不好的球员（库兹马+波普+哈雷尔），打包交易换来即战力很强的威少，组成三巨头，从侧面直接解决了施罗德的难题。<br>而施罗德，最终一年590w签约凯尔特人。</p><ol start="2"><li><p>毫不犹豫的重新签回霍华德。从上赛季的表现来看，去年的操作是失败的，小加索尔和哈雷尔和球队的化学反应并不好。</p></li><li><p>依靠巨星光环和总冠军，吸引优质球员底薪签约。</p></li></ol><h2 id="语录"><a href="#语录" class="headerlink" title="语录"></a>语录</h2><ol><li><p>当你有选择的时候，选择更重要；而当你没有选择的时候，努力才重要。努力是为了让你有更好的选择。</p></li><li><p>人不是因为变老了才没有热情，而是因为你没有热情才变老了。</p></li><li><p>成年人面对的第一个挑战就是没时间，我们需要解决的问题就是，在资源匮乏的情况下，还能够把事情做成。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;如题&lt;/p&gt;</summary>
    
    
    
    <category term="weekly" scheme="http://www.lights8080.com/categories/weekly/"/>
    
    
    <category term="weekly" scheme="http://www.lights8080.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>2108-2-K12双减的深度思考</title>
    <link href="http://www.lights8080.com/p/197f72b3.html"/>
    <id>http://www.lights8080.com/p/197f72b3.html</id>
    <published>2021-08-12T16:00:00.000Z</published>
    <updated>2021-09-02T02:03:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>如题</p><span id="more"></span><h2 id="话题：K12双减的深度思考"><a href="#话题：K12双减的深度思考" class="headerlink" title="话题：K12双减的深度思考"></a>话题：K12双减的深度思考</h2><p>认真观察身边的朋友同事，有一个现象比较明显。<br>肯吃苦努力工作的人基本都是穷人家庭出身，而那些对工作没有什么追求的人往往家庭条件比较优越。</p><p>都市剧《谁说我结不了婚》中有这样一段对话，我感触很深。<br>”“”<br>许海峰：至于这么拼吗？<br>田雷：我没有光鲜的学历，也没有丰厚的背景，我从实习生做起，一步一步拼到现在，才走到现在的位置。我拼尽全力，也只是你的起点而已。<br>”“”</p><p>我是农村出身，有时候真的会觉得很气，凭什么啊！<br>低收入家庭要想跃迁到中产阶级需要付出非常大的努力，而且不一定就能成功。而中产阶级家的孩子可以很轻松的享受并维持这个水平。</p><p>这也是年轻人躺平的原因吧，没有晋升希望。</p><p>贫富差距大，穷人太多，晋升的机会小，从宏观角度看，这是资本分配的问题。</p><p>经济内循环，关键还是要看中产阶级力量。中产阶级才是消费主力军，内循环的驱动力。（有钱的人占比太少拉动不起来，低收入家庭没钱去拉动，中产阶级是有欲望和有能力消费的群体）</p><p>20年统计，国家6亿人每月收入1000元。实现内循环，现存的中产阶级还不够。根本的解决办法，是让穷人变富。<br>如何变富？ - 靠自己。</p><p>国家层面要做的就是，尽可能保障赛道公平，让那些有天赋，肯吃苦，努力的人更容易实现阶层跃迁，给更多的低收入家庭以希望。<br>不能因为出身家庭财富和其他后天的限制就剥夺了成功的机会。要让后来人看到希望，带动更多的人步入中产。</p><p>K12双减，明面上是配合三胎政策，降低养育成本，实则是对中产阶级的降维打击。<br>强行拉平中产阶级家庭孩子和低收入家庭孩子到同一起跑线（低收入家庭没有经济能力上辅导班，那就让中产阶级家庭的孩子没有课外辅导班可上），降低底层民众晋升中产阶级的难度。</p><p>K12双减政策这只是国家层面调整社会资本结构的一部分。要求给外卖小哥和快递员上社保、加强反垄断等等，你细品其实都有其影子。</p><p>回到开头的所说的内容，年轻人躺平。<br>国家正在极力扭转这种局面，尽可能降低底层民众晋升中产阶级的难度，靠自己的努力实现富裕，去卷中产阶级。促进中产阶级的孩子努力去卷更高的阶级。</p><p>生病了，药再苦也得吃啊，总不能等到无药可救吧。</p><hr><p>要求给外卖小哥和快递员上社保，平台给骑手买社保，平台的利润减少了，最终肯定会转移到骑手和商家上。<br>外卖提价，高端的店留在平台，低端的店退出；<br>优秀的骑手收入会增加，大量混日子的骑手退出；<br>有钱人外卖贵点也会点，没钱人没钱点外卖了，去线下小店吃吧。</p><p>反垄断，会让资本更多的流向中小企业，中小企业是吸纳就业的重要力量。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如题&lt;/p&gt;</summary>
    
    
    
    <category term="weekly" scheme="http://www.lights8080.com/categories/weekly/"/>
    
    
    <category term="weekly" scheme="http://www.lights8080.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>凤凰架构-透明多层分流系统</title>
    <link href="http://www.lights8080.com/p/fd2df2c4.html"/>
    <id>http://www.lights8080.com/p/fd2df2c4.html</id>
    <published>2021-08-08T16:00:00.000Z</published>
    <updated>2021-10-25T02:13:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>周志明《凤凰架构：构建可靠的大型分布式系统》<br><a href="https://icyfenix.cn/">https://icyfenix.cn/</a></p><p>包括：域名解析，客户端缓存，传输链路，传输压缩，内容分发，负载均衡，服务端缓存。</p><span id="more"></span><p>透明多级分流系统的设计原则：</p><ul><li>第一个原则是尽可能减少单点部件，如果某些单点是无可避免的，则应尽最大限度减少到达单点部件的流量。</li><li>第二个原则是奥卡姆剃刀原则，它更为关键。”如无必要，勿增实体“</li></ul><h2 id="域名解析-DNS"><a href="#域名解析-DNS" class="headerlink" title="域名解析(DNS)"></a>域名解析(DNS)</h2><p>以 <a href="http://www.icyfenix.com.cn/">www.icyfenix.com.cn</a> 为例，介绍DNS把域名解析成IP地址的过程：</p><ol><li>客户端先检查本地的 DNS 缓存，查看是否存在并且是存活着的该域名的地址记录。</li><li>客户端将地址发送给本机操作系统中配置的本地 DNS（Local DNS）</li><li>本地 DNS 收到查询请求后，会按照顺序依次查找地址记录，“ <a href="http://www.icyfenix.com.cn/">www.icyfenix.com.cn</a> 的权威服务器”→“ icyfenix.com.cn 的权威服务器”→“ com.cn 的权威服务器”→“cn 的权威服务器”→“根域名服务器“。</li><li>现在假设本地 DNS 是全新的，上面不存在任何域名的权威服务器记录，当 DNS 查询请求一直查到根域名服务器之后，会得到“cn 的权威服务器”的地址记录，然后通过“cn 的权威服务器”，得到“com.cn 的权威服务器”的地址记录，以此类推，最后找到能够解释 <a href="http://www.icyfenix.com.cn/">www.icyfenix.com.cn</a> 的权威服务器地址。</li><li>通过“<a href="http://www.icyfenix.com.cn/">www.icyfenix.com.cn</a> 的权威服务器”，查询 <a href="http://www.icyfenix.com.cn/">www.icyfenix.com.cn</a> 的地址记录。</li></ol><p>DNS 的分级查询都有可能受到中间人攻击的威胁，产生被劫持的风险。</p><p>HTTPDNS（也称为 DNS over HTTPS，DoH）：它把原本的 DNS 解析服务开放为一个基于 HTTPS 协议的查询服务，替代基于 UDP 传输协议的 DNS 域名解析，通过程序代替操作系统直接从权威 DNS，或者可靠 Local DNS 获取解析数据，从而绕过传统 Local DNS。</p><blockquote><p>“切勿浪费较多东西，去做‘用较少的东西，同样可以做好的事情’。”<br>手上有个新锤子，看啥都是对口的钉子。</p></blockquote><h2 id="客户端缓存"><a href="#客户端缓存" class="headerlink" title="客户端缓存"></a>客户端缓存</h2><p>分为强制缓存和协商缓存，这两套机制是并行工作。当强制缓存超过时效或者被禁用，协商缓存也仍然可以正常工作。</p><h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h3><p>根据资源的修改时间进行检查</p><h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p>Expires 是 HTTP/1.0 协议中开始提供的 Header，后面跟随了一个截止时间参数</p><blockquote><p>HTTP/1.1 200 OK<br>Expires: Wed, 8 Apr 2020 07:28:00 GMT</p></blockquote><p>问题：</p><ul><li>受限于客户端的本地时间</li><li>无法处理涉及到用户身份的私有资源</li><li>无法描述“不缓存”的语义</li></ul><h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p>Cache-Control 是 HTTP/1.1 协议中定义的强制缓存 Header，与 Expires 同时存在，且语义存在冲突时，IETF 规定必须以 Cache-Control 为准。</p><blockquote><p>HTTP/1.1 200 OK<br>Cache-Control: max-age=600</p></blockquote><ul><li>max-age：相对于请求时间多少秒内，缓存是有效的</li><li>s-maxage：“共享缓存”的有效时间，即允许被 CDN、代理等持有的缓存有效时间</li><li>public：意味着资源可以被代理、CDN 等缓存</li><li>private：就意味着只能由用户的客户端进行私有缓存</li><li>no-cache：表明该资源不应该被缓存，哪怕是同一个会话中对同一个 URL 地址的请求</li><li>no-store：不强制会话中是否重复获取相同的 URL 资源，禁止浏览器、CDN 等以任何形式保存该资源</li><li>no-transform：禁止资源以任何形式被修改，包括Content-Encoding、Content-Range、Content-Type</li><li>min-fresh：仅用于客户端的请求 Header，用于建议服务器能返回一个不少于该时间的缓存资源</li><li>only-if-cached：表示客户端只会接受代理缓存，而不会接受源服务器的响应。如果代理缓存无效，就直接返回 503/Service Unavailable 错误</li><li>must-revalidate：表示在资源过期后，一定要从服务器中进行获取</li><li>proxy-revalidate：用于提示代理、CDN 等设备资源过期后的缓存行为，语义与 must-revalidate 完全一致</li></ul><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>根据资源唯一标识是否发生变化来进行检查</p><h4 id="根据资源的修改时间进行检查"><a href="#根据资源的修改时间进行检查" class="headerlink" title="根据资源的修改时间进行检查"></a>根据资源的修改时间进行检查</h4><p>Last-Modified：服务器的响应 Header，用来告诉客户端这个资源的最后修改时间<br>If-Modified-Since：客户端再次请求时，会通过 If-Modified-Since，把之前收到的资源最后修改时间发送回服务端</p><p>服务端发现资源在该时间后没有被修改过，就只要返回一个 304/Not Modified 的响应即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 304 Not Modified</span><br><span class="line">Cache-Control: public, max-age=600</span><br><span class="line">Last-Modified: Wed, 8 Apr 2020 15:31:30 GMT</span><br></pre></td></tr></table></figure><h4 id="根据资源唯一标识是否发生变化来进行检查"><a href="#根据资源唯一标识是否发生变化来进行检查" class="headerlink" title="根据资源唯一标识是否发生变化来进行检查"></a>根据资源唯一标识是否发生变化来进行检查</h4><p>Etag：是服务器的响应 Header，用于告诉客户端这个资源的唯一标识<br>If-None-Match：当客户端需要再次请求时，就会通过 If-None-Match，把之前收到的资源唯一标识发送回服务端</p><h2 id="传输链路"><a href="#传输链路" class="headerlink" title="传输链路"></a>传输链路</h2><h3 id="前端网页的优化技巧"><a href="#前端网页的优化技巧" class="headerlink" title="前端网页的优化技巧"></a>前端网页的优化技巧</h3><ul><li>最少请求数量：TCP连接开销很大，解决手段有雪碧图，文件合并，媒体内联等</li><li>扩大并发请求数：现代浏览器一般支持6个并发请求，解决手段域名分片</li><li>启用压缩传输：减少网络传输内容的大小</li><li>避免页面重定向：页面发生了重定向，就会延迟整个文档的传输</li><li>按重要性调节资源优先级：对客户端展示影响大的资源，放在 HTML 的头部，以便优先下载</li><li>…</li></ul><p>因为 HTTP 协议还在持续发展，这些优化技巧可能会成为反模式。<br>HTTP/3以前是以 TCP 为传输层的应用层协，TCP 协议本身是面向长时间、大数据传输来设计的。<br>而每个页面包含的资源（HTML、CSS、JS、图片等）的特征是，数量多，资源小。<br>以至于 HTTP/1.x 时代，大量短而小的 TCP 连接导致了网络性能的瓶颈。</p><h3 id="Keep-Alive-机制"><a href="#Keep-Alive-机制" class="headerlink" title="Keep-Alive 机制"></a>Keep-Alive 机制</h3><p>（HTTP/1.0 中不是默认开启的，HTTP/1.1 中变为默认）<br>原理是让客户端对同一个域名长期持有一个或多个不会用完即断的 TCP 连接。客户端维护一个 FIFO 队列，每次取完数据之后的一段时间内，不自动断开连接，下一个资源时可以直接复用，避免创建 TCP 连接的成本。</p><p>副作用：队首阻塞，首个资源是一个复杂的请求，导致后面的请求必须阻塞等待。</p><h3 id="HTTP-2-的多路复用技术"><a href="#HTTP-2-的多路复用技术" class="headerlink" title="HTTP/2 的多路复用技术"></a>HTTP/2 的多路复用技术</h3><p>在 HTTP/1.x 中，HTTP 请求就是传输过程中最小粒度的信息单位，如果将多个请求切碎，再混杂在一块传输，客户端难以分辨重组出有效信息。<br>而在 HTTP/2 中，帧（Frame）才是最小粒度的信息单位。它可以用来描述各种数据，比如请求的 Headers、Body，或者是用来做控制标识，如打开流、关闭流。<br>流（Stream）是一个逻辑上的数据通道概念，每个帧都附带有一个流 ID，以标识这个帧属于哪个流。</p><p>多路复用的支持，HTTP/2 就可以对每个域名只维持一个 TCP 连接，开发者也不用去考虑并发请求数限制，客户端就不需要再刻意压缩 HTTP 请求。</p><p>在 HTTP 传输中，Headers 占传输成本的比重是相当地大，HTTP/2 中专门考虑如何进行 Header 压缩的问题，同一个连接上产生的请求和响应越多，头部压缩效果也就越好。所以 HTTP/2 是单域名单连接的机制，合并资源和域名分片反而对性能提升不利。</p><p>与 HTTP/1.x 相反，HTTP/2 本身反而变得更适合传输小资源。</p><h3 id="传输压缩"><a href="#传输压缩" class="headerlink" title="传输压缩"></a>传输压缩</h3><p>当客户端可以接受压缩版本的资源时（请求的 Header 中包含 Accept-Encoding: gzip），就返回压缩后的版本（响应的 Header 中包含 Content-Encoding: gzip），否则就返回未压缩的原版。</p><h4 id="静态预压缩"><a href="#静态预压缩" class="headerlink" title="静态预压缩"></a>静态预压缩</h4><p>在网络时代的早期，服务器的处理能力还很薄弱，为了启用压缩，会把静态资源预先压缩为.gz 文件的形式给存放起来。</p><h4 id="即时压缩"><a href="#即时压缩" class="headerlink" title="即时压缩"></a>即时压缩</h4><p>现代的 Web 服务器处理能力有了大幅提升，整个压缩过程全部在内存的数据流中完成，不必等资源压缩完成再返回响应，这样可以显著提高首字节时间，改善 Web 性能体验。</p><p>在 HTTP/1.0 时，资源结束判断的机制，只有根据 Content-Length 判断。<br>但即时压缩时，服务器再也没有办法给出 Content-Length 这个响应 Header 了。<br>所以，如果是 HTTP/1.0 的话，持久连接和即时压缩只能二选其一。<br>在 HTTP/1.0 中这两者都支持，却默认都是不启用。</p><h4 id="分块编码"><a href="#分块编码" class="headerlink" title="分块编码"></a>分块编码</h4><p>HTTP/1.1中，增加了另一种资源结束判断的机制，“分块传输编码”（Chunked Transfer Encoding）。</p><p>工作原理：在响应 Header 中加入“Transfer-Encoding: chunked”之后，就代表这个响应报文将采用分块编码。此时，报文中的 Body 需要改为用一系列“分块”来传输。每个分块包含十六进制的长度值和对应长度的数据内容，长度值独占一行，数据从下一行开始。最后以一个长度值为 0 的分块，来表示资源结束。</p><h3 id="快速-UDP-网络连接"><a href="#快速-UDP-网络连接" class="headerlink" title="快速 UDP 网络连接"></a>快速 UDP 网络连接</h3><p>想从根本上改进 HTTP，就必须直接替换掉 HTTP over TCP 的根基，即 TCP 传输协议。2018 年末，IETF 正式批准了 HTTP over QUIC 使用 HTTP/3 的版本号，它会以 UDP 协议作为基础。</p><h2 id="内容分发网络-CDN"><a href="#内容分发网络-CDN" class="headerlink" title="内容分发网络(CDN)"></a>内容分发网络(CDN)</h2><p>CDN 其实就是做“内容分销”工作的。</p><p>内容分发网络的工作过程，主要涉及到路由解析、内容分发、负载均衡和它所能支持的应用内容四个方面。</p><p>仅从网络传输的角度来看，一个互联网系统的速度快慢，主要取决于以下四点因素：</p><ol><li>网站服务器接入网络运营商的链路所能提供的出口带宽。</li><li>用户客户端接入网络运营商的链路所能提供的入口带宽。</li><li>从网站到用户之间，经过的不同运营商之间互联节点的带宽。</li><li>从网站到用户之间的物理链路传输时延。</li></ol><h3 id="路由解析"><a href="#路由解析" class="headerlink" title="路由解析"></a>路由解析</h3><p><img src="https://gitee.com/lights8080/lights8080-oss/raw/master/2021/08/kCQhKS.png" alt="CDN 路由解析"></p><h3 id="内容分发"><a href="#内容分发" class="headerlink" title="内容分发"></a>内容分发</h3><p>无论是对用户还是服务器，内容分发网络都可以是完全透明的，CDN需要解决两个问题：“如何获取源站资源”和“如何管理（更新）资源”。</p><h4 id="第一种：主动分发（Push）"><a href="#第一种：主动分发（Push）" class="headerlink" title="第一种：主动分发（Push）"></a>第一种：主动分发（Push）</h4><p>主动分发就是由源站主动发起，将内容从源站或者其他资源库推送到用户边缘的各个 CDN 缓存节点上。</p><p>通常需要源站、CDN 服务双方提供的程序 API 接口层面的配合。</p><h4 id="第二种：被动回源（Pull）"><a href="#第二种：被动回源（Pull）" class="headerlink" title="第二种：被动回源（Pull）"></a>第二种：被动回源（Pull）</h4><p>由用户访问所触发的全自动、双向透明的资源缓存过程。当某个资源首次被用户请求的时候，CDN 缓存节点如果发现自己没有该资源，就会实时从源站中获取。</p><p>可以做到完全的双向透明，不需要源站在程序上做任何的配合，使用起来非常方便。</p><h4 id="如何管理（更新）资源"><a href="#如何管理（更新）资源" class="headerlink" title="如何管理（更新）资源"></a>如何管理（更新）资源</h4><p>对于Cache-Control的 s-maxage，是否遵循，完全取决于 CDN 本身的实现策略。</p><p>CDN 缓存的管理没有通用的准则，最常见的管理（更新）资源的做法是超时被动失效与手工主动失效相结合。</p><h3 id="CDN-应用"><a href="#CDN-应用" class="headerlink" title="CDN 应用"></a>CDN 应用</h3><ul><li>加速静态资源</li><li>安全防御，DDoS攻击</li><li>协议升级，https，IPv6</li><li>状态缓存</li><li>修改资源，给源站不支持跨域的资源提供跨域能力</li><li>访问控制，QoS控制，referer防盗链</li><li>注入功能，Google Analytics等</li></ul><h2 id="负载均衡-Load-Balancing"><a href="#负载均衡-Load-Balancing" class="headerlink" title="负载均衡(Load Balancing)"></a>负载均衡(Load Balancing)</h2><p>“负载均衡器”（Load Balancer）：承担了调度后方的多台机器，以统一的接口对外提供服务的技术组件。</p><p>从形式上来说都可以分为两种：四层负载均衡和七层负载均衡。四层负载均衡的优势是性能高，七层负载均衡的优势是功能强。</p><table><thead><tr><th></th><th><div style="width:135px"><strong>层</strong></div></th><th><div style="width:75px"><strong>数据单元</strong></div></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>7</td><td>应用层 <br/>Application Layer</td><td>数据<br/>Data</td><td>提供为应用软件提供服务的接口，用于与其他应用软件之间的通信。典型协议：HTTP、HTTPS、FTP、Telnet、SSH、SMTP、POP3 等</td></tr><tr><td>6</td><td>表达层<br/>Presentation Layer</td><td>数据 <br/>Data</td><td>把数据转换为能与接收者的系统格式兼容并适合传输的格式。</td></tr><tr><td>5</td><td>会话层 <br/>Session Layer</td><td>数据 <br/>Data</td><td>负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接。</td></tr><tr><td>4</td><td>传输层 <br/>Transport Layer</td><td>数据段<br/>Segments</td><td>把传输表头加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。典型协议：TCP、UDP、RDP、SCTP、FCP 等</td></tr><tr><td>3</td><td>网络层 <br/>Network Layer</td><td>数据包<br/>Packets</td><td>决定数据的传输路径选择和转发，将网络表头附加至数据段后以形成报文（即数据包）。典型协议：IPv4/IPv6、IGMP、ICMP、EGP、RIP 等</td></tr><tr><td>2</td><td>数据链路层 <br/>Data Link Layer</td><td>数据帧<br/>Frame</td><td>负责点对点的网络寻址、错误侦测和纠错。当表头和表尾被附加至数据包后，就形成数据帧（Frame）。典型协议：WiFi（802.11）、Ethernet（802.3）、PPP 等。</td></tr><tr><td>1</td><td>物理层<br/>Physical Layer</td><td>比特流<br/>Bit</td><td>在局域网上传送数据帧，它负责管理电脑通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机接口卡等。</td></tr></tbody></table><h4 id="四层负载均衡"><a href="#四层负载均衡" class="headerlink" title="四层负载均衡"></a>四层负载均衡</h4><p>四层负载均衡的工作模式都属于“转发”，即直接将承载着 TCP 报文的底层数据格式（IP 数据包或以太网帧），转发到真实服务器上，此时客户端到响应请求的真实服务器维持着同一条 TCP 通道。</p><p><strong>数据链路层负载均衡</strong><br>数据链路层传输的内容是数据帧（Frame），只需要注意到“MAC 目标地址”和“MAC 源地址”两项即可。</p><p>工作原理：修改请求的数据帧中的 MAC 目标地址，让用户原本是发送给负载均衡器的请求的数据帧，被二层交换机根据新的 MAC 目标地址，转发到服务器集群中，对应的服务器的网卡上，这样真实服务器就获得了一个原本目标并不是发送给它的数据帧。</p><p>数据链路层负载均衡的工作模式是，只有请求会经过负载均衡器，而服务的响应不需要从负载均衡器原路返回，整个请求、转发、响应的链路形成了一个“三角关系”，又叫“三角传输模式”，“单臂模式”，“直接路由”。</p><p>二层负载均衡器工作原理决定了，它们必须位于同一个子网当中，无法跨 VLAN。这个优势（效率高）和劣势（不能跨子网）就共同决定了，数据链路层负载均衡最适合用来做数据中心的第一级均衡设备，用来连接其他的下级负载均衡器。</p><p><strong>网络层负载均衡</strong><br>网络层传输的单位是分组数据包（Packets），只要知道在 IP 分组数据包的 Headers 带有源和目标的 IP 地址即可。</p><p>第一种：保持原来的数据包不变，新创建一个数据包。(IP隧道)<br>优点：</p><ul><li>并没有修改原有数据包中的任何信息，仍然具备三角传输特性</li><li>IP 隧道工作在网络层，所以可以跨越 VLAN</li></ul><p>缺点：</p><ul><li>真实服务器收到数据包后，必须在接收入口处，设计拆包机制。(几乎所有Linux系统都支持IP隧道协议)</li><li>必须保证所有的真实服务器与均衡器有着相同的虚拟 IP 地址</li></ul><p>第二种：改变目标数据包，直接把数据包 Headers 中的目标地址改掉(NAT 模式)<br>NAT模式：充当了家里、公司、学校的上网路由器的作用。</p><p>优点：</p><ul><li>没有经过 IP 隧道的额外包装，无需再拆包了</li><li>彻底的透明，真实服务器连网关都不需要配置，均衡器在转发时不仅修改目标 IP 地址，连源 IP 地址也一起改了</li></ul><p>缺点：</p><ul><li>不具备三角传输特性，必须回到负载均衡，改回自己的IP，再发给客户端。流量压力比较大时，带来较大的性能损失</li><li>真实服务器处理请求时就无法拿到客户端的 IP 地址</li></ul><h4 id="应用层负载均衡"><a href="#应用层负载均衡" class="headerlink" title="应用层负载均衡"></a>应用层负载均衡</h4><p>工作在四层之后的负载均衡模式就无法再进行转发了，只能进行代理。此时正式服务器、负载均衡器、客户端三者之间，是由两条独立的 TCP 通道来维持通讯的。</p><p><img src="https://gitee.com/lights8080/lights8080-oss/raw/master/2021/08/uHa47g.jpg" alt="转发与代理"></p><p>分类：</p><ul><li>正向代理就是我们通常简称的代理，意思就是在客户端设置的、代表客户端与服务器通讯的代理服务。它是客户端可知，而对服务器是透明的。</li><li>反向代理是指设置在服务器这一侧，代表真实服务器来与客户端通讯的代理服务。此时它对客户端来说是透明的。</li><li>透明代理是指对双方都透明的，配置在网络中间设备上的代理服务。比如，架设在路由器上的透明翻墙代理。</li></ul><p>七层负载均衡器，不能去做下载站、视频站这种流量应用，起码不能作为第一级均衡器。<br>缺点：网络性能比不过四层负载均衡器，多一轮TCP握手，还有 NAT 转发模式一样的带宽问题<br>优点：可以感知应用层通讯的具体内容，往往能够做出更明智的决策</p><p>应用：</p><ul><li>缓存方面的工作，比如静态资源缓存、协议升级、安全防护、访问控制等</li><li>更智能化的路由，比如Session 路由、亲和性集群、URL路由、根据用户路由等</li><li>某些安全攻击可以由七层负载均衡器来抵御，比如DDoS 手段是 SYN Flood 攻击</li><li>链路治理措施，比如服务降级、熔断、异常注入等</li><li>…</li></ul><h4 id="均衡策略与实现"><a href="#均衡策略与实现" class="headerlink" title="均衡策略与实现"></a>均衡策略与实现</h4><p>均衡策略与实现</p><ul><li>轮循均衡</li><li>权重轮循均衡</li><li>随机均衡</li><li>权重随机均衡</li><li>一致性哈希均衡</li><li>响应速度均衡</li><li>最少连接数均衡</li></ul><p>负载均衡器的实现有“软件均衡器”和“硬件均衡器”两类。</p><p>软件均衡器又分为直接建设在操作系统内核的均衡器和应用程序形式的均衡器两种。前者的代表是 LVS（Linux Virtual Server），后者的代表有 Nginx、HAProxy、KeepAlived，等等；前者的性能会更好，因为它不需要在内核空间和应用空间中来回复制数据包；而后者的优势是选择广泛，使用方便，功能不受限于内核版本。</p><p>硬件均衡器，往往会直接采用应用专用集成电路来实现。因为它有专用处理芯片的支持，可以避免操作系统层面的损耗，从而能够达到最高的性能。这类的代表就是著名的 F5 和 A10 公司的负载均衡产品。</p><h2 id="缓存-Cache"><a href="#缓存-Cache" class="headerlink" title="缓存(Cache)"></a>缓存(Cache)</h2><p>服务端缓存是一种通用的技术组件，它主要用于减少多个客户端相同的资源请求，缓解或降低服务器的负载压力。</p><p>引入缓存的理由，1）为了缓解 CPU 压力而做缓存，2）为了缓解 I/O 压力而做缓存。<br>如果你可以通过增强 CPU、I/O 本身的性能（比如扩展服务器的数量）来满足需要的话，那升级硬件往往是更好的解决方案。</p><p>吞吐量（每秒操作数，Operations per Second，ops/s）：它反映了对缓存进行并发读、写操作的效率，即缓存本身的工作效率高低。<br>缓存的吞吐量只在并发场景中才有统计的意义，所以，并发读写的场景中，“尽可能避免数据竞争”是最关键的。<br>针对伴随读写操作而来的状态维护，有两种处理思路。一种是以 Guava Cache 为代表的同步处理机制，另一种是以 Caffeine 为代表的异步日志提交机制。</p><p>缓存策略：</p><ul><li>FIFO（First In First Out）：优先淘汰最早进入被缓存的数据</li><li>LRU（Least Recent Used）：优先淘汰最久未被使用访问过的数据</li><li>LFU（Least Frequently Used）：优先淘汰最不经常使用的数据</li><li>TinyLFU（Tiny Least Frequently Used）：TinyLFU 是 LFU 的改进版本，通过用少量的样本数据来估计全体数据的特征。用相对小得多的记录频率和空间，来近似地找出缓存中的低价值数据。</li></ul><p>扩展知识：</p><blockquote><ol><li>ConcurrentHashMap（JDK8）中读操作完全没有线程安全措施，无论是CAS还是Synchronized都没有做。写操作是通过CAS来做节点位置判断，通过Synchronized来修改值。单个值级别的锁定意味着只有不同线程、修改同一个值才会有锁竞争。不同线程修改不同的值不会竞争相同的锁，或者相同线程修改同一个值锁是可重入的，简而言之“有锁”并不一定是指“有竞争”。</li><li>软件开发两大难题，一个是缓存失效，该失效时未失效，不该失效时失效，另一个是命名。</li><li>环形缓冲(Ring Buffer)：它是一种拥有读、写两个指针的数据复用结构。</li></ol></blockquote><h3 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h3><p>缓存可以分为“进程内缓存”和“分布式缓存”两大类。</p><p>进程内缓存：只为节点本身提供服务，无网络访问操作，速度快但缓存的数据不能在各个服务节点中共享。<br>分布式缓存：与进程内缓存相反，处理与网络有关的操作是影响吞吐量的主要因素。分为复制式缓存与集中式缓存。</p><p>复制式缓存，可以看作是“能够支持分布式的进程内缓存”，工作原理与 Session 复制类似，代表是JBossCache。缺点是复制性能会随着节点的增加呈现平方级下降，基本上已经很难再见到使用这种缓存形式的大型信息系统了。<br>集中式缓存，是目前分布式缓存的主流形式，代表是Redis。缺点是缓存的读、写都需要网络访问，不可能再达到进程内缓存那样的高性能。好处是不会随着集群节点数量的增加而产生额外的负担.</p><p>分布式缓存集群是否能保证数据一致性，也可以将它分为 AP 和 CP 两种类型，通常不太会使用缓存来处理追求强一致性的数据。<br>Redis 集群就是典型的 AP 式，它具有高性能、高可用等特点，但它却并不保证强一致性。而能够保证强一致性的 ZooKeeper、Doozerd、Etcd 等分布式协调框架，通常不会把它们当作“缓存框架”来使用。倒是常跟 Redis 和其他分布式缓存搭配工作，用来实现其中的通知、协调、队列、分布式锁等功能。</p><p>分布式缓存与进程内缓存各有所长，它们是互补的，而不是竞争的关系。所以，完全可以同时互相搭配，来构成透明多级缓存（Transparent Multilevel Cache，TMC）。</p><p>多级缓存的意思是，使用进程内缓存做一级缓存，分布式缓存做二级缓存。但代码侵入性较大，不便于管理，数据更新更是麻烦，很容易出现一二级缓存里的数据不一致。<br>如何“透明”地解决这些问题，多级缓存才具有实用的价值。<br>一种常见的设计原则，就是变更以分布式缓存中的数据为准，访问以进程内缓存的数据优先。大致做法是当数据发生变动时，在集群内发送推送通知（引入ZooKeeper 或 Etcd 来处理），让各个节点的一级缓存自动失效掉相应数据。</p><h3 id="缓存风险"><a href="#缓存风险" class="headerlink" title="缓存风险"></a>缓存风险</h3><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>查询的数据在数据库中根本不存在的话，请求的流量每次都不会命中，每次都会触及到末端的数据库。这种查询不存在数据的现象，就被称为缓存穿透。</p><p>解决办法：<br>1）对于业务逻辑本身就不能避免的缓存穿透，约定一定时间内，返回空的Key依然进行缓存。<br>2）对于恶意攻击导致的缓存穿透，设置布隆过滤器，用最小的代价，判断某个元素是否存在。</p><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>缓存中的某些热点数据忽然因为某种原因失效了，都到达真实数据源中去，导致其压力剧增。这种现象，就被称为缓存击穿。</p><p>解决办法：<br>1）加锁同步，以请求该数据的 Key 值为锁，其他线程采取阻塞或重试策略。<br>2）热点数据由代码来手动管理</p><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>由于大批不同的数据在短时间内一起失效，导致了这些数据的请求都击穿了缓存，到达数据源。这种现象，就被称为缓存雪崩。</p><p>解决办法：<br>1）提升缓存系统可用性，建设分布式缓存的集群。<br>2）分散了它们的过期时间<br>3）将缓存的生存期从固定时间改为一个时间段内的随机时间</p><h4 id="缓存污染"><a href="#缓存污染" class="headerlink" title="缓存污染"></a>缓存污染</h4><p>缓存中的数据与真实数据源中的数据不一致的现象。</p><p>为了尽可能地提高使用缓存时的一致性，人们已经总结了不少更新缓存时可以遵循的设计模式，比如 Cache Aside、Read/Write Through、Write Behind Caching，等等。</p><h5 id="Cache-Aside："><a href="#Cache-Aside：" class="headerlink" title="Cache Aside："></a>Cache Aside：</h5><ul><li>读数据时，先读缓存，缓存没有的话，再读数据源，然后将数据放入缓存，再响应请求。</li><li>写数据时，先写数据源，然后失效（而不是更新）掉缓存。</li></ul><p>Cache Aside 模式依然也不能保证在一致性上绝对不出问题，采用 Cache Aside 模式典型的出错场景，就是如果某个数据是从未被缓存过的，请求会直接流到真实数据源中，如果数据源中的写操作发生在查询请求之后，结果回填到缓存之前，也会出现缓存中回填的内容与数据库的实际数据不一致的情况。<br>但是，出现这种情况的概率实际上是很低的，Cache Aside 模式仍然是以低成本更新缓存，并且获得相对可靠结果的解决方案。</p><h5 id="Read-Write-Through"><a href="#Read-Write-Through" class="headerlink" title="Read/Write Through"></a>Read/Write Through</h5><ul><li>Read Through，读数据时，先读缓存，缓存没有的话，由缓存组件负责读数据源将数据放入缓存，再响应请求。</li><li>Write Through，写数据时，先写入缓存，由缓存组件负责同步更新到数据源中。</li></ul><h5 id="Write-Behind-Caching"><a href="#Write-Behind-Caching" class="headerlink" title="Write Behind Caching"></a>Write Behind Caching</h5><p>Write back是相较于Write Through而言的一种异步回写策略，由缓存组件负责异步更新到数据源中。适用于读少写多的场景。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;周志明《凤凰架构：构建可靠的大型分布式系统》&lt;br&gt;&lt;a href=&quot;https://icyfenix.cn/&quot;&gt;https://icyfenix.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;包括：域名解析，客户端缓存，传输链路，传输压缩，内容分发，负载均衡，服务端缓存。&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="技术" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="凤凰架构" scheme="http://www.lights8080.com/tags/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>2108-1-什么才是给孩子最好的礼物</title>
    <link href="http://www.lights8080.com/p/f438d8cc.html"/>
    <id>http://www.lights8080.com/p/f438d8cc.html</id>
    <published>2021-08-05T16:00:00.000Z</published>
    <updated>2021-09-28T07:25:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>如题</p><span id="more"></span><h2 id="话题：什么才是给孩子最好的礼物"><a href="#话题：什么才是给孩子最好的礼物" class="headerlink" title="话题：什么才是给孩子最好的礼物"></a>话题：什么才是给孩子最好的礼物</h2><p>如果说“给孩子最好的礼物是陪伴”，相信大部分人都不会反驳，且还能说出一大堆的理由来。</p><p>我试着脑补了一下，在孩子的不同时期，问他俩个问题：<br>“”“<br>孩子10岁，你问他什么最重要？他会回答是陪伴；<br>20岁问他什么最重要，他会说钱；你再问快乐的童年重要吗，他会想想说也重要。<br>30岁问他什么最重要，他会告诉你是环境和成长经历；快乐的童年重要吗，没那么重要。<br>“”“</p><p>如果在读的你现在已经三十几岁已经有孩子，对于上面这个回答并不排斥吧    </p><p>为什么家长从小就给孩子报各种补习班？那是因为我们都知道相比于快乐的童年，孩子的未来更重要，孩子将来长大了一定不会怪我。</p><p>我们都很想时刻陪在孩子身边，但是总得想想孩子20岁，30岁时最需要的是什么。真的在乎童年的陪伴吗？</p><p>我这样说，并不是我认为小时候对孩子的陪伴不重要。相反，我也认为很重要，但我想表达的是陪伴的重要性是要建立在生长环境、成长经历和财务支持等基础之上的。</p><p>如果你有能力把这些都平衡好，那真的很完美，对于普通人而言，必须有所取舍。</p><p>很遗憾没有给你美好的童年，如果现在有机会能让你在20岁，30岁时多一点点的选择，那就够了。</p><hr><p>这个思考来源于，最近二姐一家五口驱车从天津出发开往西藏。一次说走就走的旅行，这一定是很多人羡慕和向往的生活方式。</p><p>在这之前说实话我对姐夫有一定的偏见，而且是很固执的，根本原因就是没有对家庭的陪伴。</p><p>“我也想天天在家里陪着他们，你知道仨孩子上学要多少钱，将来出国留学，结婚要多少钱。我不出去挣钱，日子怎么过，她们不理解我，咱俩是男的，我以为你能理解我”<br>上面这句话是我俩单独聊天他说的（并非原话，意思一样）。</p><p>说实话，当时我并没有理解。但是随着年龄的增长，我越来越能get到他的点。<br>抛去那些分支乱插，从现在的结果来看，我觉得他并没有敷衍，而且正在一步一步的践行自己的承诺。</p><p>初心未变，负重前行。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如题&lt;/p&gt;</summary>
    
    
    
    <category term="weekly" scheme="http://www.lights8080.com/categories/weekly/"/>
    
    
    <category term="weekly" scheme="http://www.lights8080.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>凤凰架构-分布式事务</title>
    <link href="http://www.lights8080.com/p/c901dee9.html"/>
    <id>http://www.lights8080.com/p/c901dee9.html</id>
    <published>2021-08-04T16:00:00.000Z</published>
    <updated>2021-09-07T03:50:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>周志明《凤凰架构：构建可靠的大型分布式系统》<br><a href="https://icyfenix.cn/">https://icyfenix.cn/</a></p><p>包括：CAP、BASE理论。实现分布式事务的三种解决方案，可靠消息队列、TCC、SAGA事务。</p><p>可靠消息队列：简单、无法解决隔离性问题<br>TCC：编码实现业务隔离性，但要求技术可控性（预留资源接口），硬编码可以使用Seata<br>SAGA事务：编码实现业务隔离性和补偿机制，不要求技术可控性，硬编码可以使用Seata</p><span id="more"></span><p>分布式事务（Distributed Transaction）特指<strong>多个服务同时访问多个数据源</strong>的事务处理机制。</p><h4 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h4><p>分布式系统（distributed system）的最大难点，就是各个节点的状态如何同步。CAP 定理是这方面的基本定理。</p><ul><li><p>一致性（Consistency）：代表在任何时刻、任何分布式节点中所看到的数据都是符合预期的。</p></li><li><p>可用性（Availability）：代表系统不间断地提供服务的能力。密切相关两个指标：可靠性（平均无故障时间：MTBF）和可维护性（平均可修复时间：MTTR）。</p></li><li><p>分区容忍性（Partition Tolerance）：代表分布式环境中部分节点因网络原因而彼此失联（即与其他节点形成“网络分区”）时，系统仍能正确地提供服务的能力。</p></li><li><p>如果放弃分区容忍性（CA without P），意味着我们将假设节点之间通信永远是可靠的。永远可靠的通信在分布式系统中必定不成立的。主流的 RDBMS（关系数据库管理系统）集群通常就是采用放弃分区容错性的工作模式。</p></li><li><p>如果放弃可用性（CP without A），意味着我们将假设一旦网络发生分区，节点之间的信息同步时间可以无限制地延长，此时，问题相当于退化到前面“全局事务”中讨论的一个系统使用多个数据源的场景之中，我们可以通过 2PC/3PC 等手段，同时获得分区容忍性和一致性。著名的 HBase 也是属于 CP 系统。</p></li><li><p>如果放弃一致性（AP without C），意味着我们将假设一旦发生分区，节点之间所提供的数据可能不一致。选择放弃一致性的 AP 系统目前是设计分布式系统的主流选择，因为 P 是分布式网络的天然属性，而 A 通常是建设分布式的目的。目前大多数 NoSQL 库和支持分布式的缓存框架都是 AP 系统，如Redis集群。</p></li></ul><p>CAP、ACID 中讨论的一致性称为“强一致性”（Strong Consistency）。把牺牲了 C 的 AP 系统，叫做“最终一致性”（Eventual Consistency）。它是指，如果数据在一段时间内没有被另外的操作所更改，那它最终将会达到与强一致性过程相同的结果，有时候面向最终一致性的算法，也被称为“乐观复制算法”。</p><h4 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h4><p>BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的结论，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。</p><p>BASE 分别是基本可用性（Basically Available）、柔性事务（Soft State）和最终一致性（Eventually Consistent）的缩写。</p><ul><li>基本可用性（Basically Available）：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。</li><li>柔性事务（Soft State）：允许系统存在中间状态，而该中间状态不会影响系统整体可用性。这里的中间状态就是 CAP 理论中的数据不一致。</li><li>最终一致性（Eventually Consistent）：系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。</li></ul><h2 id="可靠消息队列"><a href="#可靠消息队列" class="headerlink" title="可靠消息队列"></a>可靠消息队列</h2><p>前面这种靠着持续重试来保证可靠性的操作，在计算机中就非常常见，它有个专门的名字，叫做“最大努力交付”（Best-Effort Delivery），比如 TCP 协议中的可靠性保障，就属于最大努力交付。</p><p>支持分布式事务的消息框架，如 RocketMQ，原生就支持分布式事务操作。</p><h2 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h2><p>可靠消息队列虽然能保证最终的结果是相对可靠的，过程也足够简单（相对于 TCC 来说），但整个过程完全没有任何隔离性可言，有一些业务中隔离性是无关紧要的，但有一些业务中缺乏隔离性就会带来许多麻烦。譬如：超售。</p><p>TCC 是另一种常见的分布式事务机制，它是“Try-Confirm-Cancel”三个单词的缩写。</p><p>TCC 的实现过程分为了三个阶段：</p><ul><li>Try：尝试执行阶段，完成所有业务可执行性的检查（保障一致性），并且预留好全部需用到的业务资源（保障隔离性）。</li><li>Confirm：确认执行阶段，不进行任何业务检查，直接使用 Try 阶段准备的资源来完成业务处理。Confirm 阶段可能会重复执行，因此本阶段所执行的操作需要具备幂等性。</li><li>Cancel：取消执行阶段，释放 Try 阶段预留的业务资源。Cancel 阶段可能会重复执行，也需要满足幂等性。</li></ul><p>它是一种业务侵入性较强的事务方案，要求业务处理过程必须拆分为“预留业务资源”和“确认 / 释放消费资源”两个子过程。</p><p>TCC 其实有点类似 2PC 的准备阶段和提交阶段，但 TCC 是位于用户代码层面，而不是在基础设施层面，这为它的实现带来了较高的灵活性，可以根据需要设计资源锁定的粒度。TCC 在业务执行时只操作预留资源，几乎不会涉及锁和资源的争用，具有很高的性能潜力。但是 TCC 并非纯粹只有好处，它也带来了更高的开发成本和业务侵入性，意味着有更高的开发成本和更换事务实现方案的替换成本。</p><p>通常我们并不会完全靠裸编码来实现 TCC，而是基于某些分布式事务中间件（譬如阿里开源的Seata）去完成，尽量减轻一些编码工作量。</p><h2 id="SAGA事务"><a href="#SAGA事务" class="headerlink" title="SAGA事务"></a>SAGA事务</h2><p>TCC 事务具有较强的隔离性，避免了“超售”的问题，而且其性能一般来说是本篇提及的几种柔性事务模式中最高的，但它仍不能满足所有的场景。TCC 的最主要限制是它的业务侵入性很强，不止是它需要开发编码配合所带来的工作量，而更多的是指它所要求的技术可控性上的约束。譬如，网银支付，通常也就无法完成冻结款项、解冻、扣减这样的操作。</p><p>SAGA 事务基于数据补偿代替回滚的解决思路。大致思路是把一个大事务分解为可以交错运行的一系列子事务集合。每个子事务都应该是或者能被视为是原子行为；为每一个子事务设计对应的补偿动作。</p><p>两种恢复策略：<br>正向恢复（Forward Recovery）：T1，T2，…，Ti（失败），Ti（重试）…，Ti+1，…，Tn<br>反向恢复（Backward Recovery）：T1，T2，…，Ti（失败），Ci（补偿），…，C2，C1。</p><p>与 TCC 相比，SAGA 不需要为资源设计冻结状态和撤销冻结的操作，补偿操作往往要比冻结操作容易实现得多。</p><p>SAGA 事务通常也不会直接靠裸编码来实现，一般也是在事务中间件的基础上完成，前面提到的 Seata 就同样支持 SAGA 事务模式。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;周志明《凤凰架构：构建可靠的大型分布式系统》&lt;br&gt;&lt;a href=&quot;https://icyfenix.cn/&quot;&gt;https://icyfenix.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;包括：CAP、BASE理论。实现分布式事务的三种解决方案，可靠消息队列、TCC、SAGA事务。&lt;/p&gt;
&lt;p&gt;可靠消息队列：简单、无法解决隔离性问题&lt;br&gt;TCC：编码实现业务隔离性，但要求技术可控性（预留资源接口），硬编码可以使用Seata&lt;br&gt;SAGA事务：编码实现业务隔离性和补偿机制，不要求技术可控性，硬编码可以使用Seata&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="技术" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="凤凰架构" scheme="http://www.lights8080.com/tags/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84/"/>
    
    <category term="事务" scheme="http://www.lights8080.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>凤凰架构-全局事务和共享事务</title>
    <link href="http://www.lights8080.com/p/53149592.html"/>
    <id>http://www.lights8080.com/p/53149592.html</id>
    <published>2021-08-03T16:00:00.000Z</published>
    <updated>2021-09-07T03:50:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>周志明《凤凰架构：构建可靠的大型分布式系统》<br><a href="https://icyfenix.cn/">https://icyfenix.cn/</a></p><p>XA、JTA、两阶段提交、三阶段提交</p><span id="more"></span><h2 id="全局事务"><a href="#全局事务" class="headerlink" title="全局事务"></a>全局事务</h2><p>在本节里，全局事务被限定为一种<strong>适用于单个服务使用多个数据源场景</strong>的事务解决方案。</p><p>为了解决分布式事务的一致性问题，X/Open组织提出了一套名为X/Open XA（XA 是 eXtended Architecture 的缩写）的处理事务架构，其核心内容是定义了全局的事务管理器（Transaction Manager，用于协调全局事务）和局部的资源管理器（Resource Manager，用于驱动本地事务）之间的通信接口。</p><p>XA 接口是双向的，能在一个事务管理器和多个资源管理器（Resource Manager）之间形成通信桥梁，通过协调多个数据源的一致动作，实现全局事务的统一提交或者统一回滚。</p><p>JTA（Java Transaction API）是基于 XA 模式在 Java 语言中的实现了全局事务处理的标准。</p><p>XA 将事务提交拆分成为两阶段过程，两阶段式提交（2 Phase Commit，2PC）：</p><ul><li>准备阶段（又叫作投票阶段，对于数据库来说，它与本地事务中真正提交的区别只是暂不写入最后一条 Commit Record 而已，并不立即释放隔离性，即仍继续持有锁）</li><li>提交阶段（又叫作执行阶段，对于数据库来说，这个阶段的提交操作应是很轻量的，仅仅是持久化一条 Commit Record 而已，通常能够快速完成）</li></ul><p>缺点：</p><ul><li>单点问题：协调者宕机，所有参与者都必须一直等待</li><li>性能问题：两段提交过程中，所有参与者相当于被绑定成为一个统一调度的整体，期间要经过两次远程服务调用，三次数据持久化（准备阶段写重做日志，协调者做状态持久化，提交阶段在日志写入 Commit Record）</li><li>一致性风险：前面已经提到，两段式提交的成立是有前提条件的，当网络稳定性和宕机恢复能力的假设不成立时，仍可能出现一致性问题。</li></ul><p>为了缓解两段式提交协议的一部分缺陷，具体地说是协调者的单点问题和准备阶段的性能问题，后续又发展出了“三段式提交”（3 Phase Commit，3PC）协议。<br>三段式提交把原本的两段式提交的准备阶段再细分为两个阶段，分别称为 CanCommit、PreCommit，把提交阶段改称为 DoCommit 阶段。</p><h2 id="共享事务"><a href="#共享事务" class="headerlink" title="共享事务"></a>共享事务</h2><p>共享事务（Share Transaction）是指<strong>多个服务共用同一个数据源</strong>。这里有必要再强调一次“数据源”与“数据库”的区别：数据源是指提供数据的逻辑设备，不必与物理设备一一对应。</p><p>如果直接将不同数据源视为不同的数据库，那完全可以用全局事务或者下一讲要学习的分布式事务来实现。</p><p>如果针对每个数据源连接的都是同一个物理数据库的特例，一种理论可行的方案是，直接让各个服务共享数据库连接。同一个应用进程中共享数据库连接并不困难，但不同服务节点共享数据库连接很难做到，为了实现共享事务，就必须新增一个中间角色。</p><p>这在分布式的场景下是个伪需求，你有充足理由让多个微服务去共享数据库，那就必须找到更加站得住脚的理由，来向团队解释拆分微服务的目的是什么。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;周志明《凤凰架构：构建可靠的大型分布式系统》&lt;br&gt;&lt;a href=&quot;https://icyfenix.cn/&quot;&gt;https://icyfenix.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;XA、JTA、两阶段提交、三阶段提交&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="技术" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="凤凰架构" scheme="http://www.lights8080.com/tags/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84/"/>
    
    <category term="事务" scheme="http://www.lights8080.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
</feed>
