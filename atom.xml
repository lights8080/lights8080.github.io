<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>七路灯</title>
  
  <subtitle>人的一生应当有许多停靠站，但愿每一个站台都有一盏雾中的灯。</subtitle>
  <link href="http://www.lights8080.com/atom.xml" rel="self"/>
  
  <link href="http://www.lights8080.com/"/>
  <updated>2021-10-29T07:02:20.000Z</updated>
  <id>http://www.lights8080.com/</id>
  
  <author>
    <name>七路灯</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>凤凰架构-分布式基石</title>
    <link href="http://www.lights8080.com/p/846371ce.html"/>
    <id>http://www.lights8080.com/p/846371ce.html</id>
    <published>2021-10-25T16:00:00.000Z</published>
    <updated>2021-10-29T07:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>周志明《凤凰架构：构建可靠的大型分布式系统》<br><a href="https://icyfenix.cn/">https://icyfenix.cn/</a></p><p>包括：分布式共识、服务发现、网关、负载均衡、服务容错、限流、零信任网络安全、可观测性</p><span id="more"></span><h2 id="1-分布式共识"><a href="#1-分布式共识" class="headerlink" title="1. 分布式共识"></a>1. 分布式共识</h2><h3 id="可靠与可用、共识与一致"><a href="#可靠与可用、共识与一致" class="headerlink" title="可靠与可用、共识与一致"></a>可靠与可用、共识与一致</h3><p>状态转移（State Transfer）：以同步为代表的数据复制方法。这类方法属于比较符合人类思维的可靠性保障手段，但通常要以牺牲可用性为代价。<br>操作转移（Operation Transfer）：在分布式系统里主流的数据复制方法是，通过某种操作，把源状态转换为目标状态。</p><p>让系统各节点不受局部的网络分区、机器崩溃、执行性能或者其他因素影响，能最终表现出整体一致的过程，就是各个节点的协商共识（Consensus）。<br>共识（Consensus）与一致性（Consistency）是有区别的：一致性指的是数据不同副本之间的差异，而共识是指达成一致性的方法与过程。</p><h3 id="Paxos-算法"><a href="#Paxos-算法" class="headerlink" title="Paxos 算法"></a>Paxos 算法</h3><p>Paxos 算法：一种基于消息传递的协商共识算法，几乎就是“共识”这两字的代名词了。<br>Paxos 算法将分布式系统中的节点分为提案节点、决策节点和记录节点三类，包括“准备（Prepare）”和“批准（Accept）”两个阶段。</p><h3 id="Raft-算法"><a href="#Raft-算法" class="headerlink" title="Raft 算法"></a>Raft 算法</h3><p>Multi Paxos 对 Basic Paxos 的核心改进是，增加了“选主”的过程。<br>以上这种把共识问题分解为“Leader Election”、“Entity Replication”和“Safety”三个问题来思考、解决的解题思路，就是Raft 算法。</p><p><a href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a></p><h3 id="Gossip-协议"><a href="#Gossip-协议" class="headerlink" title="Gossip 协议"></a>Gossip 协议</h3><p>Paxos、Raft、ZAB 等分布式算法经常会被称作是“强一致性”的分布式共识协议。<br>强一致性的意思是“尽管系统内部节点可以存在不一致的状态，但从系统外部看来，不一致的情况并不会被观察到，所以整体上看系统是强一致性的”。<br>Gossip 协议，是一种很有代表性的“最终一致性”的分布式共识协议。</p><h2 id="2-服务发现"><a href="#2-服务发现" class="headerlink" title="2. 服务发现"></a>2. 服务发现</h2><p>如何确定目标方法的确切位置，便是与编译链接有着等同意义的问题，解决该问题的过程，就被叫做“服务发现”（Service Discovery）。服务发现要解决注册、维护和发现三大功能问题。</p><p>因为远程服务的多样性，导致了“服务发现”也会有两种不同的理解：<br>一种是以 UDDI 为代表的“百科全书式”的服务发现。<br>另一种是类似于 DNS 这样的“门牌号码式”的服务发现。(主流地位)</p><h3 id="服务发现需要有效权衡一致性与可用性的矛盾"><a href="#服务发现需要有效权衡一致性与可用性的矛盾" class="headerlink" title="服务发现需要有效权衡一致性与可用性的矛盾"></a>服务发现需要有效权衡一致性与可用性的矛盾</h3><p>对系统的可用性和可靠性的取舍不同，对服务发现框架的具体实现也有着决定性的影响。</p><p>第一类：在分布式 K/V 存储框架上自己实现的服务发现：<br>Etcd 采用的是我们学习过的 Raft 算法，ZooKeeper 采用的是 ZAB 算法。</p><p>第二类：以基础设施（主要是指 DNS 服务器）来实现服务发现<br>Kubernetes 1.3 之后，SkyDNS 不再是默认的 DNS 服务器：AP。</p><p>第三类：专门用于服务发现的框架和工具<br>Consul：CP，Eureka：AP，Nacos：同时支持CP和AP(二选一)。</p><h2 id="3-网关"><a href="#3-网关" class="headerlink" title="3. 网关"></a>3. 网关</h2><p>网关 = 路由器（基础职能） + 过滤器（可选职能）<br>在“路由”这个基础职能里，服务网关主要考虑的是能够支持路由的“网络层次与协议”和“性能与可用性”两方面的因素。</p><p>BFF（Backends for Frontends）：网关不必为所有的前端提供无差别的服务，而是应该针对不同的前端，聚合不同的服务，提供不同的接口和网络访问协议支持。</p><h3 id="网络层次与协议"><a href="#网络层次与协议" class="headerlink" title="网络层次与协议"></a>网络层次与协议</h3><p>负载均衡器与服务网关的区别在于，前者是为了根据均衡算法对流量进行平均地路由，后者是为了根据流量中的某种特征进行正确地路由。</p><h3 id="性能与可用性"><a href="#性能与可用性" class="headerlink" title="性能与可用性"></a>性能与可用性</h3><p>我们可以把网络 I/O 模型总结为两类、五种模型。两类是指同步 I/O 与异步 I/O；五种是指在同步 I/O 中又划分出了阻塞 I/O、非阻塞 I/O、多路复用 I/O 和信号驱动 I/O 四种细分模型。</p><p>多路复用 I/O 还可以细分 select、epoll、kqueue 等不同实现。<br>信号驱动 I/O 与异步 I/O 的区别是“从缓冲区获取数据”这个步骤的处理，</p><p>在网关的可用性方面，我们应该考虑到以下几点：网关应尽可能轻量、应该尽可能选择较成熟的产品实现、在网关之前部署负载均衡器或者等价路由器（ECMP）。</p><h2 id="4-负载均衡"><a href="#4-负载均衡" class="headerlink" title="4. 负载均衡"></a>4. 负载均衡</h2><p>分为集中式的负载均衡（Nginx）、客户端负载均衡器（Netflix Ribbon）、代理客户端负载均衡器（Service Mesh）</p><h3 id="Region"><a href="#Region" class="headerlink" title="Region"></a>Region</h3><p>Region 是地域的意思，比如华北、东北、华东、华南，这些都是地域范围。不同的地域之间是没有内网连接的。</p><h3 id="Zone"><a href="#Zone" class="headerlink" title="Zone"></a>Zone</h3><p>Zone 是区域的意思，它是可用区域（Availability Zones）的简称。区域的意思是在地理上位于同一地域内，但电力和网络是互相独立的物理区域，比如在华东的上海、杭州、苏州的不同机房，就是同一个地域的几个可用区域。同一个地域的区域之间具有内网连接，流量不占用公网带宽，因此区域是微服务集群内，流量能够触及的最大范围。</p><p>异地容灾和异地双活的差别：容灾是非实时的同步，而双活是实时或者准实时的，跨地域或者跨区域做容灾都可以，但只能一般只能跨区域做双活，当然你也可以将它们结合起来同时使用，即“两地三中心”模式。</p><h2 id="5-服务容错"><a href="#5-服务容错" class="headerlink" title="5. 服务容错"></a>5. 服务容错</h2><p>容错策略，指的是“面对故障，我们该做些什么”；而容错设计模式，指的是“要实现某种容错策略，我们该如何去做”。</p><h3 id="容错策略"><a href="#容错策略" class="headerlink" title="容错策略"></a>容错策略</h3><p>7 种常见的容错策略，包括故障转移、快速失败、安全失败、沉默失败、故障恢复、并行调用和广播调用。</p><p><img src="https://static001.geekbang.org/resource/image/da/7c/da6e01c336443bd125ff94bb4be3997c.jpg" alt="容错策略"></p><h3 id="容错设计模式"><a href="#容错设计模式" class="headerlink" title="容错设计模式"></a>容错设计模式</h3><p>微服务中常见的断路器模式、舱壁隔离模式和超时重试模式等，以及流量控制模式，比如滑动时间窗模式、漏桶模式、令牌桶模式，等等。</p><h4 id="断路器模式"><a href="#断路器模式" class="headerlink" title="断路器模式"></a>断路器模式</h4><p>断路器一般可以设置为 CLOSED、OPEN 和 HALF OPEN 三种状态。</p><p>服务熔断和服务降级之间的联系与差别：</p><ul><li>断路器做的事情是自动进行服务熔断，属于一种快速失败的容错策略的实现方法。</li><li>服务降级是上游服务必须能够主动处理调用失败的后果，也不一定是在出现错误后才被动执行的，我们在很多场景中谈论的降级更可能是指，需要主动迫使服务进入降级逻辑的情况。</li></ul><h4 id="舱壁隔离模式"><a href="#舱壁隔离模式" class="headerlink" title="舱壁隔离模式"></a>舱壁隔离模式</h4><p>服务隔离，就是避免某一个远程服务的局部失败影响到全局，而设置的一种止损方案。</p><h4 id="重试模式"><a href="#重试模式" class="headerlink" title="重试模式"></a>重试模式</h4><p>我们判断是否应该且是否能够对一个服务进行重试时，要看是否同时满足下面 4 个条件。</p><ol><li>仅在主路逻辑的关键服务上进行同步的重试</li><li>仅对由瞬时故障导致的失败进行重试</li><li>仅对具备幂等性的服务进行重试</li><li>重试必须有明确的终止条件，常用的终止条件有超时终止和次数终止两种</li></ol><h2 id="6-限流"><a href="#6-限流" class="headerlink" title="6. 限流"></a>6. 限流</h2><p>任何一个系统的运算、存储、网络资源都不是无限的，当系统资源不足以支撑外部超过预期的突发流量时，就应该要有取舍，建立面对超额流量自我保护的机制，而这个机制就是微服务中常说的“限流”。</p><h3 id="流量统计指标"><a href="#流量统计指标" class="headerlink" title="流量统计指标"></a>流量统计指标</h3><p>每秒事务数（Transactions per Second，TPS）：是衡量信息系统吞吐量的最终标准，逻辑上具备原子性的业务操作。(最希望的限流指标)<br>每秒请求数（Hits per Second，HPS）：每秒从客户端发向服务端的请求数。(首选的限流指标，相对容易观察统计)<br>每秒查询数（Queries per Second，QPS）：一台服务器能够响应的查询次数。</p><p>限流设计模式包括流量计数器、滑动时间窗、漏桶和令牌桶。</p><h2 id="7-零信任网络安全"><a href="#7-零信任网络安全" class="headerlink" title="7. 零信任网络安全"></a>7. 零信任网络安全</h2><h3 id="基于边界的安全模型"><a href="#基于边界的安全模型" class="headerlink" title="基于边界的安全模型"></a>基于边界的安全模型</h3><p>边界安全着重检查的是经过网络区域边界的流量，而对可信任区域（内网）内部机器之间的流量，会给予直接信任、或者至少是较为宽松的处理策略，这样就减小了安全设施对整个应用系统复杂度的影响，以及网络传输性能的额外损耗。如VPN、DMZ、防火墙、内网、外网，这些概念，都是基于边界的安全模型。</p><h3 id="零信任安全模型"><a href="#零信任安全模型" class="headerlink" title="零信任安全模型"></a>零信任安全模型</h3><p>零信任安全的中心思想是不应当以某种固有特征来自动信任任何流量，除非明确得到了能代表请求来源（不一定是人，更可能是另一台服务）的身份凭证，否则一律不会有默认的信任关系。</p><p><img src="https://static001.geekbang.org/resource/image/36/f9/363a4d538e4d4a3a15d87258dyy59ef9.jpg" alt="传统的基于边界的网络安全模型，与云原生时代下基于零信任网络的安全模型之间的差异"></p><h3 id="建立信任"><a href="#建立信任" class="headerlink" title="建立信任"></a>建立信任</h3><ul><li>单向 TLS 认证：只需要服务端提供证书，客户端通过服务端证书验证服务器的身份，但服务器并不验证客户端的身份。单向 TLS 用于公开的服务，即任何客户端都被允许连接到服务进行访问，它保护的重点是客户端免遭冒牌服务器的欺骗。</li><li>双向 TLS 认证：客户端、服务端双方都要提供证书，双方各自通过对方提供的证书来验证对方的身份。双向 TLS 用于私密的服务，即服务只允许特定身份的客户端访问，它除了保护客户端不连接到冒牌服务器外，也保护服务端不遭到非法用户的越权访问。</li></ul><p>认证分为两种类型，一种是以机器作为认证对象，即访问服务的流量来源是另外一个服务，这被叫做服务认证（Peer Authentication，直译过来是“节点认证”）；另一种是以人类作为认证对象，即访问服务的流量来自于最终用户，这被叫做请求认证（Request Authentication）。</p><h4 id="服务认证"><a href="#服务认证" class="headerlink" title="服务认证"></a>服务认证</h4><ul><li>Istio：无需改动任何代码，启用 mTLS 认证，且提供了宽容模式，宽容模式为普通微服务向服务网格迁移提供了良好的灵活性。</li><li>spring cloud：在应用层面去实现，使用OAuth 2.0协议进行认证。客户端在调用服务时，会先使用该密钥向认证服务器申请到 JWT 令牌，然后通过令牌证明自己的身份，最后访问服务。</li></ul><h4 id="请求认证"><a href="#请求认证" class="headerlink" title="请求认证"></a>请求认证</h4><ul><li>Istio：能够自动根据配置中的JWKS验证验证请求中附带的 JWT 是否合法，整个认证过程不需要应用程序参与。JWKS 就是一组 JWK 的集合。支持 JWKS 的系统，能通过 JWT 令牌 Header 中的 KID（Key ID）自动匹配出应该使用哪个 JWK 来验证签名。</li><li>spring cloud：Spring Security 已经做好了认证所需的绝大部分工作，真正要开发者去编写的代码就是令牌的具体实现。</li></ul><h4 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h4><p>经过认证之后，合法的调用者就有了可信任的身份，此时就不再需要区分调用者到底是机器（服务）还是人类（最终用户）了，只需要根据其身份角色来进行权限访问控制就行，即我们常说的 RBAC。分别针对来自“服务”和“用户”的流量来控制权限和访问范围。</p><ul><li>Istio：便捷性、安全性、无侵入、统一管理</li><li>spring cloud：一种是使用ExpressionUrlAuthorizationConfigurer，通过编码进行集中配置，第二种是使用@RolesAllowed、@PreAuthorize，以注解的形式分散写到每个服务甚至是每个方法中。</li></ul><h2 id="8-可观测性"><a href="#8-可观测性" class="headerlink" title="8. 可观测性"></a>8. 可观测性</h2><p>可观测性原本的含义是“可以由系统的外部输出推断其内部状态的程度”。不过实际上，计算机科学中关于可观测性的研究内容已经有了很多年的实践积累。通常，人们会把可观测性分解为三个更具体的方向进行研究，分别是：日志收集、链路追踪和聚合度量。</p><h3 id="日志（Logging）"><a href="#日志（Logging）" class="headerlink" title="日志（Logging）"></a>日志（Logging）</h3><p>日志主要是用来记录系统运行期间发生过的离散事件。</p><p>在日志领域，日志收集和分析大多被统一到了 Elastic Stack（ELK）技术栈上。</p><p>ELK 在一定程度上也可以代替度量和追踪系统，实现它们的部分职能，对于大型系统，建议还是让专业的工具去做专业的事情。</p><h4 id="日志的记录"><a href="#日志的记录" class="headerlink" title="日志的记录"></a>日志的记录</h4><p>好的日志要能够毫无遗漏地记录信息、格式统一、内容恰当，而“恰当”的真正含义是指日志中不该出现的内容不要有，而该有的不要少。</p><ul><li>“不应该有”的日志内容：避免打印敏感信息、避免引用慢操作、避免打印追踪诊断信息、避免误导他人。</li><li>“不应该少”的日志内容：处理请求时的 TraceID、系统运行过程中的关键事件、启动时输出配置信息</li></ul><h4 id="分布式系统处理日志"><a href="#分布式系统处理日志" class="headerlink" title="分布式系统处理日志"></a>分布式系统处理日志</h4><p>分布式系统处理一个请求要跨越多个服务节点，因此当每个节点输出日志到文件后，就必须要把日志文件统一收集起来，集中存储、索引，而这正是日志收集器需要做的工作。此外，日志收集器还要尽力保证日志数据的连续性。</p><h4 id="日志的查询、统计、聚合等操作"><a href="#日志的查询、统计、聚合等操作" class="headerlink" title="日志的查询、统计、聚合等操作"></a>日志的查询、统计、聚合等操作</h4><p>由于日志是非结构化数据，因此我们需要进行加工，把日志行中的非结构化数据转换为结构化数据，以便针对不同的数据项来建立索引，进行条件查询、统计、聚合等操作。</p><ul><li>一种解决方案是通过 Elasticsearch 本身的处理能力做实时的聚合统计，应对于即席查询。</li><li>另一种解决方案是在收集日志后自动生成某些常用的、固定的聚合指标，这种聚合就会在 Logstash 中通过聚合插件来完成，更多是用于应对固定查询。</li></ul><h3 id="追踪（Tracing）"><a href="#追踪（Tracing）" class="headerlink" title="追踪（Tracing）"></a>追踪（Tracing）</h3><p>从广义上讲，一个完整的分布式追踪系统，应该由数据收集、数据存储和数据展示三个相对独立的子系统构成；而从狭义上讲，则就只是特指链路追踪数据的收集部分。比如Spring Cloud Sleuth就属于狭义的追踪系统，通常会搭配 Zipkin 作为数据展示，搭配 Elasticsearch 作为数据存储来组合使用。</p><p>所有业界有名的追踪系统，无论是国外 Twitter 的Zipkin、Naver 的Pinpoint，还是国内阿里的鹰眼、大众点评的CAT、个人开源的SkyWalking（后来进入 Apache 基金会孵化毕业），都受到了 Dapper 论文（Google 在 2010 年发表）的直接影响。</p><p>Dapper 提出了“追踪”（Trace）与“跨度”（Span）两个概念，每一次 Trace 都是由若干个有顺序、有层级关系的 Span 所组成一颗“追踪树”（Trace Tree）</p><p>数据收集的三种主流实现方式：基于日志的追踪、基于服务的追踪、基于边车代理的追踪。</p><h4 id="基于日志的追踪"><a href="#基于日志的追踪" class="headerlink" title="基于日志的追踪"></a>基于日志的追踪</h4><p>日志追踪对网络消息完全没有侵入性，对应用程序只有很少量的侵入性，对性能的影响也非常低。<br>缺点是直接依赖于日志归集过程，由于日志归集不及时或者精度丢失，导致日志出现延迟或缺失记录，进而产生追踪失真的情况。<br>日志追踪的代表产品是 Spring Cloud Sleuth。</p><h4 id="基于服务的追踪"><a href="#基于服务的追踪" class="headerlink" title="基于服务的追踪"></a>基于服务的追踪</h4><p>是目前最为常见的追踪实现方式，实现思路是通过某些手段给目标应用注入追踪探针。<br>基于服务的追踪会比基于日志的追踪消耗更多的资源，也具有更强的侵入性，而换来的收益就是追踪的精确性与稳定性都有所保证，不必再依靠日志归集来传输追踪数据。<br>Zipkin、SkyWalking、Pinpoint 等主流追踪系统广泛采用。</p><h4 id="基于边车代理的追踪"><a href="#基于边车代理的追踪" class="headerlink" title="基于边车代理的追踪"></a>基于边车代理的追踪</h4><p>基于边车代理的追踪是服务网格的专属方案，也是最理想的分布式追踪模型，它对应用完全透明，无论是日志还是服务本身，都不会有任何变化<br>市场占有率最高的边车代理Envoy就提供了相对完善的追踪功能。</p><h4 id="追踪规范化"><a href="#追踪规范化" class="headerlink" title="追踪规范化"></a>追踪规范化</h4><p>当初 Google 发表的 Dapper 只是论文，而不是有约束力的规范标准，它只提供了思路，并没有规定细节。<br>为了推进追踪领域的产品标准化，2016 年 11 月，CNCF 技术委员会接受了 OpenTracing 作为基金会的第三个项目。<br>Google 在这个时候出来表示反对，并提出了与 OpenTracing 目标类似的 OpenCensus 规范，随后又得到了巨头 Microsoft 的支持和参与。<br>2019 年，OpenTracing 和 OpenCensus 又忽然宣布握手言和，它们共同发布了可观测性的终极解决方案OpenTelemetry，并宣布会各自冻结 OpenTracing 和 OpenCensus 的发展。</p><h3 id="度量（Metrics）"><a href="#度量（Metrics）" class="headerlink" title="度量（Metrics）"></a>度量（Metrics）</h3><p>度量的主要目的是监控（Monitoring）和预警（Alert），是揭示系统的总体运行状态。</p><p>度量就是用经过聚合统计后的高维度信息，以最简单直观的形式来总结复杂的过程，为监控、预警提供决策支持。</p><p>如何定义指标？<br>数据类型（Metrics Types）：</p><ul><li>计数度量器（Counter）：对有相同量纲、可加减数值的合计量</li><li>瞬态度量器（Gauge）：表示某个指标在某个时点的数值</li><li>吞吐率度量器（Meter）：用于统计单位时间的吞吐量，即单位时间内某个事件的发生次数</li><li>直方图度量器（Histogram）：二维统计图，它的两个坐标分别是统计样本和该样本对应的某个属性的度量，以长条图的形式记录具体数值</li><li>采样点分位图度量器（Quantile Summary）：通过比较各分位数的分布情况的工具，主要用来验证实际值与理论值的差距，评估理论值与实际值之间的拟合度</li></ul><p>如何将这些指标告诉服务端？<br>通常有两种解决方案：拉取式采集（Pull-Based Metrics Collection）和推送式采集（Push-Based Metrics Collection）</p><h4 id="监控预警"><a href="#监控预警" class="headerlink" title="监控预警"></a>监控预警</h4><p>广义上的度量系统由面向目标系统进行指标采集的客户端，负责调度、存储和提供查询能力的服务端，以及面向最终用户的终端组成。<br>狭义上的度量系统就只包括客户端和服务端，不包含终端。</p><p>大多是 Prometheus 配合 Grafana 来进行展示的，这是 Prometheus 官方推荐的组合方案。</p><p>良好的可视化能力对于提升度量系统的产品力也非常重要，长期趋势分析、对照分析、故障分析等分析工作，既需要度量指标的持续收集、统计，往往还需要对数据进行可视化，这样才能让人更容易地从数据中挖掘规律，毕竟数据最终还是要为人类服务的。</p><p>传统监控和可观测性之间的关键区别在于：可观测性是系统或服务内在的固有属性，而不是在系统之外对系统所做出的额外增强，后者是传统监控的处理思路。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;周志明《凤凰架构：构建可靠的大型分布式系统》&lt;br&gt;&lt;a href=&quot;https://icyfenix.cn/&quot;&gt;https://icyfenix.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;包括：分布式共识、服务发现、网关、负载均衡、服务容错、限流、零信任网络安全、可观测性&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="技术" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="凤凰架构" scheme="http://www.lights8080.com/tags/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>凤凰架构-架构安全性</title>
    <link href="http://www.lights8080.com/p/ac30aed0.html"/>
    <id>http://www.lights8080.com/p/ac30aed0.html</id>
    <published>2021-10-20T16:00:00.000Z</published>
    <updated>2021-10-25T09:34:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>周志明《凤凰架构：构建可靠的大型分布式系统》<br><a href="https://icyfenix.cn/">https://icyfenix.cn/</a></p><p>包括：认证、授权、凭证、保密、传输、验证</p><span id="more"></span><p>系统安全，不仅包括“防御系统被黑客攻击”这样狭隘的安全，还包括一些与管理、运维、审计等领域主导的相关安全性问题，比如说安全备份与恢复、安全审计、防治病毒，等等。</p><p>软件架构安全，主要包括（但不限于）以下这些问题的具体解决方案：认证、授权、凭证、保密、传输、验证。</p><p>这些问题基本上也都是与具体系统、具体业务无关的通用性问题，这就意味着它们往往会存在一些业界通行的、已经被验证过是行之有效的解决方案，乃至已经形成了行业标准，不需要我们再从头去构思如何解决。</p><h2 id="认证（Authentication）"><a href="#认证（Authentication）" class="headerlink" title="认证（Authentication）"></a>认证（Authentication）</h2><blockquote><p>系统如何正确分辨出操作用户的真实身份？</p></blockquote><p>认证（Authentication）、授权（Authorization）和凭证（Credentials）这三项可以说是一个系统中最基础的安全设计了。<br>信息系统在为用户提供服务之前，总是希望先弄清楚“你是谁？”（认证）、“你能干什么？”（授权）以及“你如何证明？”（凭证）这三个基本问题的答案。</p><p>架构安全性的经验原则：以标准规范为指导、以标准接口去实现，严格遵循标准就是最恰当的安全设计。</p><h4 id="基于通讯协议：HTTP-认证"><a href="#基于通讯协议：HTTP-认证" class="headerlink" title="基于通讯协议：HTTP 认证"></a>基于通讯协议：HTTP 认证</h4><p>IETF 在RFC 7235中定义了 HTTP 协议的通用认证框架，要求所有支持 HTTP 协议的服务器，当未授权的用户意图访问服务端保护区域的资源时，应返回 401 Unauthorized 的状态码，同时要在响应报文头里，附带以下两个分别代表网页认证和代理认证的 Header 之一，告知客户端应该采取哪种方式，产生能代表访问者身份的凭证信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WWW-Authenticate: &lt;认证方案&gt; realm=&lt;保护区域的描述信息&gt;</span><br><span class="line">Proxy-Authenticate: &lt;认证方案&gt; realm=&lt;保护区域的描述信息&gt;</span><br></pre></td></tr></table></figure><p>客户端必须遵循服务端指定的认证方案，在请求资源的报文头中加入身份凭证信息，服务端核实通过后才会允许该请求正常返回，否则将返回 403 Forbidden。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Authorization: &lt;认证方案&gt; &lt;凭证内容&gt;</span><br><span class="line">Proxy-Authorization: &lt;认证方案&gt; &lt;凭证内容&gt;</span><br></pre></td></tr></table></figure><p><em>HTTP 认证框架提出的认证方案，是希望能把认证“要产生身份凭证”的目的，与“具体如何产生凭证”的实现给分开来。</em></p><p>认证方案：</p><ul><li>Basic：是一种以演示为目的的认证方案，Basic 认证产生用户身份凭证的方法是让用户输入用户名和密码，经过 Base64 编码“加密”后作为身份凭证。</li><li>Digest：HTTP 摘要认证，可以把它看作是 Basic 认证的改良版本，针对 Base64 明文发送的风险，Digest 认证把用户名和密码加盐后，再通过 MD5/SHA 等哈希算法取摘要发送出去。</li><li>Bearer：基于 OAuth 2.0 规范来完成认证，OAuth 2.0 是一个同时涉及到认证与授权的协议。</li><li>HOBA：一种基于自签名证书的认证方案。</li><li>其他：很多厂商也扩展了自己的认证方案，如AWS4-HMAC-SHA256、Twitter Basic等。</li></ul><h4 id="基于通讯内容：Web-认证"><a href="#基于通讯内容：Web-认证" class="headerlink" title="基于通讯内容：Web 认证"></a>基于通讯内容：Web 认证</h4><p>但目前的信息系统，直接采用 HTTP 认证框架的比例其实是非常低的。以 HTTP 协议为基础的认证框架，也只能面向传输协议而不是具体传输内容来设计。</p><p>如果用户访问信息系统中的具体服务，身份认证肯定希望是由系统本身的功能去完成的，而不是由 HTTP 服务器来负责认证。</p><p>这种依靠内容而不是传输协议来实现的认证方式，被称为“Web 认证”，由于在实现形式上，登录表单占了绝对的主流，因此它通常也被称为“表单认证”。</p><p><em>表单认证与 HTTP 认证不见得是完全对立的，它们分别有不同的关注点，可以结合使用。</em></p><h4 id="WebAuthn"><a href="#WebAuthn" class="headerlink" title="WebAuthn"></a>WebAuthn</h4><p>万维网联盟批准了由FIDO（Fast IDentity Online，一个安全、开放、防钓鱼、无密码认证标准的联盟）领导起草的世界首份 Web 内容认证的标准“WebAuthn”。</p><p>Web 表单长什么样，没有什么行业标准可循，允许做的五花八门，用户名密码、扫码、图形验证码等，都可以自行决定认证的全套交互细节。这些登录表单提交之前进行必要的表单校验，确实不太可能定义在规范上。<br>所以，WebAuthn 彻底抛弃了传统的密码登录方式，改为直接采用生物识别（指纹、人脸、虹膜、声纹）或者实体密钥（以 USB、蓝牙、NFC 连接的物理密钥容器）来作为身份凭证。</p><h2 id="授权（-Authorization）"><a href="#授权（-Authorization）" class="headerlink" title="授权（ Authorization）"></a>授权（ Authorization）</h2><blockquote><p>系统如何控制一个用户该看到哪些数据、能操作哪些功能？</p></blockquote><p>授权涉及到两个相对独立的问题<br>1）确保授权的过程可靠，主要有OAuth 2.0 和 SAML 2.0<br>2）确保授权的结果可控，对资源的访问控制模型，主要有RBAC、ABAC</p><h3 id="OAuth-2-0"><a href="#OAuth-2-0" class="headerlink" title="OAuth 2.0"></a>OAuth 2.0</h3><p>OAuth 2.0 解决的是第三方服务中涉及的安全授权问题，是面向于解决第三方应用（Third-Party Application）的认证授权协议。</p><p>可参考阮一峰老师讲解：<a href="https://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html">https://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html</a></p><p>OAuth 2.0 提出了四种不同的授权方式，包括授权码模式、简化模式、密码模式、客户端模式。</p><h4 id="授权码模式（Authorization-Code）"><a href="#授权码模式（Authorization-Code）" class="headerlink" title="授权码模式（Authorization Code）"></a>授权码模式（Authorization Code）</h4><p>授权码模式是四种模式中最严谨的，第三方应用必须有应用服务器，要求服务器地址必须与注册时提供的地址一致。<br>先发放授权码，然后第三方服务器使用授权码获取令牌，避免令牌在传输转向过程中被泄漏的风险。 </p><p><img src="https://gitee.com/lights8080/lights8080-oss/raw/master/2021/10/NCzNMZ.png" alt="授权码模式，简易流程图"></p><h4 id="简化模式（Implicit）"><a href="#简化模式（Implicit）" class="headerlink" title="简化模式（Implicit）"></a>简化模式（Implicit）</h4><p>隐式授权省略掉了通过授权码换取令牌的步骤，整个授权过程都不需要服务端的支持。授权服务器不会再去验证第三方应用的身份，因为已经没有应用服务器了。</p><p>特别强调了令牌必须是“通过 Fragment 带回”的，Fragment 是不会跟随请求被发送到服务端的，只能在客户端通过 Script 脚本来读取。<br>尽最大努力地避免了令牌从操作代理到第三方服务之间的链路，存在被攻击而泄露出去的可能性。</p><h4 id="密码模式（Resource-Owner-Password-Credentials）"><a href="#密码模式（Resource-Owner-Password-Credentials）" class="headerlink" title="密码模式（Resource Owner Password Credentials）"></a>密码模式（Resource Owner Password Credentials）</h4><p>密码模式里，认证和授权就被整合成了同一个过程。仅限于在用户对第三方应用是高度可信任的场景中使用，因为用户需要把密码明文提供给第三方应用，第三方以此向授权服务器获取令牌。</p><h4 id="客户端模式（Client-Credentials）"><a href="#客户端模式（Client-Credentials）" class="headerlink" title="客户端模式（Client Credentials）"></a>客户端模式（Client Credentials）</h4><p>在微服务架构中，其实并不提倡同一个系统的各服务间有默认的信任关系，所以服务之间的调用也需要先进行认证授权，然后才能通讯。客户端模式便是一种常用的服务间认证授权的解决方案。</p><h3 id="RBAC（基于角色的访问控制，Role-Based-Access-Control）。"><a href="#RBAC（基于角色的访问控制，Role-Based-Access-Control）。" class="headerlink" title="RBAC（基于角色的访问控制，Role-Based Access Control）。"></a>RBAC（基于角色的访问控制，Role-Based Access Control）。</h3><p>所有的访问控制模型，实质上都是在解决同一个问题：谁（User）拥有什么权限（Authority）去操作（Operation）哪些资源（Resource）。</p><p>为避免对每一个用户设定权限，RBAC 提出了角色和许可等概念，角色为的是解耦用户与权限之间的多对多关系，而许可为的是解耦操作与资源之间的多对多关系。<br>RBAC-1 模型的角色权限继承关系，RBAC-2 模型的角色职责分离关系。</p><p>建立访问控制模型的基本目的就是为了管理垂直权限和水平权限。垂直权限即功能权限，水平权限则是数据权限，它很难抽象与通用。</p><h2 id="凭证（Credentials）"><a href="#凭证（Credentials）" class="headerlink" title="凭证（Credentials）"></a>凭证（Credentials）</h2><blockquote><p>系统如何保证它与用户之间的承诺是双方当时真实意图的体现，是准确、完整且不可抵赖的？</p></blockquote><h3 id="Cookie-Session"><a href="#Cookie-Session" class="headerlink" title="Cookie-Session"></a>Cookie-Session</h3><p>Set-Cookie 指令：这个指令的含义是以键值对的方式向客户端发送一组信息，在此后一段时间内的每次 HTTP 请求中，这组信息会附带着名为 Cookie 的 Header 重新发回给服务端，以便服务器区分来自不同客户端的请求。</p><p>Cookie-Session 也就是最传统的，但在今天依然广泛应用于大量系统中的、由服务端与客户端联动来完成的状态管理机制。</p><p>Cookie-Session 的优点是，实现足够简单，服务端有主动的状态管理的能力，适用于单节点的单体服务环境中。缺点是，服务器水平扩展成多节点时，状态管理收到存在CAP的局限。</p><h3 id="JWT（JSON-Web-Token）"><a href="#JWT（JSON-Web-Token）" class="headerlink" title="JWT（JSON Web Token）"></a>JWT（JSON Web Token）</h3><p>解决认证授权问题的无状态方案。是目前广泛使用的一种令牌格式，尤其经常与 OAuth 2.0 配合应用于分布式的、涉及多方的应用系统中。</p><p>JWT 默认的签名算法 HMAC SHA256 是一种带密钥的哈希摘要算法，加密与验证过程都只能由中心化的授权服务来提供，所以这种方式一般只适合于授权服务与应用服务处于同一个进程中的单体应用。<br>在多方系统，或者是授权服务与资源服务分离的分布式应用当中，通常会采用非对称加密算法来进行签名。这时候，除了授权服务端持有的可以用于签名的私钥以外，还会对其他服务器公开一个公钥。<br>不过，这个公钥不能用来签名，但它能被其他服务用于验证签名是否由私钥所签发的。这样，其他服务器就也能不依赖授权服务器、无需远程通讯，即可独立判断 JWT 令牌中的信息的真伪了。</p><p>JWT 只解决防篡改的问题，并不解决防泄露的问题，所以令牌默认是不加密的，需要时自行实现。JWT 缺点有：令牌难以主动失效，相对更容易遭受重放攻击，只能携带相当有限的数据，必须考虑令牌在客户端如何存储。</p><h2 id="保密（Confidentiality）"><a href="#保密（Confidentiality）" class="headerlink" title="保密（Confidentiality）"></a>保密（Confidentiality）</h2><blockquote><p>系统如何保证敏感数据无法被包括系统管理员在内的内外部人员所窃取、滥用？</p></blockquote><p>根据需要保密信息所处的不同环节，将其划分为“信息在客户端时的保密”，“信息在传输时的保密”和“信息在服务端时的保密”。</p><p>保密的强度：(逐步升级的保密措施，更高的安全强度同时也意味着要付出更多的代价)</p><ol><li>以摘要代替明文：不能防止弱密码被彩虹表攻击</li><li>先加盐值再做哈希是应对弱密码的常用方法：不能阻止加密结果被监听</li><li>将盐值变为动态值能有效防止冒认：协商出盐值的过程将变得极为复杂，每次协商只能保护一次操作</li><li>加入动态令牌防止重放攻击：流量公共位置建立校验逻辑，服务器要付出分发令牌信息代价</li><li>启用 HTTPS 来应对因嗅探而导致的信息泄露问题：客户端或服务端被攻破风险</li><li>进一步提升保密强度的不同手段：独立于客户端存储的物理设备-U盾、独立于网络的信息通道-手机验证码、与公网物理隔离的专用内部网络</li></ol><h3 id="信息在客户端时的保密"><a href="#信息在客户端时的保密" class="headerlink" title="信息在客户端时的保密"></a>信息在客户端时的保密</h3><p>为了保证信息不被黑客窃取而去做客户端加密，其实没有太大意义，对绝大多数的信息系统来说，启用 HTTPS 可以说是唯一的实际可行的方案。</p><p>但是！为了保证密码不在服务端被滥用（密码明文被写入数据库、被输出到日志中），而在客户端就开始加密的做法，还是很有意义的。</p><p>客户端无论是否动态加盐，都不可能代替 HTTPS。真正防御性的密码加密存储应该在服务端中进行，但这是为了防御服务端被攻破而批量泄露密码的风险，并不是为了增强传输过程的安全性。</p><p>客户端并不提倡在盐值上做动态化，更理想的方式是引入慢哈希函数来解决，增加破解密码的难度。<br>如果我们控制BCrypt的执行时间大概是 0.1 秒完成一次哈希计算的话，要算完所有的 10 位大小写字母和数字组成的弱密码，就大概需要 P(26<em>2+10,10)/(3600</em>24*365)/0.1=1,237,204,169 年的时间。</p><h3 id="信息在客户端时的保密-1"><a href="#信息在客户端时的保密-1" class="headerlink" title="信息在客户端时的保密"></a>信息在客户端时的保密</h3><p>“普通安全强度”的意思是，在具有一定保密安全性的同时，避免消耗过多的运算资源，这样验证起来也相对便捷。毕竟对多数信息系统来说，只要配合一定的密码规则约束，比如密码要求长度、特殊字符等等，再配合 HTTPS 传输，就已经足够防御大多数风险了。即使是用户采用了弱密码、客户端通讯被监听、服务端被拖库、泄露了存储的密文和盐值等问题同时发生，也能够最大限度地避免用户明文密码被逆推出来。</p><p>防御服务端被拖库后，针对固定盐值的批量彩虹表攻击。具体做法是为每一个密码（指客户端传来的哈希值）产生一个随机的盐值。（建议使用CSPRNG来生成一个长度与哈希值相等的随机字符串）</p><p>把动态盐值混入客户端传来的哈希值，再做一次哈希，产生出最终的密文。<br>把“最终的密文”和“随机的盐值”一起写入到数据库记录中。<br>服务端验证过程，取出登录用户对应的密文和盐值，采用相同的哈希算法，针对客户端传来的哈希值、服务端存储的盐值计算摘要结果，比较结果和数据库储存的“最终的密文”是否相同。</p><h2 id="传输（Transport-Security）"><a href="#传输（Transport-Security）" class="headerlink" title="传输（Transport Security）"></a>传输（Transport Security）</h2><blockquote><p>系统如何保证通过网络传输的信息无法被第三方窃听、篡改和冒充？</p></blockquote><p>摘要与加密和签名的本质区别：<br><img src="https://gitee.com/lights8080/lights8080-oss/raw/master/2021/10/87Lb7x.jpg" alt="摘要、对称机密、非对称加密的区别"></p><p>非对称加密算法：<br>公钥加密，私钥解密，这种就是加密：向私钥所有者发送信息，这个信息可能被他人篡改，但是无法被他人得知。<br>私钥加密，公钥解密，这种就是签名：防止私钥所有者发布的内容被篡改，不用来保证内容不被他人获得。</p><p>What is a Digital Signature?<br><a href="http://www.youdzone.com/signature.html">http://www.youdzone.com/signature.html</a></p><h2 id="验证（Verification）"><a href="#验证（Verification）" class="headerlink" title="验证（Verification）"></a>验证（Verification）</h2><blockquote><p>系统如何确保提交到每项服务中的数据是合乎规则的，不会对系统稳定性、数据一致性、正确性产生风险？</p></blockquote><p>Java Bean Validation。是比较提倡的做法，那就是把校验行为从分层中剥离出来，不是在哪一层做，而是在 Bean 上做。</p><p>采用 Bean Validation 也便于我们统一处理校验结果不满足时的提示信息。比如提供默认值、提供国际化支持（这里没做）、提供统一的客户端返回格式（创建一个用于 ConstraintViolationException 的异常处理器来实现），以及批量执行全部校验。</p><p>对于 Bean 与 Bean 校验器，两条关于编码的建议：<br>第一条建议是，要对校验项预置好默认的提示信息，这样当校验不通过时，用户能获得明确的修正提示。<br>第二条建议是，要把不带业务含义的格式校验注解放到 Bean 的类定义之上，把带业务逻辑的校验放到 Bean 的类定义的外面。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;周志明《凤凰架构：构建可靠的大型分布式系统》&lt;br&gt;&lt;a href=&quot;https://icyfenix.cn/&quot;&gt;https://icyfenix.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;包括：认证、授权、凭证、保密、传输、验证&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="技术" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="凤凰架构" scheme="http://www.lights8080.com/tags/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>2109-4-不要为了运动而运动</title>
    <link href="http://www.lights8080.com/p/57bfb88c.html"/>
    <id>http://www.lights8080.com/p/57bfb88c.html</id>
    <published>2021-09-23T16:00:00.000Z</published>
    <updated>2021-09-24T08:04:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>如题</p><span id="more"></span><h2 id="话题：不要为了运动而运动"><a href="#话题：不要为了运动而运动" class="headerlink" title="话题：不要为了运动而运动"></a>话题：不要为了运动而运动</h2><p>现在这个天气比较舒适，中午经常有一伙儿人在楼下打羽毛球，我有时间都会在楼下趴会儿。<br>我有个同事想法就不一样，他觉得运动就是跑跑跳跳，多累啊，出一身汗，还要换衣服在上班，还不如上去睡会儿觉。<br>我不能说他说的有毛病，运动确实很累人，出一身汗，很麻烦。</p><p>我现在每周坚持游泳，游完确实很累，不想动，心想累死我了，再也不去了。练了这么久自由泳还总是呛水，太难受了。<br>但转天总有一股劲儿逼迫着你去坚持，虽然身体很酸爽，但心里总痒痒。</p><p>“””<br>啊呀快累死了<br>没时间啊<br>忘记了<br>之前没有弄过啊不会<br>“””<br>据我有限的观察，一些善于找借口的人从不热爱运动，反过来说就是热爱运动的人遇到问题，更愿意思考，承担责任，去提高自己。<br>当然我没有查任何的理论依据，随意反驳。<br>你可以说找借口是一种自我保护的方法，不背锅。我认同，但我真觉得这对个人成长来说没有任何好处。</p><p>村上春树说：今天不想跑，所以才去跑。</p><p>刘翔从小训练都是8步上栏，但为了加强前面三栏的速度，改为7步上栏，这比重新开始学跨栏还要难，为了追求快那0.01秒的速度。<br>之前看过一个2020年的残奥会比赛剪辑，当你想要放弃的时候看一看，看看他们面对困难，面对竞争，是如何做的。</p><p>不运动的理由有千万种，但运动的理由就一个坚持，永不放弃，突破自我的精神。<br>运动的魅力，就是通过每天提高一点点，追求最好的自己的过程。</p><p>运动的目的是追求最好的自己，不要为了运动而运动，你坚持不下来。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如题&lt;/p&gt;</summary>
    
    
    
    <category term="weekly" scheme="http://www.lights8080.com/categories/weekly/"/>
    
    
    <category term="weekly" scheme="http://www.lights8080.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>大数据框架汇总</title>
    <link href="http://www.lights8080.com/p/f2ce654.html"/>
    <id>http://www.lights8080.com/p/f2ce654.html</id>
    <published>2021-09-17T16:00:00.000Z</published>
    <updated>2021-09-18T11:09:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>大数据平台相关框架汇总。<br>包括：Hadoop、Hbase、Pig、Hive、Spark、Strom、Flink、Presto、Atlas、SuperSet、Cassandra、ClickHouse等</p><span id="more"></span><h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h2><p>Hadoop是一个开源框架，允许使用简单的编程模型在跨计算机集群的分布式环境中存储和处理大数据。</p><p>Hadoop框架包括以下四个模块：</p><ul><li>Hadoop Common： 这些是其他Hadoop模块所需的Java库和实用程序。这些库提供文件系统和操作系统级抽象，并包含启动Hadoop所需的必要Java文件和脚本。</li><li>Hadoop YARN： 这是作业调度和群集资源管理的框架。</li><li>Hadoop分布式文件系统（HDFS）： 一种分布式文件系统，可提供对应用程序数据的高吞吐量访问。</li><li>Hadoop MapReduce： 这是用于并行处理大型数据集的基于YARN的系统。</li></ul><h2 id="Hbase"><a href="#Hbase" class="headerlink" title="Hbase"></a>Hbase</h2><p>HBase是一个数据模型，基于 Apache Hadoop 和 BigTable 概念的宽列存储，旨在提供对大量结构化数据的快速随机访问。<br>HBase是一个面向列的建立在HDFS之上的非关系型数据库，利用了Hadoop文件系统（HDFS）提供的容错功能。<br>面向列的数据库是为巨大的表而设计的，对半结构化和结构化数据很有用，适用于在线分析处理（OLAP）。</p><h2 id="Flume"><a href="#Flume" class="headerlink" title="Flume"></a>Flume</h2><p>Apache Flume是一种分布式，高可靠和高可用的服务，可以有效采集、聚合和传输大量的日志数据。</p><p>Flume具有可调的可靠性机制和许多故障转移和恢复机制，主要用于将各种源的流数据传输到HDFS。</p><h2 id="Pig"><a href="#Pig" class="headerlink" title="Pig"></a>Pig</h2><p>由Yahoo开发，Apache Pig是对MapReduce的一种抽象。可以处理结构化，非结构化和半结构化的数据，分析结构化和半结构化的数据，并将结果存储在HDFS中。</p><p>Pig提供了一种称为 Pig Latin 的高级语言，不需要编译，执行时，每个操作符都在内部转换为MapReduce作业。</p><p>它提供了许多操作符来执行连接、排序、文件管理等操作，还提供了其他编程语言的自定义函数（UDF）功能，嵌入到Pig脚本中。</p><h2 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h2><p>由Facebook开发，Hive是一个数据仓库基础设施工具，用于处理Hadoop中的结构化数据。它位于Hadoop的顶部，用于汇总大数据，并使查询和分析变得轻松。</p><p>Hive提供用于查询的SQL类型语言，称为HiveQL或HQL，内部将HQL查询转换为执行MapReduce操作。</p><h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><p>Apache Spark是一款快速集群计算，专为快速计算而设计。它建立在Hadoop MapReduce之上，它扩展了MapReduce模型以有效地使用更多类型的计算，其中包括交互式查询和流处理。</p><p>Spark的主要特点是其内存集群计算 ，通过减少对磁盘的读/写操作，将中间处理数据存储在内存中，提高应用程序的处理速度。</p><p>包括以下四个组件：</p><ul><li>Apache Spark Core：Spark平台的基础通用执行引擎，其所有其他功能都是基于该平台执行的</li><li>Spark SQL：提供了对结构化和半结构化数据的支持</li><li>Spark Streaming：利用Spark Core的快速调度功能来执行流式分析</li><li>MLlib：分布式机器学习框架</li><li>GraphX：分布式图形处理框架</li></ul><p>弹性分布式数据集（RDD）是Spark的基础数据结构，它是一个不可变的分布式对象集合。<br>Spark利用RDD的概念来实现更快更高效的MapReduce操作。</p><p>Apache Spark是用 Scala编程语言 编写的。为了用Spark支持Python，Apache Spark社区发布了一个工具PySpark。</p><h2 id="Storm"><a href="#Storm" class="headerlink" title="Storm"></a>Storm</h2><p>Apache Storm是一个分布式实时大数据处理系统。Storm设计用于以容错和水平可伸缩方法处理大量数据。虽然Storm是无状态的，但它通过Apache ZooKeeper管理分布式环境和集群状态。</p><p>Hadoop和Storm框架用于分析大数据，Storm执行除持久性以外的所有操作，而Hadoop擅长于一切，但缺乏实时计算。</p><h2 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h2><p>Apache Flink是一个同时面向数据流处理和批量数据处理的开源框架和分布式处理引擎，具有高吞吐、低延迟、高扩展、支持容错等特性，用于对无界和有界数据流进行有状态计算。</p><p>可以运行在包括 YARN、 Mesos、Kubernetes 在内的多种资源管理框架上。</p><h3 id="Flink-常见的几类应用"><a href="#Flink-常见的几类应用" class="headerlink" title="Flink 常见的几类应用"></a>Flink 常见的几类应用</h3><p>事件驱动型应用、数据分析应用、数据管道应用</p><h4 id="事件驱动型应用"><a href="#事件驱动型应用" class="headerlink" title="事件驱动型应用"></a>事件驱动型应用</h4><p>事件驱动型应用是一类具有状态的应用，它从一个或多个事件流提取数据，并根据到来的事件触发计算、状态更新或其他外部动作。</p><p>事件驱动型应用是在计算存储分离的传统应用基础上进化而来。在传统架构中，应用需要读写远程事务型数据库。</p><p>典型的事件驱动型应用实例：反欺诈、异常检测、基于规则的报警、业务流程监控</p><h4 id="数据分析应用"><a href="#数据分析应用" class="headerlink" title="数据分析应用"></a>数据分析应用</h4><p>数据分析任务需要从原始数据中提取有价值的信息和指标。传统的分析方式通常是利用批查询，或将事件记录下来并基于此有限数据集构建应用来完成。</p><p>Flink 为持续流式分析和批量分析都提供了良好的支持。内置了SQL接口，将批、流查询的语义统一起来。</p><h4 id="数据管道应用"><a href="#数据管道应用" class="headerlink" title="数据管道应用"></a>数据管道应用</h4><p>提取-转换-加载（ETL）是一种在存储系统之间进行数据转换和迁移的常用方法。ETL 作业通常会周期性地触发，将数据从事务型数据库拷贝到分析型数据库或数据仓库。</p><p>Flink 为多种数据存储系统（如：Kafka、Kinesis、Elasticsearch、JDBC数据库系统等）内置了连接器</p><h2 id="mapReduce、pig-hive、spark-storm、flink"><a href="#mapReduce、pig-hive、spark-storm、flink" class="headerlink" title="mapReduce、pig/hive、spark/storm、flink"></a>mapReduce、pig/hive、spark/storm、flink</h2><p>第一代计算引擎 mapReduce：<br>用于批处理，是计算引擎的先驱，开发效率低，开发时间成本太大</p><p>第二代计算引擎 pig/hive：<br>对hadoop进行了嵌套，其存储基于hdfs，计算基于mr，降低了mr的编写编写成本<br>pig有自己的脚本语言，可以处理非结构化、半结构化和结构化数据，比hive更加的灵活<br>hive属于类sql语法，仅支持处理结构化数据</p><p>第三代计算引擎 spark/storm：<br>解决实时处理的需求，低延迟高吞吐量。</p><p>第四代计算引擎 flink：<br>为流式计算而生属于每一条数据触发计算，在性能的消耗低于storm，吞吐量高于storm，延时低于storm，并且比storm更加易于编写</p><h2 id="Sqoop"><a href="#Sqoop" class="headerlink" title="Sqoop"></a>Sqoop</h2><p>它用于在HDFS和RDBMS之间导入和导出数据。</p><h2 id="Presto"><a href="#Presto" class="headerlink" title="Presto"></a>Presto</h2><p>Presto是Facebook开源的分布式SQL查询引擎，规模可以支持GB到PB级，主要应用于处理秒级的查询场景。内存中计算。优点是快，跨数据源查询</p><p>Hive针对查询吞吐量进行了优化，而Presto针对延迟进行了优化。<br>Presto受最大内存限制，如果超过最大内存，查询就会失败。<br>对于交互式查询可以接受，对于必须可靠运行的日报/周报，他是不合适的，Hive会更好。</p><h2 id="Atlas"><a href="#Atlas" class="headerlink" title="Atlas"></a>Atlas</h2><p>Apache Atlas提供了开放元数据管理和治理能力，以建立其数据资产目录，对这些资产进行分类和治理。</p><p>开箱即用的元数据源集成：HBase、Hive、Sqoop、Storm、Kafka</p><h2 id="SuperSet"><a href="#SuperSet" class="headerlink" title="SuperSet"></a>SuperSet</h2><p>Apache Superset 是一个现代数据探索和可视化平台。<br>是一个现代轻量级的BI分析工具，功能强大且易于使用、轻量级且可扩展、与现代数据库集成、丰富的可视化和仪表板。</p><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p>Apache Kafka 是一个开源分布式事件流平台，高吞吐量、弹性扩展、永久存储、高可用。</p><h2 id="Cassandra"><a href="#Cassandra" class="headerlink" title="Cassandra"></a>Cassandra</h2><p>由Facebook开发，Cassandra是一套开源分布式NoSQL数据库系统，基于 BigTable 和 DynamoDB 思想的宽列存储。</p><p>HBase vs Cassandra<br><a href="https://appinventiv.com/blog/hbase-vs-cassandra/">https://appinventiv.com/blog/hbase-vs-cassandra/</a></p><p>当你需要分析大数据或执行聚合时请使用HBase，如果强调交互式数据和实时事务处理，可以使用 Cassandra。</p><h2 id="ClickHouse"><a href="#ClickHouse" class="headerlink" title="ClickHouse"></a>ClickHouse</h2><p>ClickHouse是一个快速的开源 OLAP 数据库管理系统，它是面向列的，允许使用 SQL 查询实时生成分析报告。</p><h2 id="ETL"><a href="#ETL" class="headerlink" title="ETL"></a>ETL</h2><p>ETL是将业务系统的数据经过抽取（Extract）、清洗转换（Transform）之后加载（Load）到数据仓库的过程，目的是将企业中的分散、零乱、标准不统一的数据整合到一起，为企业的决策提供分析依据。</p><h2 id="ELK"><a href="#ELK" class="headerlink" title="ELK"></a>ELK</h2><p>ElasticSearch<br>Kibana<br>Logstash<br>Beats</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;大数据平台相关框架汇总。&lt;br&gt;包括：Hadoop、Hbase、Pig、Hive、Spark、Strom、Flink、Presto、Atlas、SuperSet、Cassandra、ClickHouse等&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://www.lights8080.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="大数据" scheme="http://www.lights8080.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>2109-3-小情境与大情境</title>
    <link href="http://www.lights8080.com/p/1db6c142.html"/>
    <id>http://www.lights8080.com/p/1db6c142.html</id>
    <published>2021-09-15T16:00:00.000Z</published>
    <updated>2021-09-17T01:40:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>如题</p><span id="more"></span><h2 id="话题：小情境与大情境"><a href="#话题：小情境与大情境" class="headerlink" title="话题：小情境与大情境"></a>话题：小情境与大情境</h2><p>最近在读一本书《李诞脱口秀工作手册》，还没有读完，其中有一个观点很有启发，小情境与大情境。<br>小情境就是你的一个又一个段子，大情境就是你的主持。</p><p>“””<br>请思考一个问题，我们上台演出的目的是什么？是为了伺候好那一场，那一天的观众吗？</p><p>我们当然要为演出效果负责，但是你上台的出发点不该是这个，而是要拉长时间看——目的始终是成为更强的脱口秀演员。<br>目的是通过逗笑观众磨砺自己，而不是逗笑观众。</p><p>不停上开放麦，不停演出的目的，是练自己，不是炸场。<br>最终你会变成一个在舞台上游刃有余，什么状况都能接住的演员，你会场场都炸。<br>但你的出发点不该是练这个，如果你一出发就去练怎么炸场，你也不太可能变成一个炸场演员。<br>你的上限太低了，你的上限就是一天又一天迎来送往的观众，你会慢慢发现，炸场其实挺容易的，你会收获一天又一天无意义的成功。</p><p>这也能解释从线下到线上的不适，你能练成伺候一百人的能力，你能伺候好一千万人吗？</p><p>不是你去找观众，而是要让观众来找你。狠狠地操练自己，你越强，找到你的观众越多。<br>而不是你能讨好的人越多，你的观众越多。<br>炸场是副产品，正如名利也是副产品。<br>追求炸场，追求名利，你会一无所获，或者更惨，你会变成一个庸人，甚至一个坏人。</p><p>人是目的，不是手段。<br>“””</p><p>他说很多朋友从线下转到线上，都要问这么一个问题，“我是该看观众还是该看镜头？”</p><p>这确实是一个很好的问题，在职场中类似的问题有一堆，“如何应对三十五岁危机？”，“如何跟老板搞好关系？”，“如何管理员工？”。</p><p>这些看似是很麻烦的问题，其实都是假问题。</p><p>脱口秀表演，如果你把重点放在与观众的关系上，你在台上很容易不知所措，后果就是注意力分散，或者更加悲惨，演砸了。<br>职场工作，如果你把重点放在搞好领导同事之间的关系上，那就是拿自己当手段不是目的，后果就是焦虑，工作做不好，在专业上不专业了。</p><p>过度去讨好观众，就算这场观众笑了；过度搞好同事关系，就算这几年升职加薪了，那也是无意义的成功。<br>用发展的眼光看问题，这是一份终身职业，一份与你的一切不能分割的工作，有意义的失败远远比无意义的成功有价值。</p><p>人生的目的就是成为更好的自己，狠狠地操练自己。</p><p>另外，我觉得每个人都应该学会识别生活中的小情境与大情境。<br>我们必须习惯用发展的眼光看问题，人生不是几把牌，赢了就赢了，人生是个牌局，想散都散不了的那种，输赢不在一把两把。</p><p>塞翁失马焉知非福。</p><p>说到这里，我认为在孩子教育的事情上，是非常非常需要用发展的眼光。<br>有时候会因为一些小事儿，跟孩子生气，跟他气完后，就反过来跟自己生气，“我为什么生气了？”。</p><p>教育不应该是控制，应该是高度控制下的失控。<br>教育是目的，不是手段。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如题&lt;/p&gt;</summary>
    
    
    
    <category term="weekly" scheme="http://www.lights8080.com/categories/weekly/"/>
    
    
    <category term="weekly" scheme="http://www.lights8080.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>2109-2-马猴来了</title>
    <link href="http://www.lights8080.com/p/9dc87d4e.html"/>
    <id>http://www.lights8080.com/p/9dc87d4e.html</id>
    <published>2021-09-09T16:00:00.000Z</published>
    <updated>2021-09-17T01:40:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>如题</p><span id="more"></span><h2 id="话题：马猴来了"><a href="#话题：马猴来了" class="headerlink" title="话题：马猴来了"></a>话题：马猴来了</h2><p>书接上文：<br>我之前一直都不认可这样的主播，认为其对社会没有任何价值。没有什么能耐，就靠嘴皮子，吸引一些脑残粉而已。</p><p>但我也被马猴所吸引了，至少在想休闲的时候会想到他的直播。<br>除了PK惩罚比较好玩意外，更喜欢的是他那真实的态度。<br>大多数主播，会迎合讨好粉丝，说话有时嗲嗲的，显得很做作。<br>马猴的直播算得上是一股清流，姿态放的很低，虽然是靠直播挣钱，但不刻意迎合粉丝，不说假话，自然真实，敢玩。<br>没有什么显眼才艺，但这就是他的风格。</p><p>非常敢玩游戏，除了吃东西不玩，其他的基本都敢接。<br>看过他往睡觉的床上泼一盆水，蒙眼跳蹬子，墩屁墩，墙上凿坑，脸上抹泥…<br>隔天再进他的直播间发现灯泡捅坏了，一扇门拆了，后面的背景阿里路亚抠的只剩路亚了。</p><p>直播中，粉丝问啥，他也从不遮遮掩掩。<br>比如直播挣多少钱啊，女主播内幕啊。<br>他透露自己<br>“””<br>曾经当过煤矿工人，一年就挣2w块钱。<br>赌博输掉20w，媳妇闹离婚。<br>我自己啥能耐没有，我去在外面，一个月挣个两三千到头了。<br>做主播现在好点，每个月挣6w差不多，一开始那会儿一月能有一两千不错了。<br>已经从直播中挣了差不多300w+，现在住的别墅，二楼单独弄了个直播间，给大家展示下子粉丝送的东西（好烟好酒）。<br>咱说实在的，给朋友随红包也就三五百块钱。哪天我的大哥开播了，我刷礼物就得一万多，少了拿不出手，是不是。<br>做PL直播的都没有一个好东西，都得有点啥事，正常上班的人干不了主播。<br>就现在的全网的这些PK主播都是些烂七八糟的人，真话。包括我自己，但是我没偷，没骗，没抢。你觉得自己过的不错你就刷点，觉得过的一般的看着就行了。<br>那些给女主播刷礼物的，好几万好几万的，你以为是情怀啊，屁！<br>……<br>“””</p><p>他自称是一个正能量主播，我觉得他也做到了。<br>PK哪怕输的一塌糊涂，气势上也一点不输，输多少次，依然当游戏欢笑面对。<br>真实、自信、不做作，这就是他给我传递的正能量！<br>分享直播生活和内幕，分享过往经历，能让人从中吸取一些经验教训，了解到不同人的生活方式，那也是价值。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如题&lt;/p&gt;</summary>
    
    
    
    <category term="weekly" scheme="http://www.lights8080.com/categories/weekly/"/>
    
    
    <category term="weekly" scheme="http://www.lights8080.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>数据仓库项目实战</title>
    <link href="http://www.lights8080.com/p/78ecf609.html"/>
    <id>http://www.lights8080.com/p/78ecf609.html</id>
    <published>2021-09-05T16:00:00.000Z</published>
    <updated>2021-09-08T08:53:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>读书笔记-《大数据分析：数据仓库项目实战》</p><span id="more"></span><h2 id="大数据和数据仓库概论"><a href="#大数据和数据仓库概论" class="headerlink" title="大数据和数据仓库概论"></a>大数据和数据仓库概论</h2><h4 id="大数据概论"><a href="#大数据概论" class="headerlink" title="大数据概论"></a>大数据概论</h4><p><img src="https://gitee.com/lights8080/lights8080-oss/raw/master/2021/09/mBx4zQ.jpg" alt="大数据生态圈的层次及其应用举例"></p><ul><li>数据采集层：多数据源，非结构化数据采集</li><li>数据计算层：分为离线数据计算和实时数据计算</li><li>数据应用层：最终提供给用户使用</li></ul><h4 id="数据仓库概论"><a href="#数据仓库概论" class="headerlink" title="数据仓库概论"></a>数据仓库概论</h4><p>数据仓库（Data Warehouse，DW）：为企业所有级别的决策制度过程，提供数据资源集合，出于分析性报告和决策支持目的而创建。是未面向分析的集成化数据环境。</p><p>数据仓库的特点：</p><ul><li>数据是面向主题的：具有更高的数据抽象级别</li><li>数据是集成的：数据源于不同的联机系统，进入仓库前必须经过统一和综合</li><li>数据是不可更新的</li><li>数据是随时间不断变化的</li></ul><h2 id="数据仓库建模"><a href="#数据仓库建模" class="headerlink" title="数据仓库建模"></a>数据仓库建模</h2><h4 id="范式理论"><a href="#范式理论" class="headerlink" title="范式理论"></a>范式理论</h4><p>使用范式的根本目的包括：</p><ul><li>减少数据冗余，尽量让每个数据只出现一次</li><li>保证数据的一致性</li></ul><p>联机事务处理(On-Line Transaction Processing，OLTP)：传统关系数据库的主要应用，保证数据的一致性及避免冗余。<br>联机分析处理(On-Line Analytical Processing，OLAP)：数据仓库系统主要应用，通常以某一张事实表为中心进行表的组织，面向业务，可能存在数据的冗余，通常采用维度模型建模。</p><p>维度模型：包括星型模型、雪花模型、星座模型</p><h4 id="表的分类"><a href="#表的分类" class="headerlink" title="表的分类"></a>表的分类</h4><p>事实表：每行数据代表一个业务事件。”事实”这个术语表示的是业务事件的度量值。如：订单金额</p><p>事实表分类：</p><ul><li>事务型事实表（每个事务或事件产生一行数据）</li><li>周期型快照事实表（保留固定时间间隔的数据）</li><li>累积型快照事实表（用于跟踪业务事实的变化）</li></ul><p>维度表：指对业务状态编码的解释表，又称为码表。如：订单状态表、商品分类</p><h4 id="逻辑分层"><a href="#逻辑分层" class="headerlink" title="逻辑分层"></a>逻辑分层</h4><p>分层：</p><ul><li>ODS（原始数据层，Operational Data Store）：加载原始日志</li><li>DWD（明细数据层，Data Warehouse Detail ）：结构和粒度与ODS保持一致，对数据进行清洗、维度退化、脱敏、数据压缩等（仅关注事实表的相关维度及度量值字段）</li><li>DWS（服务数据层，Data Warehouse Service ）：宽表化手段构建公共指标数据，不同的主题按天进行轻度汇总</li><li>DWT（主题数据层，Data Warehouse Topic）：按主题进行汇总，获得每个主题的全量数据表</li><li>ADS（应用数据层，Application Data Store）：面向实际的数据需求，为各统计报表提供数据</li></ul><p>好处：</p><ul><li>【易维护】高效的数据组织形式，清洗和过滤，规范化，血缘追踪</li><li>【高性能】时间价值，数据集合，维度汇总，查询效率</li><li>【简单化】集成价值，多维度数据整合，多角度多层次的数据分析</li><li>【历史性】历史数据，回溯历史，预测未来</li></ul><p>DWD构建维度模型的四个步骤：</p><ol><li>选择业务过程：一条业务线对应一张事实表。如：下单业务，支付业务</li><li>声明粒度：精确定义事实表中一行数据所表示的内容，尽可能选择最细粒度</li><li>确定维度：主要作用是描述业务事实，表示的是”谁、何处、何时”等信息。如时间维度，用户维度</li><li>确定事实：指的是业务中的度量值，如订单件数，订单金额等</li></ol><p>得出业务总线矩阵：将维度表进行退化，地区表和省份表退化为地区维度表，商品类目退化为商品维度表等<br><img src="https://gitee.com/lights8080/lights8080-oss/raw/master/2021/09/d4oJdU.jpg" alt="业务总线矩阵"></p><p>DWS、DWT层都是按照主题来创建宽表的，而主题相当于观察问题的角度，不同的维度表意味着不同的角度。<br><img src="https://gitee.com/lights8080/lights8080-oss/raw/master/2021/09/rxAni4.jpg"></p><p>DWS层用于统计各主题对象的当天行为，服务于DWT层的主题宽表，宽表字段是站在不同维度的视角去看事实表的，重点关注事实表的度量值。<br><img src="https://gitee.com/lights8080/lights8080-oss/raw/master/2021/09/4onPTr.jpg"></p><p>DWT层以分析的主题对象为建模驱动，基于上层应用和产品指标需求，构建主题对象的全量宽表。<br><img src="https://gitee.com/lights8080/lights8080-oss/raw/master/2021/09/puooTc.jpg"></p><p>ADS层分别对不同的主题进行指标分析。</p><h2 id="技术选型和架构选型"><a href="#技术选型和架构选型" class="headerlink" title="技术选型和架构选型"></a>技术选型和架构选型</h2><p>技术选型：<br>数据采集与传输：Flume、Kafka、Sqoop<br>数据存储：MySQL、HDFS<br>数据计算：Hive、Tez<br>任务调度：Azkaban<br>即席查询：Presto、Druid、Kylin<br>元数据管理：Atlas</p><p>框架选型：<br>Apache：可以自由定制所需功能组件，运维过程烦琐，组件间的兼容性需要自己调研<br>CDH：国内使用较多，不开源，不用担心组件兼容问题<br>HDP：开源，但没有CDH稳定，使用较少</p><h2 id="数据集市"><a href="#数据集市" class="headerlink" title="数据集市"></a>数据集市</h2><p>数据集市本质上是一个数据交易市场，就像宜家楼上的展厅，这是一个面向最终用户的数据市场。数据（家具）以一种更加容易被业务人员接受的方式组合在一起。<br>数据集市提供数据交易服务的最终实现，为用户提供各种数据服务支持。</p><p>特征：</p><ul><li>有特定的应用主题</li><li>业务部门管理和维护</li><li>聚焦具体领域，要满足低延迟，高并发的数据查询要求</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;读书笔记-《大数据分析：数据仓库项目实战》&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="技术" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="读书笔记" scheme="http://www.lights8080.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="大数据" scheme="http://www.lights8080.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    <category term="数据仓库" scheme="http://www.lights8080.com/tags/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>2109-1-对面大哥都是我祖宗</title>
    <link href="http://www.lights8080.com/p/342ac289.html"/>
    <id>http://www.lights8080.com/p/342ac289.html</id>
    <published>2021-09-02T16:00:00.000Z</published>
    <updated>2021-09-17T01:40:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>如题</p><span id="more"></span><h2 id="话题：对面大哥都是我祖宗"><a href="#话题：对面大哥都是我祖宗" class="headerlink" title="话题：对面大哥都是我祖宗"></a>话题：对面大哥都是我祖宗</h2><p>最近这几天在微信直播关注了一个逗比主播，分享一下这其中的故事。<br>晚上无事，打开手机漫无目的的乱滑着。进到一个直播间，两个人正在PK，热度和观看人数都很高。<br>出于好奇心，就持续看了下去。</p><p>左面是凡达（后面看粉丝说凡家主播占了微信直播的一半流量），右面是马猴。<br>PK期间，热度低的一方要不停的喊出一句话“对面的大哥都是我祖宗”（他们约定的游戏规则）。<br>PK结束，右边马猴小优势获胜。然后就是惩罚阶段，左边凡达撅着拿铁盆扣在屁股，用脚踢铁盆50下。<br>凡达各种挑衅问对面敢不敢再开一局，双方你一句我一句谁也让谁，又开了一局。（现在想想，PK主播想要的就是这种直播效果，线下可以是朋友，线上那就是损友）<br>这局凡达以碾压式的优势获胜。<br>马猴虽然输了，但整个状态就跟赢了对面十万票似的，连喊“对面的大哥都是我祖宗！！！”都底气十足。<br>惩罚是剪掉一个裤腿，也一样干净利索，说话气势态度上甚至比对面还强势。<br>我心想你都输成这样了，看你后面还咋直播，转而进了他的直播间。</p><p>俩人连线结束后不一会儿，一个大哥就上来语音连线了，后面就称他为X吧。（应该是经常给马猴打赏的粉丝）</p><p>X说：<br>“””<br>你这样还咋玩儿啊，你第一局赢了，你的粉丝大哥们这么支持你，给你刷礼物为啥啊？<br>你认为你把把都能赢凡达啊，人家多少粉丝什么级别，你这一局赢的就是侥幸，你知道吧。<br>我们这么给你刷礼物，就是要让你赢一次，他是大号，让他没有面子，后面才有机会再打，多吸引点他的粉丝过来，你才能火啊。<br>他为啥要各种刺激你，非要跟你打第二局啊，他要找回面子来的啊。<br>结果呢，你被他一刺激就开打了，你没有看你的聊天啊，都刷屏了让你别打！别打！<br>你鸟他干嘛啊，你对他那么实在有鸟用，你就照顾好你的粉丝就行了。<br>你看第二局打的，说真的，你这多伤你直播间儿大哥的心啊。<br>“””</p><p>这时候马猴的气势和心态都蔫了，他说：<br>我没想那么多，我就是玩儿，打的时候我说了，赢他凡达一次就够了，输多少次我都赢了。<br>如果伤害了直播间的大哥，我道歉，对不起。<br>我就是一个小主播，没法跟人家凡达比。<br>你说我没啥才艺，不会唱歌跳舞，我就是个PK主播，不PK那我主播什么，别的我也不会。<br>这是实话，真的。</p><p>X说：<br>“””<br>就你实在。<br>你赢了，第二局你不跟他打了，你放心第二天他肯定会主动找你连麦的。<br>他要找机会出气啊，他房间的大哥要给他撑腰啊，给他的粉丝要回面子啊。<br>你这样又打输了，他面子也找回去了，人家还会找你连麦吗？<br>就你这智商，连点战术都没有，你怎么火的起来哦，打仗不是光靠拼的。<br>“””</p><p>这时，又有人找他连麦PK。聊了一会儿，马猴说等会儿，我开个会。</p><p>X说：<br>“””<br>不要跟他开打，这人就是凡家的小弟。<br>你赢了一局，他还是咽不下这口气，找个小弟过来PK侮辱你的。<br>你就跟他磨嘴皮子，没话说了就撂下一句话，先打赢你师傅再来找我打。<br>我跟你讲，如果这次你连他小弟都打输了，你就再没机会了。<br>你放心，只有这样凡达才会再找你连麦，连这个都看不明白吗？<br>你照顾好你房间的大哥就行了，你对他那么实在干嘛。<br>“””</p><p>细品X说的这些话，真是战术大师，对方心理琢磨的透透的。<br>直播中还有这么多门道，这是我没有想到的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如题&lt;/p&gt;</summary>
    
    
    
    <category term="weekly" scheme="http://www.lights8080.com/categories/weekly/"/>
    
    
    <category term="weekly" scheme="http://www.lights8080.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>2108-4-企业文化</title>
    <link href="http://www.lights8080.com/p/7fc5d86f.html"/>
    <id>http://www.lights8080.com/p/7fc5d86f.html</id>
    <published>2021-08-26T16:00:00.000Z</published>
    <updated>2021-09-02T02:03:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>如题</p><span id="more"></span><h2 id="话题：企业文化"><a href="#话题：企业文化" class="headerlink" title="话题：企业文化"></a>话题：企业文化</h2><p>相信大部分人都非常向往大厂的企业文化吧。<br>比如：扁平化管理、没有考勤管理和休假制度、没有主管和考核、不建立统一技术规范、没有测试团队等。<br>天啊！很难想象这样的制度，公司怎样运营？</p><p>那大厂为什么会这样，且还能运营的很好？又是如何组织上万人朝着同一个目标前进呢。<br>我觉得关键是公司里是一群什么样的人。大厂的竞争实际是人才的竞争，而公司的企业文化就是要保证吸引和留住人才。<br>”“”<br>对于程序型的工作，顶级员工的输出量是一般员工的2倍。<br>对于创新型/创意型的工作，顶级员工的输出量是一般员工的10倍!<br>”“”</p><p>工程师人天生带有一种工匠式的图腾崇拜精神，奉行达者为师，不迷信管理他们的人，但充分尊重能够指导他们的人。<br>他们都非常的自律性，有目标，有责任感。企业里有这样一群优秀的人，还需要管理吗？</p><p>优秀的人从来不怕麻烦，如果是一个好的方案，大家就会趋同。所以不设立统一的技术规范，反而进化迭代出更好的规范。</p><p>公司的目标靠产品驱动，落实到人，分配给团队，团队就需要对自己做出来的东西负责任。<br>团队内有不同意见时，听谁的呢？<br>那就是谁对这个产品负责就听谁的，一旦负责人决定了，团队内不同意见的人，要迅速调整。</p><p>能力差的，不认可公司文化和价值观的人，最终会被淘汰掉，或主动离职。<br>所以企业文化和有这样一群人是密不可分的。<br>有这样的文化，没有这样一群优秀的人，是支撑不了企业成长的；<br>没有这样的文化，即使有这样一群优秀的人，最终也会人才流失。<br>大厂为啥热衷于要搞开源？互联网企业技术就是核心价值，这不是帮助同业成长吗？<br>核心还是建立行业标准和最佳实践，建立技术品牌，留住和吸引顶级工程师，并从共享生态中获得反馈输入受益。</p><p>多美好，相辅相成，但小厂照搬过来，大概率是行不通的。<br>原因是小厂没有能力招到一群优秀的人。基本都是一个大牛，带一堆小兵。<br>是小兵也就意味着能力水平和意识，都达不到水平，只能靠管理，靠规范，靠大牛的指导，才能朝着目标前进。</p><h2 id="语录"><a href="#语录" class="headerlink" title="语录"></a>语录</h2><ol><li>如果你想造一艘船，先不要雇人去收集木头， 也不要给他们分配任何任务，而是去激发他们对浩瀚汪洋的渴望。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;如题&lt;/p&gt;</summary>
    
    
    
    <category term="weekly" scheme="http://www.lights8080.com/categories/weekly/"/>
    
    
    <category term="weekly" scheme="http://www.lights8080.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>2108-3-从NBA看职场</title>
    <link href="http://www.lights8080.com/p/418eb76d.html"/>
    <id>http://www.lights8080.com/p/418eb76d.html</id>
    <published>2021-08-19T16:00:00.000Z</published>
    <updated>2021-09-02T02:03:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>如题</p><span id="more"></span><h2 id="话题：从NBA看职场"><a href="#话题：从NBA看职场" class="headerlink" title="话题：从NBA看职场"></a>话题：从NBA看职场</h2><p>球员背景：</p><p>施罗德：<br>市场上没有比施罗德更适合湖人的首发控卫了，从赛季中期湖人的报价来看，确实把施罗德当第三巨头来看待了。<br>施罗德也正是看中了这点，要求球队首发和顶薪，拒绝湖人平均年薪2000w报价的资本。</p><p>霍华德：<br>19-20赛季湖人获得NBA总冠军，霍华德在夺冠道路上也发挥了应有价值，选择续约湖人是自然的事情。<br>湖人从市场签约了小加索尔和哈雷尔，账目实力远大于霍华德，霍华德上场时间被挤没了，只能离队最终一年签约76人。</p><p>库兹马+波普：<br>库兹马、波普都处于合同年，因为19-20赛季在季后赛中发挥作用，提升了市场价值。湖人分别签了平均年薪超千万的长约。<br>但上赛季表现中规中矩，没有达到预期。</p><hr><p>我有时候会想如果我是湖人总经理，面对这个局面，我该如何操作呢？<br>尤其是对施罗德的续约上，顶薪明显是溢价合同，但是市场上又没有更好的选择了。放走施罗德湖人后卫就是问题？</p><p>下面来看看湖人总经理的操作：<br>1。 果断放弃表现不好的球员（库兹马+波普+哈雷尔），打包交易换来即战力很强的威少，组成三巨头，从侧面直接解决了施罗德的难题。<br>而施罗德，最终一年590w签约凯尔特人。</p><ol start="2"><li><p>毫不犹豫的重新签回霍华德。从上赛季的表现来看，去年的操作是失败的，小加索尔和哈雷尔和球队的化学反应并不好。</p></li><li><p>依靠巨星光环和总冠军，吸引优质球员底薪签约。</p></li></ol><h2 id="语录"><a href="#语录" class="headerlink" title="语录"></a>语录</h2><ol><li><p>当你有选择的时候，选择更重要；而当你没有选择的时候，努力才重要。努力是为了让你有更好的选择。</p></li><li><p>人不是因为变老了才没有热情，而是因为你没有热情才变老了。</p></li><li><p>成年人面对的第一个挑战就是没时间，我们需要解决的问题就是，在资源匮乏的情况下，还能够把事情做成。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;如题&lt;/p&gt;</summary>
    
    
    
    <category term="weekly" scheme="http://www.lights8080.com/categories/weekly/"/>
    
    
    <category term="weekly" scheme="http://www.lights8080.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>2108-2-K12双减的深度思考</title>
    <link href="http://www.lights8080.com/p/197f72b3.html"/>
    <id>http://www.lights8080.com/p/197f72b3.html</id>
    <published>2021-08-12T16:00:00.000Z</published>
    <updated>2021-09-02T02:03:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>如题</p><span id="more"></span><h2 id="话题：K12双减的深度思考"><a href="#话题：K12双减的深度思考" class="headerlink" title="话题：K12双减的深度思考"></a>话题：K12双减的深度思考</h2><p>认真观察身边的朋友同事，有一个现象比较明显。<br>肯吃苦努力工作的人基本都是穷人家庭出身，而那些对工作没有什么追求的人往往家庭条件比较优越。</p><p>都市剧《谁说我结不了婚》中有这样一段对话，我感触很深。<br>”“”<br>许海峰：至于这么拼吗？<br>田雷：我没有光鲜的学历，也没有丰厚的背景，我从实习生做起，一步一步拼到现在，才走到现在的位置。我拼尽全力，也只是你的起点而已。<br>”“”</p><p>我是农村出身，有时候真的会觉得很气，凭什么啊！<br>低收入家庭要想跃迁到中产阶级需要付出非常大的努力，而且不一定就能成功。而中产阶级家的孩子可以很轻松的享受并维持这个水平。</p><p>这也是年轻人躺平的原因吧，没有晋升希望。</p><p>贫富差距大，穷人太多，晋升的机会小，从宏观角度看，这是资本分配的问题。</p><p>经济内循环，关键还是要看中产阶级力量。中产阶级才是消费主力军，内循环的驱动力。（有钱的人占比太少拉动不起来，低收入家庭没钱去拉动，中产阶级是有欲望和有能力消费的群体）</p><p>20年统计，国家6亿人每月收入1000元。实现内循环，现存的中产阶级还不够。根本的解决办法，是让穷人变富。<br>如何变富？ - 靠自己。</p><p>国家层面要做的就是，尽可能保障赛道公平，让那些有天赋，肯吃苦，努力的人更容易实现阶层跃迁，给更多的低收入家庭以希望。<br>不能因为出身家庭财富和其他后天的限制就剥夺了成功的机会。要让后来人看到希望，带动更多的人步入中产。</p><p>K12双减，明面上是配合三胎政策，降低养育成本，实则是对中产阶级的降维打击。<br>强行拉平中产阶级家庭孩子和低收入家庭孩子到同一起跑线（低收入家庭没有经济能力上辅导班，那就让中产阶级家庭的孩子没有课外辅导班可上），降低底层民众晋升中产阶级的难度。</p><p>K12双减政策这只是国家层面调整社会资本结构的一部分。要求给外卖小哥和快递员上社保、加强反垄断等等，你细品其实都有其影子。</p><p>回到开头的所说的内容，年轻人躺平。<br>国家正在极力扭转这种局面，尽可能降低底层民众晋升中产阶级的难度，靠自己的努力实现富裕，去卷中产阶级。促进中产阶级的孩子努力去卷更高的阶级。</p><p>生病了，药再苦也得吃啊，总不能等到无药可救吧。</p><hr><p>要求给外卖小哥和快递员上社保，平台给骑手买社保，平台的利润减少了，最终肯定会转移到骑手和商家上。<br>外卖提价，高端的店留在平台，低端的店退出；<br>优秀的骑手收入会增加，大量混日子的骑手退出；<br>有钱人外卖贵点也会点，没钱人没钱点外卖了，去线下小店吃吧。</p><p>反垄断，会让资本更多的流向中小企业，中小企业是吸纳就业的重要力量。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如题&lt;/p&gt;</summary>
    
    
    
    <category term="weekly" scheme="http://www.lights8080.com/categories/weekly/"/>
    
    
    <category term="weekly" scheme="http://www.lights8080.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>凤凰架构-透明多层分流系统</title>
    <link href="http://www.lights8080.com/p/fd2df2c4.html"/>
    <id>http://www.lights8080.com/p/fd2df2c4.html</id>
    <published>2021-08-08T16:00:00.000Z</published>
    <updated>2021-10-25T02:13:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>周志明《凤凰架构：构建可靠的大型分布式系统》<br><a href="https://icyfenix.cn/">https://icyfenix.cn/</a></p><p>包括：域名解析，客户端缓存，传输链路，传输压缩，内容分发，负载均衡，服务端缓存。</p><span id="more"></span><p>透明多级分流系统的设计原则：</p><ul><li>第一个原则是尽可能减少单点部件，如果某些单点是无可避免的，则应尽最大限度减少到达单点部件的流量。</li><li>第二个原则是奥卡姆剃刀原则，它更为关键。”如无必要，勿增实体“</li></ul><h2 id="域名解析-DNS"><a href="#域名解析-DNS" class="headerlink" title="域名解析(DNS)"></a>域名解析(DNS)</h2><p>以 <a href="http://www.icyfenix.com.cn/">www.icyfenix.com.cn</a> 为例，介绍DNS把域名解析成IP地址的过程：</p><ol><li>客户端先检查本地的 DNS 缓存，查看是否存在并且是存活着的该域名的地址记录。</li><li>客户端将地址发送给本机操作系统中配置的本地 DNS（Local DNS）</li><li>本地 DNS 收到查询请求后，会按照顺序依次查找地址记录，“ <a href="http://www.icyfenix.com.cn/">www.icyfenix.com.cn</a> 的权威服务器”→“ icyfenix.com.cn 的权威服务器”→“ com.cn 的权威服务器”→“cn 的权威服务器”→“根域名服务器“。</li><li>现在假设本地 DNS 是全新的，上面不存在任何域名的权威服务器记录，当 DNS 查询请求一直查到根域名服务器之后，会得到“cn 的权威服务器”的地址记录，然后通过“cn 的权威服务器”，得到“com.cn 的权威服务器”的地址记录，以此类推，最后找到能够解释 <a href="http://www.icyfenix.com.cn/">www.icyfenix.com.cn</a> 的权威服务器地址。</li><li>通过“<a href="http://www.icyfenix.com.cn/">www.icyfenix.com.cn</a> 的权威服务器”，查询 <a href="http://www.icyfenix.com.cn/">www.icyfenix.com.cn</a> 的地址记录。</li></ol><p>DNS 的分级查询都有可能受到中间人攻击的威胁，产生被劫持的风险。</p><p>HTTPDNS（也称为 DNS over HTTPS，DoH）：它把原本的 DNS 解析服务开放为一个基于 HTTPS 协议的查询服务，替代基于 UDP 传输协议的 DNS 域名解析，通过程序代替操作系统直接从权威 DNS，或者可靠 Local DNS 获取解析数据，从而绕过传统 Local DNS。</p><blockquote><p>“切勿浪费较多东西，去做‘用较少的东西，同样可以做好的事情’。”<br>手上有个新锤子，看啥都是对口的钉子。</p></blockquote><h2 id="客户端缓存"><a href="#客户端缓存" class="headerlink" title="客户端缓存"></a>客户端缓存</h2><p>分为强制缓存和协商缓存，这两套机制是并行工作。当强制缓存超过时效或者被禁用，协商缓存也仍然可以正常工作。</p><h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h3><p>根据资源的修改时间进行检查</p><h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p>Expires 是 HTTP/1.0 协议中开始提供的 Header，后面跟随了一个截止时间参数</p><blockquote><p>HTTP/1.1 200 OK<br>Expires: Wed, 8 Apr 2020 07:28:00 GMT</p></blockquote><p>问题：</p><ul><li>受限于客户端的本地时间</li><li>无法处理涉及到用户身份的私有资源</li><li>无法描述“不缓存”的语义</li></ul><h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p>Cache-Control 是 HTTP/1.1 协议中定义的强制缓存 Header，与 Expires 同时存在，且语义存在冲突时，IETF 规定必须以 Cache-Control 为准。</p><blockquote><p>HTTP/1.1 200 OK<br>Cache-Control: max-age=600</p></blockquote><ul><li>max-age：相对于请求时间多少秒内，缓存是有效的</li><li>s-maxage：“共享缓存”的有效时间，即允许被 CDN、代理等持有的缓存有效时间</li><li>public：意味着资源可以被代理、CDN 等缓存</li><li>private：就意味着只能由用户的客户端进行私有缓存</li><li>no-cache：表明该资源不应该被缓存，哪怕是同一个会话中对同一个 URL 地址的请求</li><li>no-store：不强制会话中是否重复获取相同的 URL 资源，禁止浏览器、CDN 等以任何形式保存该资源</li><li>no-transform：禁止资源以任何形式被修改，包括Content-Encoding、Content-Range、Content-Type</li><li>min-fresh：仅用于客户端的请求 Header，用于建议服务器能返回一个不少于该时间的缓存资源</li><li>only-if-cached：表示客户端只会接受代理缓存，而不会接受源服务器的响应。如果代理缓存无效，就直接返回 503/Service Unavailable 错误</li><li>must-revalidate：表示在资源过期后，一定要从服务器中进行获取</li><li>proxy-revalidate：用于提示代理、CDN 等设备资源过期后的缓存行为，语义与 must-revalidate 完全一致</li></ul><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>根据资源唯一标识是否发生变化来进行检查</p><h4 id="根据资源的修改时间进行检查"><a href="#根据资源的修改时间进行检查" class="headerlink" title="根据资源的修改时间进行检查"></a>根据资源的修改时间进行检查</h4><p>Last-Modified：服务器的响应 Header，用来告诉客户端这个资源的最后修改时间<br>If-Modified-Since：客户端再次请求时，会通过 If-Modified-Since，把之前收到的资源最后修改时间发送回服务端</p><p>服务端发现资源在该时间后没有被修改过，就只要返回一个 304/Not Modified 的响应即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 304 Not Modified</span><br><span class="line">Cache-Control: public, max-age=600</span><br><span class="line">Last-Modified: Wed, 8 Apr 2020 15:31:30 GMT</span><br></pre></td></tr></table></figure><h4 id="根据资源唯一标识是否发生变化来进行检查"><a href="#根据资源唯一标识是否发生变化来进行检查" class="headerlink" title="根据资源唯一标识是否发生变化来进行检查"></a>根据资源唯一标识是否发生变化来进行检查</h4><p>Etag：是服务器的响应 Header，用于告诉客户端这个资源的唯一标识<br>If-None-Match：当客户端需要再次请求时，就会通过 If-None-Match，把之前收到的资源唯一标识发送回服务端</p><h2 id="传输链路"><a href="#传输链路" class="headerlink" title="传输链路"></a>传输链路</h2><h3 id="前端网页的优化技巧"><a href="#前端网页的优化技巧" class="headerlink" title="前端网页的优化技巧"></a>前端网页的优化技巧</h3><ul><li>最少请求数量：TCP连接开销很大，解决手段有雪碧图，文件合并，媒体内联等</li><li>扩大并发请求数：现代浏览器一般支持6个并发请求，解决手段域名分片</li><li>启用压缩传输：减少网络传输内容的大小</li><li>避免页面重定向：页面发生了重定向，就会延迟整个文档的传输</li><li>按重要性调节资源优先级：对客户端展示影响大的资源，放在 HTML 的头部，以便优先下载</li><li>…</li></ul><p>因为 HTTP 协议还在持续发展，这些优化技巧可能会成为反模式。<br>HTTP/3以前是以 TCP 为传输层的应用层协，TCP 协议本身是面向长时间、大数据传输来设计的。<br>而每个页面包含的资源（HTML、CSS、JS、图片等）的特征是，数量多，资源小。<br>以至于 HTTP/1.x 时代，大量短而小的 TCP 连接导致了网络性能的瓶颈。</p><h3 id="Keep-Alive-机制"><a href="#Keep-Alive-机制" class="headerlink" title="Keep-Alive 机制"></a>Keep-Alive 机制</h3><p>（HTTP/1.0 中不是默认开启的，HTTP/1.1 中变为默认）<br>原理是让客户端对同一个域名长期持有一个或多个不会用完即断的 TCP 连接。客户端维护一个 FIFO 队列，每次取完数据之后的一段时间内，不自动断开连接，下一个资源时可以直接复用，避免创建 TCP 连接的成本。</p><p>副作用：队首阻塞，首个资源是一个复杂的请求，导致后面的请求必须阻塞等待。</p><h3 id="HTTP-2-的多路复用技术"><a href="#HTTP-2-的多路复用技术" class="headerlink" title="HTTP/2 的多路复用技术"></a>HTTP/2 的多路复用技术</h3><p>在 HTTP/1.x 中，HTTP 请求就是传输过程中最小粒度的信息单位，如果将多个请求切碎，再混杂在一块传输，客户端难以分辨重组出有效信息。<br>而在 HTTP/2 中，帧（Frame）才是最小粒度的信息单位。它可以用来描述各种数据，比如请求的 Headers、Body，或者是用来做控制标识，如打开流、关闭流。<br>流（Stream）是一个逻辑上的数据通道概念，每个帧都附带有一个流 ID，以标识这个帧属于哪个流。</p><p>多路复用的支持，HTTP/2 就可以对每个域名只维持一个 TCP 连接，开发者也不用去考虑并发请求数限制，客户端就不需要再刻意压缩 HTTP 请求。</p><p>在 HTTP 传输中，Headers 占传输成本的比重是相当地大，HTTP/2 中专门考虑如何进行 Header 压缩的问题，同一个连接上产生的请求和响应越多，头部压缩效果也就越好。所以 HTTP/2 是单域名单连接的机制，合并资源和域名分片反而对性能提升不利。</p><p>与 HTTP/1.x 相反，HTTP/2 本身反而变得更适合传输小资源。</p><h3 id="传输压缩"><a href="#传输压缩" class="headerlink" title="传输压缩"></a>传输压缩</h3><p>当客户端可以接受压缩版本的资源时（请求的 Header 中包含 Accept-Encoding: gzip），就返回压缩后的版本（响应的 Header 中包含 Content-Encoding: gzip），否则就返回未压缩的原版。</p><h4 id="静态预压缩"><a href="#静态预压缩" class="headerlink" title="静态预压缩"></a>静态预压缩</h4><p>在网络时代的早期，服务器的处理能力还很薄弱，为了启用压缩，会把静态资源预先压缩为.gz 文件的形式给存放起来。</p><h4 id="即时压缩"><a href="#即时压缩" class="headerlink" title="即时压缩"></a>即时压缩</h4><p>现代的 Web 服务器处理能力有了大幅提升，整个压缩过程全部在内存的数据流中完成，不必等资源压缩完成再返回响应，这样可以显著提高首字节时间，改善 Web 性能体验。</p><p>在 HTTP/1.0 时，资源结束判断的机制，只有根据 Content-Length 判断。<br>但即时压缩时，服务器再也没有办法给出 Content-Length 这个响应 Header 了。<br>所以，如果是 HTTP/1.0 的话，持久连接和即时压缩只能二选其一。<br>在 HTTP/1.0 中这两者都支持，却默认都是不启用。</p><h4 id="分块编码"><a href="#分块编码" class="headerlink" title="分块编码"></a>分块编码</h4><p>HTTP/1.1中，增加了另一种资源结束判断的机制，“分块传输编码”（Chunked Transfer Encoding）。</p><p>工作原理：在响应 Header 中加入“Transfer-Encoding: chunked”之后，就代表这个响应报文将采用分块编码。此时，报文中的 Body 需要改为用一系列“分块”来传输。每个分块包含十六进制的长度值和对应长度的数据内容，长度值独占一行，数据从下一行开始。最后以一个长度值为 0 的分块，来表示资源结束。</p><h3 id="快速-UDP-网络连接"><a href="#快速-UDP-网络连接" class="headerlink" title="快速 UDP 网络连接"></a>快速 UDP 网络连接</h3><p>想从根本上改进 HTTP，就必须直接替换掉 HTTP over TCP 的根基，即 TCP 传输协议。2018 年末，IETF 正式批准了 HTTP over QUIC 使用 HTTP/3 的版本号，它会以 UDP 协议作为基础。</p><h2 id="内容分发网络-CDN"><a href="#内容分发网络-CDN" class="headerlink" title="内容分发网络(CDN)"></a>内容分发网络(CDN)</h2><p>CDN 其实就是做“内容分销”工作的。</p><p>内容分发网络的工作过程，主要涉及到路由解析、内容分发、负载均衡和它所能支持的应用内容四个方面。</p><p>仅从网络传输的角度来看，一个互联网系统的速度快慢，主要取决于以下四点因素：</p><ol><li>网站服务器接入网络运营商的链路所能提供的出口带宽。</li><li>用户客户端接入网络运营商的链路所能提供的入口带宽。</li><li>从网站到用户之间，经过的不同运营商之间互联节点的带宽。</li><li>从网站到用户之间的物理链路传输时延。</li></ol><h3 id="路由解析"><a href="#路由解析" class="headerlink" title="路由解析"></a>路由解析</h3><p><img src="https://gitee.com/lights8080/lights8080-oss/raw/master/2021/08/kCQhKS.png" alt="CDN 路由解析"></p><h3 id="内容分发"><a href="#内容分发" class="headerlink" title="内容分发"></a>内容分发</h3><p>无论是对用户还是服务器，内容分发网络都可以是完全透明的，CDN需要解决两个问题：“如何获取源站资源”和“如何管理（更新）资源”。</p><h4 id="第一种：主动分发（Push）"><a href="#第一种：主动分发（Push）" class="headerlink" title="第一种：主动分发（Push）"></a>第一种：主动分发（Push）</h4><p>主动分发就是由源站主动发起，将内容从源站或者其他资源库推送到用户边缘的各个 CDN 缓存节点上。</p><p>通常需要源站、CDN 服务双方提供的程序 API 接口层面的配合。</p><h4 id="第二种：被动回源（Pull）"><a href="#第二种：被动回源（Pull）" class="headerlink" title="第二种：被动回源（Pull）"></a>第二种：被动回源（Pull）</h4><p>由用户访问所触发的全自动、双向透明的资源缓存过程。当某个资源首次被用户请求的时候，CDN 缓存节点如果发现自己没有该资源，就会实时从源站中获取。</p><p>可以做到完全的双向透明，不需要源站在程序上做任何的配合，使用起来非常方便。</p><h4 id="如何管理（更新）资源"><a href="#如何管理（更新）资源" class="headerlink" title="如何管理（更新）资源"></a>如何管理（更新）资源</h4><p>对于Cache-Control的 s-maxage，是否遵循，完全取决于 CDN 本身的实现策略。</p><p>CDN 缓存的管理没有通用的准则，最常见的管理（更新）资源的做法是超时被动失效与手工主动失效相结合。</p><h3 id="CDN-应用"><a href="#CDN-应用" class="headerlink" title="CDN 应用"></a>CDN 应用</h3><ul><li>加速静态资源</li><li>安全防御，DDoS攻击</li><li>协议升级，https，IPv6</li><li>状态缓存</li><li>修改资源，给源站不支持跨域的资源提供跨域能力</li><li>访问控制，QoS控制，referer防盗链</li><li>注入功能，Google Analytics等</li></ul><h2 id="负载均衡-Load-Balancing"><a href="#负载均衡-Load-Balancing" class="headerlink" title="负载均衡(Load Balancing)"></a>负载均衡(Load Balancing)</h2><p>“负载均衡器”（Load Balancer）：承担了调度后方的多台机器，以统一的接口对外提供服务的技术组件。</p><p>从形式上来说都可以分为两种：四层负载均衡和七层负载均衡。四层负载均衡的优势是性能高，七层负载均衡的优势是功能强。</p><table><thead><tr><th></th><th><div style="width:135px"><strong>层</strong></div></th><th><div style="width:75px"><strong>数据单元</strong></div></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>7</td><td>应用层 <br/>Application Layer</td><td>数据<br/>Data</td><td>提供为应用软件提供服务的接口，用于与其他应用软件之间的通信。典型协议：HTTP、HTTPS、FTP、Telnet、SSH、SMTP、POP3 等</td></tr><tr><td>6</td><td>表达层<br/>Presentation Layer</td><td>数据 <br/>Data</td><td>把数据转换为能与接收者的系统格式兼容并适合传输的格式。</td></tr><tr><td>5</td><td>会话层 <br/>Session Layer</td><td>数据 <br/>Data</td><td>负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接。</td></tr><tr><td>4</td><td>传输层 <br/>Transport Layer</td><td>数据段<br/>Segments</td><td>把传输表头加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。典型协议：TCP、UDP、RDP、SCTP、FCP 等</td></tr><tr><td>3</td><td>网络层 <br/>Network Layer</td><td>数据包<br/>Packets</td><td>决定数据的传输路径选择和转发，将网络表头附加至数据段后以形成报文（即数据包）。典型协议：IPv4/IPv6、IGMP、ICMP、EGP、RIP 等</td></tr><tr><td>2</td><td>数据链路层 <br/>Data Link Layer</td><td>数据帧<br/>Frame</td><td>负责点对点的网络寻址、错误侦测和纠错。当表头和表尾被附加至数据包后，就形成数据帧（Frame）。典型协议：WiFi（802.11）、Ethernet（802.3）、PPP 等。</td></tr><tr><td>1</td><td>物理层<br/>Physical Layer</td><td>比特流<br/>Bit</td><td>在局域网上传送数据帧，它负责管理电脑通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机接口卡等。</td></tr></tbody></table><h4 id="四层负载均衡"><a href="#四层负载均衡" class="headerlink" title="四层负载均衡"></a>四层负载均衡</h4><p>四层负载均衡的工作模式都属于“转发”，即直接将承载着 TCP 报文的底层数据格式（IP 数据包或以太网帧），转发到真实服务器上，此时客户端到响应请求的真实服务器维持着同一条 TCP 通道。</p><p><strong>数据链路层负载均衡</strong><br>数据链路层传输的内容是数据帧（Frame），只需要注意到“MAC 目标地址”和“MAC 源地址”两项即可。</p><p>工作原理：修改请求的数据帧中的 MAC 目标地址，让用户原本是发送给负载均衡器的请求的数据帧，被二层交换机根据新的 MAC 目标地址，转发到服务器集群中，对应的服务器的网卡上，这样真实服务器就获得了一个原本目标并不是发送给它的数据帧。</p><p>数据链路层负载均衡的工作模式是，只有请求会经过负载均衡器，而服务的响应不需要从负载均衡器原路返回，整个请求、转发、响应的链路形成了一个“三角关系”，又叫“三角传输模式”，“单臂模式”，“直接路由”。</p><p>二层负载均衡器工作原理决定了，它们必须位于同一个子网当中，无法跨 VLAN。这个优势（效率高）和劣势（不能跨子网）就共同决定了，数据链路层负载均衡最适合用来做数据中心的第一级均衡设备，用来连接其他的下级负载均衡器。</p><p><strong>网络层负载均衡</strong><br>网络层传输的单位是分组数据包（Packets），只要知道在 IP 分组数据包的 Headers 带有源和目标的 IP 地址即可。</p><p>第一种：保持原来的数据包不变，新创建一个数据包。(IP隧道)<br>优点：</p><ul><li>并没有修改原有数据包中的任何信息，仍然具备三角传输特性</li><li>IP 隧道工作在网络层，所以可以跨越 VLAN</li></ul><p>缺点：</p><ul><li>真实服务器收到数据包后，必须在接收入口处，设计拆包机制。(几乎所有Linux系统都支持IP隧道协议)</li><li>必须保证所有的真实服务器与均衡器有着相同的虚拟 IP 地址</li></ul><p>第二种：改变目标数据包，直接把数据包 Headers 中的目标地址改掉(NAT 模式)<br>NAT模式：充当了家里、公司、学校的上网路由器的作用。</p><p>优点：</p><ul><li>没有经过 IP 隧道的额外包装，无需再拆包了</li><li>彻底的透明，真实服务器连网关都不需要配置，均衡器在转发时不仅修改目标 IP 地址，连源 IP 地址也一起改了</li></ul><p>缺点：</p><ul><li>不具备三角传输特性，必须回到负载均衡，改回自己的IP，再发给客户端。流量压力比较大时，带来较大的性能损失</li><li>真实服务器处理请求时就无法拿到客户端的 IP 地址</li></ul><h4 id="应用层负载均衡"><a href="#应用层负载均衡" class="headerlink" title="应用层负载均衡"></a>应用层负载均衡</h4><p>工作在四层之后的负载均衡模式就无法再进行转发了，只能进行代理。此时正式服务器、负载均衡器、客户端三者之间，是由两条独立的 TCP 通道来维持通讯的。</p><p><img src="https://gitee.com/lights8080/lights8080-oss/raw/master/2021/08/uHa47g.jpg" alt="转发与代理"></p><p>分类：</p><ul><li>正向代理就是我们通常简称的代理，意思就是在客户端设置的、代表客户端与服务器通讯的代理服务。它是客户端可知，而对服务器是透明的。</li><li>反向代理是指设置在服务器这一侧，代表真实服务器来与客户端通讯的代理服务。此时它对客户端来说是透明的。</li><li>透明代理是指对双方都透明的，配置在网络中间设备上的代理服务。比如，架设在路由器上的透明翻墙代理。</li></ul><p>七层负载均衡器，不能去做下载站、视频站这种流量应用，起码不能作为第一级均衡器。<br>缺点：网络性能比不过四层负载均衡器，多一轮TCP握手，还有 NAT 转发模式一样的带宽问题<br>优点：可以感知应用层通讯的具体内容，往往能够做出更明智的决策</p><p>应用：</p><ul><li>缓存方面的工作，比如静态资源缓存、协议升级、安全防护、访问控制等</li><li>更智能化的路由，比如Session 路由、亲和性集群、URL路由、根据用户路由等</li><li>某些安全攻击可以由七层负载均衡器来抵御，比如DDoS 手段是 SYN Flood 攻击</li><li>链路治理措施，比如服务降级、熔断、异常注入等</li><li>…</li></ul><h4 id="均衡策略与实现"><a href="#均衡策略与实现" class="headerlink" title="均衡策略与实现"></a>均衡策略与实现</h4><p>均衡策略与实现</p><ul><li>轮循均衡</li><li>权重轮循均衡</li><li>随机均衡</li><li>权重随机均衡</li><li>一致性哈希均衡</li><li>响应速度均衡</li><li>最少连接数均衡</li></ul><p>负载均衡器的实现有“软件均衡器”和“硬件均衡器”两类。</p><p>软件均衡器又分为直接建设在操作系统内核的均衡器和应用程序形式的均衡器两种。前者的代表是 LVS（Linux Virtual Server），后者的代表有 Nginx、HAProxy、KeepAlived，等等；前者的性能会更好，因为它不需要在内核空间和应用空间中来回复制数据包；而后者的优势是选择广泛，使用方便，功能不受限于内核版本。</p><p>硬件均衡器，往往会直接采用应用专用集成电路来实现。因为它有专用处理芯片的支持，可以避免操作系统层面的损耗，从而能够达到最高的性能。这类的代表就是著名的 F5 和 A10 公司的负载均衡产品。</p><h2 id="缓存-Cache"><a href="#缓存-Cache" class="headerlink" title="缓存(Cache)"></a>缓存(Cache)</h2><p>服务端缓存是一种通用的技术组件，它主要用于减少多个客户端相同的资源请求，缓解或降低服务器的负载压力。</p><p>引入缓存的理由，1）为了缓解 CPU 压力而做缓存，2）为了缓解 I/O 压力而做缓存。<br>如果你可以通过增强 CPU、I/O 本身的性能（比如扩展服务器的数量）来满足需要的话，那升级硬件往往是更好的解决方案。</p><p>吞吐量（每秒操作数，Operations per Second，ops/s）：它反映了对缓存进行并发读、写操作的效率，即缓存本身的工作效率高低。<br>缓存的吞吐量只在并发场景中才有统计的意义，所以，并发读写的场景中，“尽可能避免数据竞争”是最关键的。<br>针对伴随读写操作而来的状态维护，有两种处理思路。一种是以 Guava Cache 为代表的同步处理机制，另一种是以 Caffeine 为代表的异步日志提交机制。</p><p>缓存策略：</p><ul><li>FIFO（First In First Out）：优先淘汰最早进入被缓存的数据</li><li>LRU（Least Recent Used）：优先淘汰最久未被使用访问过的数据</li><li>LFU（Least Frequently Used）：优先淘汰最不经常使用的数据</li><li>TinyLFU（Tiny Least Frequently Used）：TinyLFU 是 LFU 的改进版本，通过用少量的样本数据来估计全体数据的特征。用相对小得多的记录频率和空间，来近似地找出缓存中的低价值数据。</li></ul><p>扩展知识：</p><blockquote><ol><li>ConcurrentHashMap（JDK8）中读操作完全没有线程安全措施，无论是CAS还是Synchronized都没有做。写操作是通过CAS来做节点位置判断，通过Synchronized来修改值。单个值级别的锁定意味着只有不同线程、修改同一个值才会有锁竞争。不同线程修改不同的值不会竞争相同的锁，或者相同线程修改同一个值锁是可重入的，简而言之“有锁”并不一定是指“有竞争”。</li><li>软件开发两大难题，一个是缓存失效，该失效时未失效，不该失效时失效，另一个是命名。</li><li>环形缓冲(Ring Buffer)：它是一种拥有读、写两个指针的数据复用结构。</li></ol></blockquote><h3 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h3><p>缓存可以分为“进程内缓存”和“分布式缓存”两大类。</p><p>进程内缓存：只为节点本身提供服务，无网络访问操作，速度快但缓存的数据不能在各个服务节点中共享。<br>分布式缓存：与进程内缓存相反，处理与网络有关的操作是影响吞吐量的主要因素。分为复制式缓存与集中式缓存。</p><p>复制式缓存，可以看作是“能够支持分布式的进程内缓存”，工作原理与 Session 复制类似，代表是JBossCache。缺点是复制性能会随着节点的增加呈现平方级下降，基本上已经很难再见到使用这种缓存形式的大型信息系统了。<br>集中式缓存，是目前分布式缓存的主流形式，代表是Redis。缺点是缓存的读、写都需要网络访问，不可能再达到进程内缓存那样的高性能。好处是不会随着集群节点数量的增加而产生额外的负担.</p><p>分布式缓存集群是否能保证数据一致性，也可以将它分为 AP 和 CP 两种类型，通常不太会使用缓存来处理追求强一致性的数据。<br>Redis 集群就是典型的 AP 式，它具有高性能、高可用等特点，但它却并不保证强一致性。而能够保证强一致性的 ZooKeeper、Doozerd、Etcd 等分布式协调框架，通常不会把它们当作“缓存框架”来使用。倒是常跟 Redis 和其他分布式缓存搭配工作，用来实现其中的通知、协调、队列、分布式锁等功能。</p><p>分布式缓存与进程内缓存各有所长，它们是互补的，而不是竞争的关系。所以，完全可以同时互相搭配，来构成透明多级缓存（Transparent Multilevel Cache，TMC）。</p><p>多级缓存的意思是，使用进程内缓存做一级缓存，分布式缓存做二级缓存。但代码侵入性较大，不便于管理，数据更新更是麻烦，很容易出现一二级缓存里的数据不一致。<br>如何“透明”地解决这些问题，多级缓存才具有实用的价值。<br>一种常见的设计原则，就是变更以分布式缓存中的数据为准，访问以进程内缓存的数据优先。大致做法是当数据发生变动时，在集群内发送推送通知（引入ZooKeeper 或 Etcd 来处理），让各个节点的一级缓存自动失效掉相应数据。</p><h3 id="缓存风险"><a href="#缓存风险" class="headerlink" title="缓存风险"></a>缓存风险</h3><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>查询的数据在数据库中根本不存在的话，请求的流量每次都不会命中，每次都会触及到末端的数据库。这种查询不存在数据的现象，就被称为缓存穿透。</p><p>解决办法：<br>1）对于业务逻辑本身就不能避免的缓存穿透，约定一定时间内，返回空的Key依然进行缓存。<br>2）对于恶意攻击导致的缓存穿透，设置布隆过滤器，用最小的代价，判断某个元素是否存在。</p><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>缓存中的某些热点数据忽然因为某种原因失效了，都到达真实数据源中去，导致其压力剧增。这种现象，就被称为缓存击穿。</p><p>解决办法：<br>1）加锁同步，以请求该数据的 Key 值为锁，其他线程采取阻塞或重试策略。<br>2）热点数据由代码来手动管理</p><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>由于大批不同的数据在短时间内一起失效，导致了这些数据的请求都击穿了缓存，到达数据源。这种现象，就被称为缓存雪崩。</p><p>解决办法：<br>1）提升缓存系统可用性，建设分布式缓存的集群。<br>2）分散了它们的过期时间<br>3）将缓存的生存期从固定时间改为一个时间段内的随机时间</p><h4 id="缓存污染"><a href="#缓存污染" class="headerlink" title="缓存污染"></a>缓存污染</h4><p>缓存中的数据与真实数据源中的数据不一致的现象。</p><p>为了尽可能地提高使用缓存时的一致性，人们已经总结了不少更新缓存时可以遵循的设计模式，比如 Cache Aside、Read/Write Through、Write Behind Caching，等等。</p><h5 id="Cache-Aside："><a href="#Cache-Aside：" class="headerlink" title="Cache Aside："></a>Cache Aside：</h5><ul><li>读数据时，先读缓存，缓存没有的话，再读数据源，然后将数据放入缓存，再响应请求。</li><li>写数据时，先写数据源，然后失效（而不是更新）掉缓存。</li></ul><p>Cache Aside 模式依然也不能保证在一致性上绝对不出问题，采用 Cache Aside 模式典型的出错场景，就是如果某个数据是从未被缓存过的，请求会直接流到真实数据源中，如果数据源中的写操作发生在查询请求之后，结果回填到缓存之前，也会出现缓存中回填的内容与数据库的实际数据不一致的情况。<br>但是，出现这种情况的概率实际上是很低的，Cache Aside 模式仍然是以低成本更新缓存，并且获得相对可靠结果的解决方案。</p><h5 id="Read-Write-Through"><a href="#Read-Write-Through" class="headerlink" title="Read/Write Through"></a>Read/Write Through</h5><ul><li>Read Through，读数据时，先读缓存，缓存没有的话，由缓存组件负责读数据源将数据放入缓存，再响应请求。</li><li>Write Through，写数据时，先写入缓存，由缓存组件负责同步更新到数据源中。</li></ul><h5 id="Write-Behind-Caching"><a href="#Write-Behind-Caching" class="headerlink" title="Write Behind Caching"></a>Write Behind Caching</h5><p>Write back是相较于Write Through而言的一种异步回写策略，由缓存组件负责异步更新到数据源中。适用于读少写多的场景。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;周志明《凤凰架构：构建可靠的大型分布式系统》&lt;br&gt;&lt;a href=&quot;https://icyfenix.cn/&quot;&gt;https://icyfenix.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;包括：域名解析，客户端缓存，传输链路，传输压缩，内容分发，负载均衡，服务端缓存。&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="技术" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="凤凰架构" scheme="http://www.lights8080.com/tags/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>2108-1-什么才是给孩子最好的礼物</title>
    <link href="http://www.lights8080.com/p/f438d8cc.html"/>
    <id>http://www.lights8080.com/p/f438d8cc.html</id>
    <published>2021-08-05T16:00:00.000Z</published>
    <updated>2021-09-28T07:25:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>如题</p><span id="more"></span><h2 id="话题：什么才是给孩子最好的礼物"><a href="#话题：什么才是给孩子最好的礼物" class="headerlink" title="话题：什么才是给孩子最好的礼物"></a>话题：什么才是给孩子最好的礼物</h2><p>如果说“给孩子最好的礼物是陪伴”，相信大部分人都不会反驳，且还能说出一大堆的理由来。</p><p>我试着脑补了一下，在孩子的不同时期，问他俩个问题：<br>“”“<br>孩子10岁，你问他什么最重要？他会回答是陪伴；<br>20岁问他什么最重要，他会说钱；你再问快乐的童年重要吗，他会想想说也重要。<br>30岁问他什么最重要，他会告诉你是环境和成长经历；快乐的童年重要吗，没那么重要。<br>“”“</p><p>如果在读的你现在已经三十几岁已经有孩子，对于上面这个回答并不排斥吧    </p><p>为什么家长从小就给孩子报各种补习班？那是因为我们都知道相比于快乐的童年，孩子的未来更重要，孩子将来长大了一定不会怪我。</p><p>我们都很想时刻陪在孩子身边，但是总得想想孩子20岁，30岁时最需要的是什么。真的在乎童年的陪伴吗？</p><p>我这样说，并不是我认为小时候对孩子的陪伴不重要。相反，我也认为很重要，但我想表达的是陪伴的重要性是要建立在生长环境、成长经历和财务支持等基础之上的。</p><p>如果你有能力把这些都平衡好，那真的很完美，对于普通人而言，必须有所取舍。</p><p>很遗憾没有给你美好的童年，如果现在有机会能让你在20岁，30岁时多一点点的选择，那就够了。</p><hr><p>这个思考来源于，最近二姐一家五口驱车从天津出发开往西藏。一次说走就走的旅行，这一定是很多人羡慕和向往的生活方式。</p><p>在这之前说实话我对姐夫有一定的偏见，而且是很固执的，根本原因就是没有对家庭的陪伴。</p><p>“我也想天天在家里陪着他们，你知道仨孩子上学要多少钱，将来出国留学，结婚要多少钱。我不出去挣钱，日子怎么过，她们不理解我，咱俩是男的，我以为你能理解我”<br>上面这句话是我俩单独聊天他说的（并非原话，意思一样）。</p><p>说实话，当时我并没有理解。但是随着年龄的增长，我越来越能get到他的点。<br>抛去那些分支乱插，从现在的结果来看，我觉得他并没有敷衍，而且正在一步一步的践行自己的承诺。</p><p>初心未变，负重前行。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如题&lt;/p&gt;</summary>
    
    
    
    <category term="weekly" scheme="http://www.lights8080.com/categories/weekly/"/>
    
    
    <category term="weekly" scheme="http://www.lights8080.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>凤凰架构-分布式事务</title>
    <link href="http://www.lights8080.com/p/c901dee9.html"/>
    <id>http://www.lights8080.com/p/c901dee9.html</id>
    <published>2021-08-04T16:00:00.000Z</published>
    <updated>2021-09-07T03:50:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>周志明《凤凰架构：构建可靠的大型分布式系统》<br><a href="https://icyfenix.cn/">https://icyfenix.cn/</a></p><p>包括：CAP、BASE理论。实现分布式事务的三种解决方案，可靠消息队列、TCC、SAGA事务。</p><p>可靠消息队列：简单、无法解决隔离性问题<br>TCC：编码实现业务隔离性，但要求技术可控性（预留资源接口），硬编码可以使用Seata<br>SAGA事务：编码实现业务隔离性和补偿机制，不要求技术可控性，硬编码可以使用Seata</p><span id="more"></span><p>分布式事务（Distributed Transaction）特指<strong>多个服务同时访问多个数据源</strong>的事务处理机制。</p><h4 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h4><p>分布式系统（distributed system）的最大难点，就是各个节点的状态如何同步。CAP 定理是这方面的基本定理。</p><ul><li><p>一致性（Consistency）：代表在任何时刻、任何分布式节点中所看到的数据都是符合预期的。</p></li><li><p>可用性（Availability）：代表系统不间断地提供服务的能力。密切相关两个指标：可靠性（平均无故障时间：MTBF）和可维护性（平均可修复时间：MTTR）。</p></li><li><p>分区容忍性（Partition Tolerance）：代表分布式环境中部分节点因网络原因而彼此失联（即与其他节点形成“网络分区”）时，系统仍能正确地提供服务的能力。</p></li><li><p>如果放弃分区容忍性（CA without P），意味着我们将假设节点之间通信永远是可靠的。永远可靠的通信在分布式系统中必定不成立的。主流的 RDBMS（关系数据库管理系统）集群通常就是采用放弃分区容错性的工作模式。</p></li><li><p>如果放弃可用性（CP without A），意味着我们将假设一旦网络发生分区，节点之间的信息同步时间可以无限制地延长，此时，问题相当于退化到前面“全局事务”中讨论的一个系统使用多个数据源的场景之中，我们可以通过 2PC/3PC 等手段，同时获得分区容忍性和一致性。著名的 HBase 也是属于 CP 系统。</p></li><li><p>如果放弃一致性（AP without C），意味着我们将假设一旦发生分区，节点之间所提供的数据可能不一致。选择放弃一致性的 AP 系统目前是设计分布式系统的主流选择，因为 P 是分布式网络的天然属性，而 A 通常是建设分布式的目的。目前大多数 NoSQL 库和支持分布式的缓存框架都是 AP 系统，如Redis集群。</p></li></ul><p>CAP、ACID 中讨论的一致性称为“强一致性”（Strong Consistency）。把牺牲了 C 的 AP 系统，叫做“最终一致性”（Eventual Consistency）。它是指，如果数据在一段时间内没有被另外的操作所更改，那它最终将会达到与强一致性过程相同的结果，有时候面向最终一致性的算法，也被称为“乐观复制算法”。</p><h4 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h4><p>BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的结论，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。</p><p>BASE 分别是基本可用性（Basically Available）、柔性事务（Soft State）和最终一致性（Eventually Consistent）的缩写。</p><ul><li>基本可用性（Basically Available）：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。</li><li>柔性事务（Soft State）：允许系统存在中间状态，而该中间状态不会影响系统整体可用性。这里的中间状态就是 CAP 理论中的数据不一致。</li><li>最终一致性（Eventually Consistent）：系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。</li></ul><h2 id="可靠消息队列"><a href="#可靠消息队列" class="headerlink" title="可靠消息队列"></a>可靠消息队列</h2><p>前面这种靠着持续重试来保证可靠性的操作，在计算机中就非常常见，它有个专门的名字，叫做“最大努力交付”（Best-Effort Delivery），比如 TCP 协议中的可靠性保障，就属于最大努力交付。</p><p>支持分布式事务的消息框架，如 RocketMQ，原生就支持分布式事务操作。</p><h2 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h2><p>可靠消息队列虽然能保证最终的结果是相对可靠的，过程也足够简单（相对于 TCC 来说），但整个过程完全没有任何隔离性可言，有一些业务中隔离性是无关紧要的，但有一些业务中缺乏隔离性就会带来许多麻烦。譬如：超售。</p><p>TCC 是另一种常见的分布式事务机制，它是“Try-Confirm-Cancel”三个单词的缩写。</p><p>TCC 的实现过程分为了三个阶段：</p><ul><li>Try：尝试执行阶段，完成所有业务可执行性的检查（保障一致性），并且预留好全部需用到的业务资源（保障隔离性）。</li><li>Confirm：确认执行阶段，不进行任何业务检查，直接使用 Try 阶段准备的资源来完成业务处理。Confirm 阶段可能会重复执行，因此本阶段所执行的操作需要具备幂等性。</li><li>Cancel：取消执行阶段，释放 Try 阶段预留的业务资源。Cancel 阶段可能会重复执行，也需要满足幂等性。</li></ul><p>它是一种业务侵入性较强的事务方案，要求业务处理过程必须拆分为“预留业务资源”和“确认 / 释放消费资源”两个子过程。</p><p>TCC 其实有点类似 2PC 的准备阶段和提交阶段，但 TCC 是位于用户代码层面，而不是在基础设施层面，这为它的实现带来了较高的灵活性，可以根据需要设计资源锁定的粒度。TCC 在业务执行时只操作预留资源，几乎不会涉及锁和资源的争用，具有很高的性能潜力。但是 TCC 并非纯粹只有好处，它也带来了更高的开发成本和业务侵入性，意味着有更高的开发成本和更换事务实现方案的替换成本。</p><p>通常我们并不会完全靠裸编码来实现 TCC，而是基于某些分布式事务中间件（譬如阿里开源的Seata）去完成，尽量减轻一些编码工作量。</p><h2 id="SAGA事务"><a href="#SAGA事务" class="headerlink" title="SAGA事务"></a>SAGA事务</h2><p>TCC 事务具有较强的隔离性，避免了“超售”的问题，而且其性能一般来说是本篇提及的几种柔性事务模式中最高的，但它仍不能满足所有的场景。TCC 的最主要限制是它的业务侵入性很强，不止是它需要开发编码配合所带来的工作量，而更多的是指它所要求的技术可控性上的约束。譬如，网银支付，通常也就无法完成冻结款项、解冻、扣减这样的操作。</p><p>SAGA 事务基于数据补偿代替回滚的解决思路。大致思路是把一个大事务分解为可以交错运行的一系列子事务集合。每个子事务都应该是或者能被视为是原子行为；为每一个子事务设计对应的补偿动作。</p><p>两种恢复策略：<br>正向恢复（Forward Recovery）：T1，T2，…，Ti（失败），Ti（重试）…，Ti+1，…，Tn<br>反向恢复（Backward Recovery）：T1，T2，…，Ti（失败），Ci（补偿），…，C2，C1。</p><p>与 TCC 相比，SAGA 不需要为资源设计冻结状态和撤销冻结的操作，补偿操作往往要比冻结操作容易实现得多。</p><p>SAGA 事务通常也不会直接靠裸编码来实现，一般也是在事务中间件的基础上完成，前面提到的 Seata 就同样支持 SAGA 事务模式。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;周志明《凤凰架构：构建可靠的大型分布式系统》&lt;br&gt;&lt;a href=&quot;https://icyfenix.cn/&quot;&gt;https://icyfenix.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;包括：CAP、BASE理论。实现分布式事务的三种解决方案，可靠消息队列、TCC、SAGA事务。&lt;/p&gt;
&lt;p&gt;可靠消息队列：简单、无法解决隔离性问题&lt;br&gt;TCC：编码实现业务隔离性，但要求技术可控性（预留资源接口），硬编码可以使用Seata&lt;br&gt;SAGA事务：编码实现业务隔离性和补偿机制，不要求技术可控性，硬编码可以使用Seata&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="技术" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="凤凰架构" scheme="http://www.lights8080.com/tags/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84/"/>
    
    <category term="事务" scheme="http://www.lights8080.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>凤凰架构-全局事务和共享事务</title>
    <link href="http://www.lights8080.com/p/53149592.html"/>
    <id>http://www.lights8080.com/p/53149592.html</id>
    <published>2021-08-03T16:00:00.000Z</published>
    <updated>2021-09-07T03:50:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>周志明《凤凰架构：构建可靠的大型分布式系统》<br><a href="https://icyfenix.cn/">https://icyfenix.cn/</a></p><p>XA、JTA、两阶段提交、三阶段提交</p><span id="more"></span><h2 id="全局事务"><a href="#全局事务" class="headerlink" title="全局事务"></a>全局事务</h2><p>在本节里，全局事务被限定为一种<strong>适用于单个服务使用多个数据源场景</strong>的事务解决方案。</p><p>为了解决分布式事务的一致性问题，X/Open组织提出了一套名为X/Open XA（XA 是 eXtended Architecture 的缩写）的处理事务架构，其核心内容是定义了全局的事务管理器（Transaction Manager，用于协调全局事务）和局部的资源管理器（Resource Manager，用于驱动本地事务）之间的通信接口。</p><p>XA 接口是双向的，能在一个事务管理器和多个资源管理器（Resource Manager）之间形成通信桥梁，通过协调多个数据源的一致动作，实现全局事务的统一提交或者统一回滚。</p><p>JTA（Java Transaction API）是基于 XA 模式在 Java 语言中的实现了全局事务处理的标准。</p><p>XA 将事务提交拆分成为两阶段过程，两阶段式提交（2 Phase Commit，2PC）：</p><ul><li>准备阶段（又叫作投票阶段，对于数据库来说，它与本地事务中真正提交的区别只是暂不写入最后一条 Commit Record 而已，并不立即释放隔离性，即仍继续持有锁）</li><li>提交阶段（又叫作执行阶段，对于数据库来说，这个阶段的提交操作应是很轻量的，仅仅是持久化一条 Commit Record 而已，通常能够快速完成）</li></ul><p>缺点：</p><ul><li>单点问题：协调者宕机，所有参与者都必须一直等待</li><li>性能问题：两段提交过程中，所有参与者相当于被绑定成为一个统一调度的整体，期间要经过两次远程服务调用，三次数据持久化（准备阶段写重做日志，协调者做状态持久化，提交阶段在日志写入 Commit Record）</li><li>一致性风险：前面已经提到，两段式提交的成立是有前提条件的，当网络稳定性和宕机恢复能力的假设不成立时，仍可能出现一致性问题。</li></ul><p>为了缓解两段式提交协议的一部分缺陷，具体地说是协调者的单点问题和准备阶段的性能问题，后续又发展出了“三段式提交”（3 Phase Commit，3PC）协议。<br>三段式提交把原本的两段式提交的准备阶段再细分为两个阶段，分别称为 CanCommit、PreCommit，把提交阶段改称为 DoCommit 阶段。</p><h2 id="共享事务"><a href="#共享事务" class="headerlink" title="共享事务"></a>共享事务</h2><p>共享事务（Share Transaction）是指<strong>多个服务共用同一个数据源</strong>。这里有必要再强调一次“数据源”与“数据库”的区别：数据源是指提供数据的逻辑设备，不必与物理设备一一对应。</p><p>如果直接将不同数据源视为不同的数据库，那完全可以用全局事务或者下一讲要学习的分布式事务来实现。</p><p>如果针对每个数据源连接的都是同一个物理数据库的特例，一种理论可行的方案是，直接让各个服务共享数据库连接。同一个应用进程中共享数据库连接并不困难，但不同服务节点共享数据库连接很难做到，为了实现共享事务，就必须新增一个中间角色。</p><p>这在分布式的场景下是个伪需求，你有充足理由让多个微服务去共享数据库，那就必须找到更加站得住脚的理由，来向团队解释拆分微服务的目的是什么。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;周志明《凤凰架构：构建可靠的大型分布式系统》&lt;br&gt;&lt;a href=&quot;https://icyfenix.cn/&quot;&gt;https://icyfenix.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;XA、JTA、两阶段提交、三阶段提交&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="技术" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="凤凰架构" scheme="http://www.lights8080.com/tags/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84/"/>
    
    <category term="事务" scheme="http://www.lights8080.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>大数据中台架构</title>
    <link href="http://www.lights8080.com/p/27c771b.html"/>
    <id>http://www.lights8080.com/p/27c771b.html</id>
    <published>2021-08-01T16:00:00.000Z</published>
    <updated>2021-09-08T10:09:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>以奈学教育大数据架构师训练营为大纲，关于数据仓库的学习笔记</p><span id="more"></span><h2 id="大数据中台架构"><a href="#大数据中台架构" class="headerlink" title="大数据中台架构"></a>大数据中台架构</h2><p><img src="https://gitee.com/lights8080/lights8080-oss/raw/master/2021/08/5BVKI1.jpg" alt="大数据中台架构设计实践"></p><p>大数据中台演进三阶段：</p><p>定位和价值：</p><ul><li>降低数据使用门槛</li><li>提升决策利用效率</li><li>数据驱动业务增长</li></ul><p>第一阶段：</p><ul><li>定位：快速描述业务事实，提供数据分析的原材料</li><li>价值：为决策提供支持，评估业务效果</li><li>形式：数据提取-&gt;数据计算-&gt;数据仓库建设-&gt;指标体系-&gt;报表</li></ul><p>第二阶段：</p><ul><li>定位：波动根因分析</li><li>价值：辅助/诊断业务</li><li>形式：专题分析-&gt;分析框架-&gt;分析工具-&gt;多维分析模型</li></ul><p>第三阶段：</p><ul><li>定位：数据化运营实践落地</li><li>价值：业务数据统计分析-&gt;数据驱动运营闭环-&gt;良性循环</li><li>形式：分析报告</li></ul><p>大数据仓库中台建设目标：</p><ul><li>响应：监视事件计量标准，与历史数据相关联，制定及时的应对策略</li><li>分析：分析盈利价值链，内部运营的状况和风险，外部市场变化</li><li>决策：大数据中找出价值信息，对管理和分析人员精准及时的报告</li><li>计划：预测和趋势分析，感知风险</li></ul><p>大数据仓库中台建设实现功能：</p><ul><li>逻辑分层：数据采集层-&gt;原始数据层-&gt;数据仓库层-&gt;数据集市层-&gt;数据应用层</li><li>数仓规范：开发标准，命名规范，开放的数据存储、建模、计算能力</li><li>主题域划分：一致性维度与事实；业务数据矩阵（明确各业务分析的主题模块、业务过程所属的数据域）</li><li>数据建模：构建维度和事实总线矩阵，维度和事实模型设计；明确统计指标，指标结果表设计；维度总线矩阵（明确维度和业务过程之间的关系）</li><li>数据治理：元数据管理，数据安全，数据治理，数据生命周期管理</li><li>智能分析：数据挖掘（精细化运营、竞对抓取分析、商业广告），实时预测分析，多维根因分析</li></ul><h2 id="数据仓库建模"><a href="#数据仓库建模" class="headerlink" title="数据仓库建模"></a>数据仓库建模</h2><h5 id="事实表"><a href="#事实表" class="headerlink" title="事实表"></a>事实表</h5><p>又叫事实数据表，主要特点是含有大量的数据，并且这些数据是可以汇总，并被记录的。</p><p>表格里存储了能体现实际数据或详细数值，一般由维度编码和事实数据组成。事实表作为数据仓库维度建模的核心，紧紧围绕着业务过程进行设计。</p><p>事实数据表不应该包含描述性的信息，也不应该包含除数字度量字段及使事实与纬度表中对应项的相关索引字段之外的任何数据。</p><p>事实表数据列组成部分：</p><ul><li>键值列</li><li>度量值（分为可以累计的度量值，非累计的度量值）</li></ul><p>事实表分类：</p><ul><li>事务型事实表（每个事务或事件产生一行数据）</li><li>周期型快照事实表（保留固定时间间隔的数据）</li><li>累积型快照事实表（用于跟踪业务事实的变化）</li></ul><h5 id="维度表"><a href="#维度表" class="headerlink" title="维度表"></a>维度表</h5><p>数据仓库中的表，其条目描述事实数据表中的数据。</p><p>表格里存放了具有独立属性和层次结构的数据，一般由维度编码和对应的维度说明组成。</p><p>维度表可以看作是用户来分析数据的窗口，纬度表中包含事实数据表中事实记录的特性，有些特性提供描述性信息，有些特性指定如何汇总事实数据表数据，以便为分析者提供有用的信息，维度表包含帮助汇总数据的特性的层次结构。</p><h4 id="逻辑分层"><a href="#逻辑分层" class="headerlink" title="逻辑分层"></a>逻辑分层</h4><p><img src="https://gitee.com/lights8080/lights8080-oss/raw/master/2021/08/EbqvFO.jpg" alt="离线数据仓库中台系统架构—逻辑分层"></p><ul><li>ODS（操作数据层，Operational Data Store）：将原始数据几乎无处理地存放在数据仓库系统中，看数据量和存储预算决定保留时间</li><li>DM（Data Warehouse）/CDM（数据公共层，Common Dimenions Model）：包括DIM、DWD、DWM、DWS，采取更多的宽表化手段构建公共指标数据层，提升公共指标的复用性，减少重复加工<ul><li>DIM（维表，Dimension）：以维度作为建模驱动</li><li>DWD（明细事实表，Data Warehouse Detail）：以业务过程作为建模驱动，基于每个具体的业务过程特点，构建最细粒度的明细事实表</li><li>DWM（轻度汇总层，Data WareHouse Middle）</li><li>DM（数据集市/宽表，Data Market）/DWS（汇总数据层，Data Warehouse Summary）：以分析的主题对象作为建模驱动</li></ul></li><li>ADS（应用数据层，Application Data Store）：存放数据产品个性化的统计指标数据</li></ul><h5 id="粒度"><a href="#粒度" class="headerlink" title="粒度"></a>粒度</h5><p>粒度就是业务流程中对度量的单位，比如商品是按件记录度量，还是按批记录度量。</p><h5 id="度量"><a href="#度量" class="headerlink" title="度量"></a>度量</h5><p>度量是业务流程节点上的一个数值。比如销量，价格，成本等等。</p><h5 id="宽表"><a href="#宽表" class="headerlink" title="宽表"></a>宽表</h5><p>通常是指业务主题相关的指标、维度、主题属性关联在一起的一张数据库表。</p><h4 id="逻辑分层-业务架构"><a href="#逻辑分层-业务架构" class="headerlink" title="逻辑分层(业务架构)"></a>逻辑分层(业务架构)</h4><p><img src="https://gitee.com/lights8080/lights8080-oss/raw/master/2021/08/4EEWgS.jpg" alt="离线数据仓库中台系统架构—逻辑分层(业务架构)"></p><p>数仓数据分层好处：</p><ul><li>【易维护】高效的数据组织形式，清洗和过滤，规范化，血缘追踪</li><li>【高性能】时间价值，数据集合，维度汇总，查询效率</li><li>【简单化】集成价值，多维度数据整合，多角度多层次的数据分析</li><li>【历史性】历史数据，回溯历史，预测未来</li></ul><h4 id="数据建模"><a href="#数据建模" class="headerlink" title="数据建模"></a>数据建模</h4><p>DWD层需构建维度模型：选择业务过程→声明粒度→确认维度→确认事实</p><h5 id="维度总线矩阵"><a href="#维度总线矩阵" class="headerlink" title="维度总线矩阵"></a>维度总线矩阵</h5><p><img src="https://gitee.com/lights8080/lights8080-oss/raw/master/2021/08/ZOAcu7.jpg" alt="维度总线矩阵"></p><h2 id="Skynet调度中台"><a href="#Skynet调度中台" class="headerlink" title="Skynet调度中台"></a>Skynet调度中台</h2><p><img src="https://gitee.com/lights8080/lights8080-oss/raw/master/2021/08/dFtbBY.jpg" alt="Skynet调度中台—总体架构设计与实践"></p><h2 id="Lambda-VS-Kappa架构"><a href="#Lambda-VS-Kappa架构" class="headerlink" title="Lambda VS Kappa架构"></a>Lambda VS Kappa架构</h2><p><a href="https://www.cnblogs.com/xiaodf/p/11642555.html">https://www.cnblogs.com/xiaodf/p/11642555.html</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://help.aliyun.com/document_detail/126215.html?spm=a2c4g.11186623.6.586.245d38acj9VNpD">阿里云-数仓分层</a><br><a href="https://www.cnblogs.com/shengyang17/p/10558342.html#_lab2_0_1">数据仓库 |1.3 数仓分层| 建模</a><br><a href="https://www.cnblogs.com/shengyang17/p/10545198.html#_lab2_0_1">数据仓库| 1.4 ODS&amp; DWD&amp; DWS&amp;DWT&amp; ADS</a><br><a href="https://blog.csdn.net/u010999396/article/details/68488981">数据仓库事实表和维表</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;以奈学教育大数据架构师训练营为大纲，关于数据仓库的学习笔记&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://www.lights8080.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="大数据" scheme="http://www.lights8080.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    <category term="数据仓库" scheme="http://www.lights8080.com/tags/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"/>
    
    <category term="中台" scheme="http://www.lights8080.com/tags/%E4%B8%AD%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>2107-5-终身成长</title>
    <link href="http://www.lights8080.com/p/a62366c0.html"/>
    <id>http://www.lights8080.com/p/a62366c0.html</id>
    <published>2021-07-29T16:00:00.000Z</published>
    <updated>2021-09-24T10:46:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>如题</p><span id="more"></span><h2 id="话题：《终身成长》"><a href="#话题：《终身成长》" class="headerlink" title="话题：《终身成长》"></a>话题：《终身成长》</h2><p>《终身成长》整本书都在介绍固定型思维模式和成长型思维模式对人产生的影响。</p><p>认真观察身边的人会发现，那些职级高能力强的人，比较符合成长型思维模式；而那些在基层深耕多年的人，更匹配固定型思维模式。虽然会有个例，但是请相信，那些靠运气赢来的，终会凭能力输回去。当然这其中还会有个例存在。</p><p>“只有缺乏天赋的人才需要努力”，曾就一个同事跟我说过类似的话”能力不行才加班“。固定思维的人害怕让别人知道自己不够聪明，还会通过抱怨和责怪别人来保护他们自己，认为别人成功是靠运气而不是努力，常常把自己的问题归于外部因素导致。成长型思维的人承认自己的不完美，愿意听取不同建议。面对挑战的更关注如何提高自己。</p><p>固定型思维的人喜欢包装自己，成长型思维的人喜欢剖析自己。</p><h2 id="语录"><a href="#语录" class="headerlink" title="语录"></a>语录</h2><ol><li><p>固定型思维模式让你更关心别人如何看待你；而成长型思维模式让你更关心你能否提高自己。</p></li><li><p>固定型思维模式者告诉我们：“如果你需要为某事付出努力，那么你肯定不擅长做这件事。”</p></li><li><p>在固定型思维模式者的眼中，努力是有缺陷和不足的人需要做的。</p></li><li><p>固定型思维模式中，无论是肯定的还是否定的标签都会扰乱你的思绪：当你被贴上肯定的标签时，你害怕会失去它；而当你不幸被贴上否定的标签时，你会害怕自己正如标签所说。</p></li><li><p>不把失败看作愚蠢的象征，而是去认识到这是因为自己缺乏经验和技能。</p></li><li><p>成功意味着做到最好的自己，而不是要强于他人；失败是一次机会，而不是死刑；努力是通往成功的关键。</p></li><li><p>考试成绩和对成就的评估只会告诉你目前这个学生处在什么位置，而不会告诉你将来他会达到什么高度。</p></li></ol><h2 id="对话"><a href="#对话" class="headerlink" title="对话"></a>对话</h2><p>菲利普：天呐，我太笨手笨脚了。<br>父亲：我们把钉子撒了的时候，不应该说这样的话。<br>菲利普：那应该说什么呢？<br>父亲：你应该说，钉子撒了——我要把它们捡起来！<br>菲利普：就这样？<br>父亲：就这样。<br>菲利普：谢谢，爸爸。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如题&lt;/p&gt;</summary>
    
    
    
    <category term="weekly" scheme="http://www.lights8080.com/categories/weekly/"/>
    
    
    <category term="weekly" scheme="http://www.lights8080.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>凤凰架构-本地事务</title>
    <link href="http://www.lights8080.com/p/4bfa4595.html"/>
    <id>http://www.lights8080.com/p/4bfa4595.html</id>
    <published>2021-07-29T16:00:00.000Z</published>
    <updated>2021-09-07T03:50:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>周志明《凤凰架构：构建可靠的大型分布式系统》<br><a href="https://icyfenix.cn/">https://icyfenix.cn/</a></p><p>包括：ACID、如何实现原子性和持久性、如何实现隔离性、事务隔离级别、多版本并发控制-MVCC、悲观锁和乐观锁</p><span id="more"></span><h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><ul><li>一致性（Consistency）：保证系统中所有的数据都是符合期望的，且相互关联的数据之间不会产生矛盾。</li><li>原子性（Atomic）：在同一项业务处理过程中，事务保证了对多个数据的修改，要么同时成功，要么同时被撤销。</li><li>隔离性（Isolation）：在不同的业务处理过程中，事务保证了各自业务正在读、写的数据互相独立，不会彼此影响。</li><li>持久性（Durability）：事务应当保证所有成功被提交的数据修改都能够正确地被持久化，不丢失数据。</li></ul><p>原子性，隔离性和持久性是数据库的属性，是手段，而一致性（在ACID意义上）是应用程序的属性，是目的。应用可能依赖数据库的原子性和隔离属性来实现一致性，但这并不仅取决于数据库。</p><p>本地事务是最基础的一种事务处理方案，通常只<strong>适用于单个服务使用单个数据源的场景</strong>，它是直接依赖于数据源（通常是数据库系统）本身的事务能力来工作的。</p><h2 id="如何实现原子性和持久性"><a href="#如何实现原子性和持久性" class="headerlink" title="如何实现原子性和持久性"></a>如何实现原子性和持久性</h2><p>实现原子性和持久性的最大困难是“写入磁盘”这个操作并不是原子的（比如要写入到不同的磁盘块上），不仅有“写入”与“未写入”状态，还客观地存在着“正在写”的中间状态。</p><p><strong>未提交事务，写入后崩溃</strong>，要将已经修改过的数据从磁盘中恢复成没有改过的样子，以保证原子性。<br><strong>已提交事务，写入前崩溃</strong>，要将没来得及写入磁盘的数据重新写入，以保证持久性。</p><p>由于写入中间状态与崩溃都是无法避免的，为了保证原子性和持久性，就只能在崩溃后采取恢复的补救措施，这种数据恢复操作被称为“崩溃恢复”。</p><p>为了能够顺利地完成崩溃恢复，会以日志的形式先记录到磁盘，日志记录全部落盘后为Commit Record，表示事务成功。根据日志上的信息对真正的数据进行修改，修改完成后为End Record，表示事务已完成持久化。这种事务实现方法被称为Commit Logging。</p><p>Commit Logging的原理很清晰，但缺陷是，即使磁盘 I/O 有足够空闲、即使某个事务修改的数据量非常庞大，都不允许在事务提交前就修改磁盘上的真实数据，这对提升数据库的性能是否不利。<br>为了解决这个问题，ARIES提出所谓“提前写入”（Write-Ahead），就是允许在事务提交之前，提前写入变动数据的意思。</p><p>按照事务提交时点为界，划分为 FORCE 和 STEAL 两类情况：</p><ul><li>FORCE：当事务提交后，要求变动数据必须同时完成写入。</li><li>NO-FORCE：当事务提交后，不强制变动数据必须同时完成写入。</li><li>STEAL：在事务提交前，允许变动数据提前写入。</li><li>NO-STEAL：在事务提交前，不允许变动数据提前写入。(从优化磁盘 I/O 性能考虑，没有必要强制数据写入立即进行)</li></ul><p>从优化磁盘 I/O 性能考虑，没有必要强制数据写入立即进行。允许数据提前写入（NO-STEAL），有利于利用空闲 I/O 资源，也有利于节省数据库缓存区的内存。<br>从优化磁盘 I/O 的角度看，NO-FORCE + STEAL 组合的性能无疑是最高的；从算法实现与日志的角度看 NO-FORCE + STEAL 组合的复杂度无疑也是最高的。<br><img src="https://gitee.com/lights8080/lights8080-oss/raw/master/2021/07/sbc3jM.jpg" alt="FORCE 和 STEAL 的四种组合关系"></p><p>Write-Ahead Logging 允许 NO-FORCE，也允许 STEAL。解决办法是增加了另一种被称为 Undo Log 的日志类型，当变动数据写入磁盘前，必须先记录 Undo Log，以便在事务回滚或者崩溃恢复时根据 Undo Log 对提前写入的数据变动进行擦除。<br>崩溃恢复时会执行以下三个阶段的操作：分析阶段（Analysis）、重做阶段（Redo）、回滚阶段（Undo）。</p><h2 id="如何实现隔离性"><a href="#如何实现隔离性" class="headerlink" title="如何实现隔离性"></a>如何实现隔离性</h2><p>隔离性保证了每个事务各自读、写的数据互相独立，不会彼此影响。</p><p>串行的数据访问，具有天然的隔离性，现代数据库都提供了以下三种锁：</p><ul><li>写锁（Write Lock，也叫做排他锁，简写为 X-Lock）：只有持有写锁的事务才能对数据进行写入操作，数据加持着写锁时，其他事务不能写入数据，也不能施加读锁。</li><li>读锁（Read Lock，也叫做共享锁，简写为 S-Lock）：多个事务可以对同一个数据添加多个读锁，数据被加上读锁后就不能再被加上写锁，所以其他事务不能对该数据进行写入，但仍然可以读取。对于持有读锁的事务，如果该数据只有一个事务加了读锁，那可以直接将其升级为写锁，然后写入数据。</li><li>范围锁（Range Lock）：对于某个范围直接加排他锁，在这个范围内的数据不能被读取，也不能被写入。</li></ul><p><strong>本地事务的四种隔离级别</strong></p><ul><li>可串行化（Serializable）：隔离性级别最高，对事务所有读、写的数据全都加上读锁、写锁和范围锁即可（这种可串行化的实现方案称为 Two-Phase Lock - 2PL）。</li><li>可重复读（Repeatable Read）：对事务所涉及到的数据加读锁和写锁，并且一直持续到事务结束，但不再加范围锁。可重复读比可串行化弱化的地方在于幻读问题</li><li>读已提交（Read Committed）：对事务涉及到的数据加的写锁，会一直持续到事务结束，但加的读锁在查询操作完成后就马上会释放。读已提交比可重复读弱化的地方在于不可重复读问题</li><li>读未提交（Read Uncommitted）：对事务涉及到的数据只加写锁，这会一直持续到事务结束，但完全不加读锁。读未提交比读已提交弱化的地方在于脏读问题</li></ul><p><strong>事务隔离级别解决的问题</strong></p><ul><li>幻读问题：事务执行的过程中，两个完全相同的范围查询得到了不同的结果集</li><li>不可重复读问题：在事务执行过程中，对同一行数据的两次查询得到了不同的结果</li><li>脏读问题：在事务执行的过程中，一个事务读取到了另一个事务未提交的数据</li></ul><p><strong>多版本并发控制”（Multi-Version Concurrency Control，MVCC）</strong><br>这种“一个事务读 + 另一个事务写”的隔离问题，有一种名为“多版本并发控制”的无锁优化方案被主流的商业数据库广泛采用。</p><p>MVCC 的基本思路是对数据库的任何修改都不会直接覆盖之前的数据，而是产生一个新版副本与老版本共存，以此达到读取时可以完全不加锁的目的。</p><ul><li>隔离级别是可串行化：可串行化本来的语义就是要阻塞其他事务的读取操作，与MVCC无锁优化冲突。</li><li>隔离级别是可重复读：总是读取 CREATE_VERSION 小于或等于当前事务 ID 的记录，在这个前提下，如果数据仍有多个版本，则取最新（事务 ID 最大）的。</li><li>隔离级别是读已提交：总是取最新的版本即可，即最近被 Commit 的那个版本的数据记录。</li><li>隔离级别是读未提交：直接修改原始数据即可，其他事务查看数据的时候立刻可以查看到，无需版本控制。</li></ul><p>MVCC 是只针对“读 + 写”场景的优化，如果是两个事务同时修改数据，即“写 + 写”的情况，那就没有多少优化的空间了，加锁几乎是唯一可行的解决方案，分为悲观锁和乐观锁。</p><ul><li><strong>“悲观锁（悲观并发控制）”</strong>：认为事务之间数据存在竞争是必然情况，竞争越剧烈，性能越好。（即基于锁的并发控制，比如2PL）</li><li><strong>“乐观锁（乐观并发控制）”</strong>：认为事务之间数据存在竞争是偶然情况，竞争越剧烈，性能越差。（基本思路是提交事务前检查有没有更改，如果有就放弃修改并重试）</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;周志明《凤凰架构：构建可靠的大型分布式系统》&lt;br&gt;&lt;a href=&quot;https://icyfenix.cn/&quot;&gt;https://icyfenix.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;包括：ACID、如何实现原子性和持久性、如何实现隔离性、事务隔离级别、多版本并发控制-MVCC、悲观锁和乐观锁&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="技术" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="凤凰架构" scheme="http://www.lights8080.com/tags/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84/"/>
    
    <category term="事务" scheme="http://www.lights8080.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>凤凰架构-RPC vs REST</title>
    <link href="http://www.lights8080.com/p/dcd4b9cd.html"/>
    <id>http://www.lights8080.com/p/dcd4b9cd.html</id>
    <published>2021-07-25T16:00:00.000Z</published>
    <updated>2021-09-07T03:49:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>周志明《凤凰架构：构建可靠的大型分布式系统》<br><a href="https://icyfenix.cn/">https://icyfenix.cn/</a></p><p>RPC发展史、REST风格的面向资源编程思想</p><span id="more"></span><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>RPC出现的最初目的，就是为了让计算机能够跟调用本地方法一样去调用远程方法。</p><p>进程间通信（Inter-Process Communication，IPC）方法：</p><ul><li>管道（Pipe）：类似于两个进程间的桥梁，传递少量的字符流和字节流。如：ps -ef | grep java</li><li>信号（Signal）：通知目标进程有某种事件发生。如：kill -9 pid</li><li>信号量（Semaphore）：信号量用于两个进程之间同步协作手段。如：wait(),notify()</li><li>消息队列（Message Queue）：以上三种方式只适合传递传递少量信息，消息队列用于进程间数据量较多的通信。</li><li>共享内存（Shared Memory）：允许多个进程访问同一块公共的内存空间，这是效率最高的进程间通信形式。</li><li>套接字接口（Socket）：以上两种方式只适合单机多进程间的通信，套接字接口是更为普适的进程间通信机制，可用于不同机器之间的进程通信。</li></ul><h3 id="通信的成本"><a href="#通信的成本" class="headerlink" title="通信的成本"></a>通信的成本</h3><p>最后一种基于套接字接口的通信方式（IPC Socket），它不仅适用于本地相同机器的不同进程间通信，由于 Socket 是网络栈的统一接口，它也理所当然地能支持基于网络的跨机器的进程间通信。</p><p>由于 Socket 是各个操作系统都有提供的标准接口，完全有可能把远程方法调用的通信细节隐藏在操作系统底层，从应用层面上看来可以做到远程调用与本地的进程间通信在编码上完全一致。但这种透明的调用形式却反而造成了程序员误以为通信是无成本的假象。</p><p>在“透明的 RPC 调用”一度成为主流范式的时候，Andrew Tanenbaum教授对此提出了一系列质问。论文的中心观点是：本地调用与远程调用当做一样处理，这是犯了方向性的错误，把系统间的调用做成透明，反而会增加程序员工作的复杂度。</p><p>透明通信的支持者有之，反对者有之，经过此后几年的发展，逐渐证明了Andrew Tanenbaum教授的预言是正确的。最终大佬们共同总结了通过网络进行分布式运算的八宗罪。</p><p>潜台词就是如果远程服务调用要弄透明化的话，就必须为这些罪过买单。至此，RPC 应该是一种高层次的或者说语言层次的特征，而不是像 IPC 那样，是低层次的或者说系统层次的特征成为工业界、学术界的主流观点。</p><h3 id="RPC三个基本问题"><a href="#RPC三个基本问题" class="headerlink" title="RPC三个基本问题"></a>RPC三个基本问题</h3><ul><li>如何表示数据：就是序列化与反序列化。Web Service 的XML Serialization</li><li>如何传递数据：通常指的是应用层协议，实际传输一般是基于标准的 TCP、UDP 等标准的传输层协议来完成的。Web Service 的Simple Object Access Protocol（SOAP）</li><li>如何确定方法：一套语言无关的接口描述语言。Web Service 的Web Service Description Language（WSDL）</li></ul><h3 id="RPC的统一和分裂"><a href="#RPC的统一和分裂" class="headerlink" title="RPC的统一和分裂"></a>RPC的统一和分裂</h3><h4 id="统一"><a href="#统一" class="headerlink" title="统一"></a>统一</h4><p>CORBA本身设计得实在是太过于啰嗦繁琐，制定的规范晦涩难懂脱离实际，没有把握住统一 RPC 的大好机遇。</p><p>后来XML 1.0 发布，并成为W3C的推荐标准，随后SOAP 1.0规范的发布，它代表着一种被称为“Web Service”的全新的 RPC 协议的诞生。随后提交给 W3C 投票成为国际标准，所以也被称为W3C Web Service。Web Service 采用了 XML 作为远程过程调用的序列化、接口描述、服务发现等所有编码的载体。</p><p>Web Service 的一大缺点是它那过于严格的数据和接口定义所带来的性能问题，XML本身信息密度就相对低下，Web Service又是跨语言的 RPC 协议，一个简单的字段为了不会产生歧义，XML严格描述的话，往往比原来多出几十倍的空间。<br>另外一点是，它希望在一套协议上一揽子解决分布式计算中可能遇到的所有问题，除它本身包括的 SOAP、WSDL、UDDI 协议外，还有一堆WS-*命名的、用于解决事务、一致性、事件、通知、业务描述、安全、防重放等子功能协议，这对开发者造成了非常沉重的学习负担。</p><h4 id="分裂"><a href="#分裂" class="headerlink" title="分裂"></a>分裂</h4><p>由于一直没有一个同时满足以上三点的“完美 RPC 协议”出现。今时今日，任何一款具有生命力的 RPC 框架，都不再去追求大而全的“完美”，而是有自己的针对性特点作为主要的发展方向。</p><ul><li>朝着面向对象发展：RMI（Sun/Oracle）、.NET Remoting</li><li>朝着性能发展，代表为 gRPC（Google）、Thrift（Facebook/Apache）</li><li>朝着简化发展，代表为 JSON-RPC</li></ul><p>到了最近几年，RPC 框架有明显的朝着更高层次（不仅仅负责调用远程服务，还管理远程服务）与插件化方向发展的趋势，不再追求独立地解决 RPC 的全部三个问题（表示数据、传递数据、表示方法），而是将一部分功能设计成扩展点，让用户自己去选择。<br>框架聚焦于提供核心的、更高层次的能力，譬如提供负载均衡、服务注册、可观察性等方面的支持。这一类框架的代表有 Facebook 的 Thrift 与阿里的 Dubbo。</p><h2 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h2><p>REST并不是一种远程服务调用协议，它甚至就不是一种协议。虽然它有一些指导原则，但实际上并不受任何强制的约束。经常会有人批评说，某个系统接口“设计得不够 RESTful”，其实这句话本身就有些争议。因为 REST 只能说是一种风格。</p><p>REST是“表征状态转移”（Representational State Transfer）的缩写。可以理解为是“HTT”（Hyper Text Transfer，超文本传输）的进一步抽象，它们就像是接口与实现类之间的关系。</p><p>REST中关键概念：（以阅读文章为例）</p><ul><li>资源（Resource）：可以将其视作是某种信息、数据。如：文章的内容，无论是网页还是报纸，你阅读的仍是同一个“资源”</li><li>表征（Representation）：指信息与用户交互时的表示形式。如：文章的PDF、Markdown等表现形式</li><li>状态（State）：在特定语境中才能产生的上下文信息就被称为“状态”。如：请求“下一篇”文章，依赖当前正在阅读的文章</li><li>转移（Transfer）：服务器通过某种方式，把“用户当前阅读的文章”转变成“下一篇文章”，这就被称为“表征状态转移”</li></ul><h3 id="RESTful的系统"><a href="#RESTful的系统" class="headerlink" title="RESTful的系统"></a>RESTful的系统</h3><p>REST风格的系统应该满足以下六大原则</p><ul><li>服务端与客户端分离（Client-Server）</li><li>无状态（Stateless）</li><li>可缓存（Cacheability）</li><li>分层系统（Layered System）</li><li>统一接口（Uniform Interface）</li><li>按需代码（Code-On-Demand）</li></ul><p>REST以资源为主体进行服务设计的风格，带来了什么好处：</p><ul><li>降低的服务接口的学习成本</li><li>资源天然具有集合与层次结构</li><li>REST 绑定于 HTTP 协议</li></ul><p>RMM成熟度模型</p><ul><li>0级. The Swamp of Plain Old XML：完全不REST，是RPC的风格</li><li>1级. Resources：引入资源的概念</li><li>2级. HTTP Verbs：引入统一接口，映射到HTTP协议的方法上（目前大部分的系统能够达到的REST界别）</li><li>3级. Hypermedia Controls：“超文本驱动”，除了第一个请求是地址栏输入驱动以外，后续请求应该自己描述清楚后续可能发生的状态转移，由超文本自身来驱动。</li></ul><p>编程思想的立场不同：</p><ul><li>面向过程编程时，为什么要以算法和处理过程为中心，输入数据，输出结果？当然是为了符合计算机世界中主流的交互方式。</li><li>面向对象编程时，为什么要将数据和行为统一起来、封装成对象？当然是为了符合现实世界的主流的交互方式。</li><li>面向资源编程时，为什么要将数据（资源）作为抽象的主体，把行为看作是统一的接口？当然是为了符合网络世界的主流的交互方式。</li></ul><h2 id="RPC-vs-REST"><a href="#RPC-vs-REST" class="headerlink" title="RPC vs REST"></a>RPC vs REST</h2><p>REST 与 RPC 在思想上差异的核心是抽象的目标不一样，即面向资源的编程思想与面向过程的编程思想两者之间的区别。</p><p>至于使用范围，REST 与 RPC 作为主流的两种远程调用方式，在使用上是确有重合的，但重合的区域有多大就见仁见智了。</p><p>RPC一些发展方向，如分布式对象、提升调用效率、简化调用复杂性。</p><ul><li>分布式对象：这一条线的应用与 REST 可以说是毫无关联；</li><li>提升调用效率：REST提升传输效率的潜力有限，对于传输协议、序列化器这两点都不会有什么选择的权力</li><li>简化调用复杂性：追求简化调用的场景，众多 RPC 里也就 JSON-RPC 有机会与 REST 竞争</li></ul><p>我们今天再去看这两种编程思想，虽然它们出现的时间有先后，但在人类使用计算机语言来处理数据的工作中，无论用哪种思维来抽象问题都是合乎逻辑的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;周志明《凤凰架构：构建可靠的大型分布式系统》&lt;br&gt;&lt;a href=&quot;https://icyfenix.cn/&quot;&gt;https://icyfenix.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RPC发展史、REST风格的面向资源编程思想&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="技术" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="凤凰架构" scheme="http://www.lights8080.com/tags/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84/"/>
    
    <category term="RPC" scheme="http://www.lights8080.com/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>2107-4-风险意识</title>
    <link href="http://www.lights8080.com/p/8acff730.html"/>
    <id>http://www.lights8080.com/p/8acff730.html</id>
    <published>2021-07-22T16:00:00.000Z</published>
    <updated>2021-09-29T05:36:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>如题</p><span id="more"></span><h2 id="话题：风险意识"><a href="#话题：风险意识" class="headerlink" title="话题：风险意识"></a>话题：风险意识</h2><p>试想一下，如果你下班坐地铁，列车走到一半突然停了，车厢开始渗水，开始淹过膝盖，腰部，胸口，一直到你的脖子，只能靠仰头呼吸，甚至呼吸都变得困难了。你认为这是开玩笑吗？这是真实的河南暴雨亲历者故事。</p><p>这真有点像灾难片了《地铁惊魂》。</p><p>现在的我们不用为饿肚子发愁，不用考虑突然被猛兽攻击，热了有空调，冷了有暖气。我们误以为我们已经足够强大，可以抵御任何风险。然而，灾难来临时真的不会跟你打招呼。</p><p>对于个人来讲，遇到突发情况，在救援人员赶到之前，我们能做的只有自救，然后在自己没有危险的情况下帮助他人。</p><p>我喜欢发散性思考或者叫没事儿瞎寻思的人。<br>比如坐公交我有想过如果撞车会发生什么？站立在什么位置更安全。<br>比如开车前面突然出现了人，该如何操作？到路口之前，我都是有意识的把脚放到刹车上，现在已养成习惯。<br>我甚至还想过，如果坐飞机出现突发情况，我该如何自救（虽然我也知道这无济于事，但我确实脑补过这个场景）。</p><p>这可能跟我喜欢看灾难片有关。<br>我想说风险无法预知，面对风险，你早一步，危险的几率就会下降很多。风险意识，就尽可能的让我们早这一步。当然能做到避免风险，那就更好了。</p><p>PS：我上下班的交通路径有三种，平时只会走最优的那条线，遇到突发情况（封站、人员滞留等），会立马切换到别的路径上，基本不会迟到。</p><h2 id="语录"><a href="#语录" class="headerlink" title="语录"></a>语录</h2><ol><li><p>我现在不和人争吵了，因为我开始意识到，每个人只能在他的认知水平基础上去思考，以后有人告诉我2+2等于10，我会说，你真厉害，你完全正确。<br>——马斯克</p></li><li><p>如果你从太空看地球，它会改变你。它改变了你与这个星球和人类的关系。我想参加这次飞行，因为这是我一生都想做的事情。<br>——贝索斯</p></li><li><p>自知者不怨人，知命者不怨天；怨人者穷，怨天者无志。<br>——荀子荣辱</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;如题&lt;/p&gt;</summary>
    
    
    
    <category term="weekly" scheme="http://www.lights8080.com/categories/weekly/"/>
    
    
    <category term="weekly" scheme="http://www.lights8080.com/tags/weekly/"/>
    
  </entry>
  
</feed>
