<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>七路灯</title>
  
  <subtitle>人的一生应当有许多停靠站，但愿每一个站台都有一盏雾中的灯。</subtitle>
  <link href="http://www.lights8080.com/atom.xml" rel="self"/>
  
  <link href="http://www.lights8080.com/"/>
  <updated>2021-09-24T08:04:16.000Z</updated>
  <id>http://www.lights8080.com/</id>
  
  <author>
    <name>七路灯</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2109-4-不要为了运动而运动</title>
    <link href="http://www.lights8080.com/p/57bfb88c.html"/>
    <id>http://www.lights8080.com/p/57bfb88c.html</id>
    <published>2021-09-23T16:00:00.000Z</published>
    <updated>2021-09-24T08:04:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>如题</p><span id="more"></span><h2 id="话题：不要为了运动而运动"><a href="#话题：不要为了运动而运动" class="headerlink" title="话题：不要为了运动而运动"></a>话题：不要为了运动而运动</h2><p>现在这个天气比较舒适，中午经常有一伙儿人在楼下打羽毛球，我有时间都会在楼下趴会儿。<br>我有个同事想法就不一样，他觉得运动就是跑跑跳跳，多累啊，出一身汗，还要换衣服在上班，还不如上去睡会儿觉。<br>我不能说他说的有毛病，运动确实很累人，出一身汗，很麻烦。</p><p>我现在每周坚持游泳，游完确实很累，不想动，心想累死我了，再也不去了。练了这么久自由泳还总是呛水，太难受了。<br>但转天总有一股劲儿逼迫着你去坚持，虽然身体很酸爽，但心里总痒痒。</p><p>“””<br>啊呀快累死了<br>没时间啊<br>忘记了<br>之前没有弄过啊不会<br>“””<br>据我有限的观察，一些善于找借口的人从不热爱运动，反过来说就是热爱运动的人遇到问题，更愿意思考，承担责任，去提高自己。<br>当然我没有查任何的理论依据，随意反驳。<br>你可以说找借口是一种自我保护的方法，不背锅。我认同，但我真觉得这对个人成长来说没有任何好处。</p><p>村上春树说：今天不想跑，所以才去跑。</p><p>刘翔从小训练都是8步上栏，但为了加强前面三栏的速度，改为7步上栏，这比重新开始学跨栏还要难，为了追求快那0.01秒的速度。<br>之前看过一个2020年的残奥会比赛剪辑，当你想要放弃的时候看一看，看看他们面对困难，面对竞争，是如何做的。</p><p>不运动的理由有千万种，但运动的理由就一个坚持，永不放弃，突破自我的精神。<br>运动的魅力，就是通过每天提高一点点，追求最好的自己的过程。</p><p>运动的目的是追求最好的自己，不要为了运动而运动，你坚持不下来。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如题&lt;/p&gt;</summary>
    
    
    
    <category term="weekly" scheme="http://www.lights8080.com/categories/weekly/"/>
    
    
    <category term="weekly" scheme="http://www.lights8080.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>大数据框架汇总</title>
    <link href="http://www.lights8080.com/p/f2ce654.html"/>
    <id>http://www.lights8080.com/p/f2ce654.html</id>
    <published>2021-09-17T16:00:00.000Z</published>
    <updated>2021-09-18T11:09:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>大数据平台相关框架汇总。<br>包括：Hadoop、Hbase、Pig、Hive、Spark、Strom、Flink、Presto、Atlas、SuperSet、Cassandra、ClickHouse等</p><span id="more"></span><h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h2><p>Hadoop是一个开源框架，允许使用简单的编程模型在跨计算机集群的分布式环境中存储和处理大数据。</p><p>Hadoop框架包括以下四个模块：</p><ul><li>Hadoop Common： 这些是其他Hadoop模块所需的Java库和实用程序。这些库提供文件系统和操作系统级抽象，并包含启动Hadoop所需的必要Java文件和脚本。</li><li>Hadoop YARN： 这是作业调度和群集资源管理的框架。</li><li>Hadoop分布式文件系统（HDFS）： 一种分布式文件系统，可提供对应用程序数据的高吞吐量访问。</li><li>Hadoop MapReduce： 这是用于并行处理大型数据集的基于YARN的系统。</li></ul><h2 id="Hbase"><a href="#Hbase" class="headerlink" title="Hbase"></a>Hbase</h2><p>HBase是一个数据模型，基于 Apache Hadoop 和 BigTable 概念的宽列存储，旨在提供对大量结构化数据的快速随机访问。<br>HBase是一个面向列的建立在HDFS之上的非关系型数据库，利用了Hadoop文件系统（HDFS）提供的容错功能。<br>面向列的数据库是为巨大的表而设计的，对半结构化和结构化数据很有用，适用于在线分析处理（OLAP）。</p><h2 id="Flume"><a href="#Flume" class="headerlink" title="Flume"></a>Flume</h2><p>Apache Flume是一种分布式，高可靠和高可用的服务，可以有效采集、聚合和传输大量的日志数据。</p><p>Flume具有可调的可靠性机制和许多故障转移和恢复机制，主要用于将各种源的流数据传输到HDFS。</p><h2 id="Pig"><a href="#Pig" class="headerlink" title="Pig"></a>Pig</h2><p>由Yahoo开发，Apache Pig是对MapReduce的一种抽象。可以处理结构化，非结构化和半结构化的数据，分析结构化和半结构化的数据，并将结果存储在HDFS中。</p><p>Pig提供了一种称为 Pig Latin 的高级语言，不需要编译，执行时，每个操作符都在内部转换为MapReduce作业。</p><p>它提供了许多操作符来执行连接、排序、文件管理等操作，还提供了其他编程语言的自定义函数（UDF）功能，嵌入到Pig脚本中。</p><h2 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h2><p>由Facebook开发，Hive是一个数据仓库基础设施工具，用于处理Hadoop中的结构化数据。它位于Hadoop的顶部，用于汇总大数据，并使查询和分析变得轻松。</p><p>Hive提供用于查询的SQL类型语言，称为HiveQL或HQL，内部将HQL查询转换为执行MapReduce操作。</p><h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><p>Apache Spark是一款快速集群计算，专为快速计算而设计。它建立在Hadoop MapReduce之上，它扩展了MapReduce模型以有效地使用更多类型的计算，其中包括交互式查询和流处理。</p><p>Spark的主要特点是其内存集群计算 ，通过减少对磁盘的读/写操作，将中间处理数据存储在内存中，提高应用程序的处理速度。</p><p>包括以下四个组件：</p><ul><li>Apache Spark Core：Spark平台的基础通用执行引擎，其所有其他功能都是基于该平台执行的</li><li>Spark SQL：提供了对结构化和半结构化数据的支持</li><li>Spark Streaming：利用Spark Core的快速调度功能来执行流式分析</li><li>MLlib：分布式机器学习框架</li><li>GraphX：分布式图形处理框架</li></ul><p>弹性分布式数据集（RDD）是Spark的基础数据结构，它是一个不可变的分布式对象集合。<br>Spark利用RDD的概念来实现更快更高效的MapReduce操作。</p><p>Apache Spark是用 Scala编程语言 编写的。为了用Spark支持Python，Apache Spark社区发布了一个工具PySpark。</p><h2 id="Storm"><a href="#Storm" class="headerlink" title="Storm"></a>Storm</h2><p>Apache Storm是一个分布式实时大数据处理系统。Storm设计用于以容错和水平可伸缩方法处理大量数据。虽然Storm是无状态的，但它通过Apache ZooKeeper管理分布式环境和集群状态。</p><p>Hadoop和Storm框架用于分析大数据，Storm执行除持久性以外的所有操作，而Hadoop擅长于一切，但缺乏实时计算。</p><h2 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h2><p>Apache Flink是一个同时面向数据流处理和批量数据处理的开源框架和分布式处理引擎，具有高吞吐、低延迟、高扩展、支持容错等特性，用于对无界和有界数据流进行有状态计算。</p><p>可以运行在包括 YARN、 Mesos、Kubernetes 在内的多种资源管理框架上。</p><h3 id="Flink-常见的几类应用"><a href="#Flink-常见的几类应用" class="headerlink" title="Flink 常见的几类应用"></a>Flink 常见的几类应用</h3><p>事件驱动型应用、数据分析应用、数据管道应用</p><h4 id="事件驱动型应用"><a href="#事件驱动型应用" class="headerlink" title="事件驱动型应用"></a>事件驱动型应用</h4><p>事件驱动型应用是一类具有状态的应用，它从一个或多个事件流提取数据，并根据到来的事件触发计算、状态更新或其他外部动作。</p><p>事件驱动型应用是在计算存储分离的传统应用基础上进化而来。在传统架构中，应用需要读写远程事务型数据库。</p><p>典型的事件驱动型应用实例：反欺诈、异常检测、基于规则的报警、业务流程监控</p><h4 id="数据分析应用"><a href="#数据分析应用" class="headerlink" title="数据分析应用"></a>数据分析应用</h4><p>数据分析任务需要从原始数据中提取有价值的信息和指标。传统的分析方式通常是利用批查询，或将事件记录下来并基于此有限数据集构建应用来完成。</p><p>Flink 为持续流式分析和批量分析都提供了良好的支持。内置了SQL接口，将批、流查询的语义统一起来。</p><h4 id="数据管道应用"><a href="#数据管道应用" class="headerlink" title="数据管道应用"></a>数据管道应用</h4><p>提取-转换-加载（ETL）是一种在存储系统之间进行数据转换和迁移的常用方法。ETL 作业通常会周期性地触发，将数据从事务型数据库拷贝到分析型数据库或数据仓库。</p><p>Flink 为多种数据存储系统（如：Kafka、Kinesis、Elasticsearch、JDBC数据库系统等）内置了连接器</p><h2 id="mapReduce、pig-hive、spark-storm、flink"><a href="#mapReduce、pig-hive、spark-storm、flink" class="headerlink" title="mapReduce、pig/hive、spark/storm、flink"></a>mapReduce、pig/hive、spark/storm、flink</h2><p>第一代计算引擎 mapReduce：<br>用于批处理，是计算引擎的先驱，开发效率低，开发时间成本太大</p><p>第二代计算引擎 pig/hive：<br>对hadoop进行了嵌套，其存储基于hdfs，计算基于mr，降低了mr的编写编写成本<br>pig有自己的脚本语言，可以处理非结构化、半结构化和结构化数据，比hive更加的灵活<br>hive属于类sql语法，仅支持处理结构化数据</p><p>第三代计算引擎 spark/storm：<br>解决实时处理的需求，低延迟高吞吐量。</p><p>第四代计算引擎 flink：<br>为流式计算而生属于每一条数据触发计算，在性能的消耗低于storm，吞吐量高于storm，延时低于storm，并且比storm更加易于编写</p><h2 id="Sqoop"><a href="#Sqoop" class="headerlink" title="Sqoop"></a>Sqoop</h2><p>它用于在HDFS和RDBMS之间导入和导出数据。</p><h2 id="Presto"><a href="#Presto" class="headerlink" title="Presto"></a>Presto</h2><p>Presto是Facebook开源的分布式SQL查询引擎，规模可以支持GB到PB级，主要应用于处理秒级的查询场景。内存中计算。优点是快，跨数据源查询</p><p>Hive针对查询吞吐量进行了优化，而Presto针对延迟进行了优化。<br>Presto受最大内存限制，如果超过最大内存，查询就会失败。<br>对于交互式查询可以接受，对于必须可靠运行的日报/周报，他是不合适的，Hive会更好。</p><h2 id="Atlas"><a href="#Atlas" class="headerlink" title="Atlas"></a>Atlas</h2><p>Apache Atlas提供了开放元数据管理和治理能力，以建立其数据资产目录，对这些资产进行分类和治理。</p><p>开箱即用的元数据源集成：HBase、Hive、Sqoop、Storm、Kafka</p><h2 id="SuperSet"><a href="#SuperSet" class="headerlink" title="SuperSet"></a>SuperSet</h2><p>Apache Superset 是一个现代数据探索和可视化平台。<br>是一个现代轻量级的BI分析工具，功能强大且易于使用、轻量级且可扩展、与现代数据库集成、丰富的可视化和仪表板。</p><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p>Apache Kafka 是一个开源分布式事件流平台，高吞吐量、弹性扩展、永久存储、高可用。</p><h2 id="Cassandra"><a href="#Cassandra" class="headerlink" title="Cassandra"></a>Cassandra</h2><p>由Facebook开发，Cassandra是一套开源分布式NoSQL数据库系统，基于 BigTable 和 DynamoDB 思想的宽列存储。</p><p>HBase vs Cassandra<br><a href="https://appinventiv.com/blog/hbase-vs-cassandra/">https://appinventiv.com/blog/hbase-vs-cassandra/</a></p><p>当你需要分析大数据或执行聚合时请使用HBase，如果强调交互式数据和实时事务处理，可以使用 Cassandra。</p><h2 id="ClickHouse"><a href="#ClickHouse" class="headerlink" title="ClickHouse"></a>ClickHouse</h2><p>ClickHouse是一个快速的开源 OLAP 数据库管理系统，它是面向列的，允许使用 SQL 查询实时生成分析报告。</p><h2 id="ETL"><a href="#ETL" class="headerlink" title="ETL"></a>ETL</h2><p>ETL是将业务系统的数据经过抽取（Extract）、清洗转换（Transform）之后加载（Load）到数据仓库的过程，目的是将企业中的分散、零乱、标准不统一的数据整合到一起，为企业的决策提供分析依据。</p><h2 id="ELK"><a href="#ELK" class="headerlink" title="ELK"></a>ELK</h2><p>ElasticSearch<br>Kibana<br>Logstash<br>Beats</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;大数据平台相关框架汇总。&lt;br&gt;包括：Hadoop、Hbase、Pig、Hive、Spark、Strom、Flink、Presto、Atlas、SuperSet、Cassandra、ClickHouse等&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://www.lights8080.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="大数据" scheme="http://www.lights8080.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>2109-3-小情境与大情境</title>
    <link href="http://www.lights8080.com/p/1db6c142.html"/>
    <id>http://www.lights8080.com/p/1db6c142.html</id>
    <published>2021-09-15T16:00:00.000Z</published>
    <updated>2021-09-17T01:40:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>如题</p><span id="more"></span><h2 id="话题：小情境与大情境"><a href="#话题：小情境与大情境" class="headerlink" title="话题：小情境与大情境"></a>话题：小情境与大情境</h2><p>最近在读一本书《李诞脱口秀工作手册》，还没有读完，其中有一个观点很有启发，小情境与大情境。<br>小情境就是你的一个又一个段子，大情境就是你的主持。</p><p>“””<br>请思考一个问题，我们上台演出的目的是什么？是为了伺候好那一场，那一天的观众吗？</p><p>我们当然要为演出效果负责，但是你上台的出发点不该是这个，而是要拉长时间看——目的始终是成为更强的脱口秀演员。<br>目的是通过逗笑观众磨砺自己，而不是逗笑观众。</p><p>不停上开放麦，不停演出的目的，是练自己，不是炸场。<br>最终你会变成一个在舞台上游刃有余，什么状况都能接住的演员，你会场场都炸。<br>但你的出发点不该是练这个，如果你一出发就去练怎么炸场，你也不太可能变成一个炸场演员。<br>你的上限太低了，你的上限就是一天又一天迎来送往的观众，你会慢慢发现，炸场其实挺容易的，你会收获一天又一天无意义的成功。</p><p>这也能解释从线下到线上的不适，你能练成伺候一百人的能力，你能伺候好一千万人吗？</p><p>不是你去找观众，而是要让观众来找你。狠狠地操练自己，你越强，找到你的观众越多。<br>而不是你能讨好的人越多，你的观众越多。<br>炸场是副产品，正如名利也是副产品。<br>追求炸场，追求名利，你会一无所获，或者更惨，你会变成一个庸人，甚至一个坏人。</p><p>人是目的，不是手段。<br>“””</p><p>他说很多朋友从线下转到线上，都要问这么一个问题，“我是该看观众还是该看镜头？”</p><p>这确实是一个很好的问题，在职场中类似的问题有一堆，“如何应对三十五岁危机？”，“如何跟老板搞好关系？”，“如何管理员工？”。</p><p>这些看似是很麻烦的问题，其实都是假问题。</p><p>脱口秀表演，如果你把重点放在与观众的关系上，你在台上很容易不知所措，后果就是注意力分散，或者更加悲惨，演砸了。<br>职场工作，如果你把重点放在搞好领导同事之间的关系上，那就是拿自己当手段不是目的，后果就是焦虑，工作做不好，在专业上不专业了。</p><p>过度去讨好观众，就算这场观众笑了；过度搞好同事关系，就算这几年升职加薪了，那也是无意义的成功。<br>用发展的眼光看问题，这是一份终身职业，一份与你的一切不能分割的工作，有意义的失败远远比无意义的成功有价值。</p><p>人生的目的就是成为更好的自己，狠狠地操练自己。</p><p>另外，我觉得每个人都应该学会识别生活中的小情境与大情境。<br>我们必须习惯用发展的眼光看问题，人生不是几把牌，赢了就赢了，人生是个牌局，想散都散不了的那种，输赢不在一把两把。</p><p>塞翁失马焉知非福。</p><p>说到这里，我认为在孩子教育的事情上，是非常非常需要用发展的眼光。<br>有时候会因为一些小事儿，跟孩子生气，跟他气完后，就反过来跟自己生气，“我为什么生气了？”。</p><p>教育不应该是控制，应该是高度控制下的失控。<br>教育是目的，不是手段。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如题&lt;/p&gt;</summary>
    
    
    
    <category term="weekly" scheme="http://www.lights8080.com/categories/weekly/"/>
    
    
    <category term="weekly" scheme="http://www.lights8080.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>2109-2-马猴来了</title>
    <link href="http://www.lights8080.com/p/9dc87d4e.html"/>
    <id>http://www.lights8080.com/p/9dc87d4e.html</id>
    <published>2021-09-09T16:00:00.000Z</published>
    <updated>2021-09-17T01:40:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>如题</p><span id="more"></span><h2 id="话题：马猴来了"><a href="#话题：马猴来了" class="headerlink" title="话题：马猴来了"></a>话题：马猴来了</h2><p>书接上文：<br>我之前一直都不认可这样的主播，认为其对社会没有任何价值。没有什么能耐，就靠嘴皮子，吸引一些脑残粉而已。</p><p>但我也被马猴所吸引了，至少在想休闲的时候会想到他的直播。<br>除了PK惩罚比较好玩意外，更喜欢的是他那真实的态度。<br>大多数主播，会迎合讨好粉丝，说话有时嗲嗲的，显得很做作。<br>马猴的直播算得上是一股清流，姿态放的很低，虽然是靠直播挣钱，但不刻意迎合粉丝，不说假话，自然真实，敢玩。<br>没有什么显眼才艺，但这就是他的风格。</p><p>非常敢玩游戏，除了吃东西不玩，其他的基本都敢接。<br>看过他往睡觉的床上泼一盆水，蒙眼跳蹬子，墩屁墩，墙上凿坑，脸上抹泥…<br>隔天再进他的直播间发现灯泡捅坏了，一扇门拆了，后面的背景阿里路亚抠的只剩路亚了。</p><p>直播中，粉丝问啥，他也从不遮遮掩掩。<br>比如直播挣多少钱啊，女主播内幕啊。<br>他透露自己<br>“””<br>曾经当过煤矿工人，一年就挣2w块钱。<br>赌博输掉20w，媳妇闹离婚。<br>我自己啥能耐没有，我去在外面，一个月挣个两三千到头了。<br>做主播现在好点，每个月挣6w差不多，一开始那会儿一月能有一两千不错了。<br>已经从直播中挣了差不多300w+，现在住的别墅，二楼单独弄了个直播间，给大家展示下子粉丝送的东西（好烟好酒）。<br>咱说实在的，给朋友随红包也就三五百块钱。哪天我的大哥开播了，我刷礼物就得一万多，少了拿不出手，是不是。<br>做PL直播的都没有一个好东西，都得有点啥事，正常上班的人干不了主播。<br>就现在的全网的这些PK主播都是些烂七八糟的人，真话。包括我自己，但是我没偷，没骗，没抢。你觉得自己过的不错你就刷点，觉得过的一般的看着就行了。<br>那些给女主播刷礼物的，好几万好几万的，你以为是情怀啊，屁！<br>……<br>“””</p><p>他自称是一个正能量主播，我觉得他也做到了。<br>PK哪怕输的一塌糊涂，气势上也一点不输，输多少次，依然当游戏欢笑面对。<br>真实、自信、不做作，这就是他给我传递的正能量！<br>分享直播生活和内幕，分享过往经历，能让人从中吸取一些经验教训，了解到不同人的生活方式，那也是价值。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如题&lt;/p&gt;</summary>
    
    
    
    <category term="weekly" scheme="http://www.lights8080.com/categories/weekly/"/>
    
    
    <category term="weekly" scheme="http://www.lights8080.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>数据仓库项目实战</title>
    <link href="http://www.lights8080.com/p/78ecf609.html"/>
    <id>http://www.lights8080.com/p/78ecf609.html</id>
    <published>2021-09-05T16:00:00.000Z</published>
    <updated>2021-09-08T08:53:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>读书笔记-《大数据分析：数据仓库项目实战》</p><span id="more"></span><h2 id="大数据和数据仓库概论"><a href="#大数据和数据仓库概论" class="headerlink" title="大数据和数据仓库概论"></a>大数据和数据仓库概论</h2><h4 id="大数据概论"><a href="#大数据概论" class="headerlink" title="大数据概论"></a>大数据概论</h4><p><img src="https://gitee.com/lights8080/lights8080-oss/raw/master/2021/09/mBx4zQ.jpg" alt="大数据生态圈的层次及其应用举例"></p><ul><li>数据采集层：多数据源，非结构化数据采集</li><li>数据计算层：分为离线数据计算和实时数据计算</li><li>数据应用层：最终提供给用户使用</li></ul><h4 id="数据仓库概论"><a href="#数据仓库概论" class="headerlink" title="数据仓库概论"></a>数据仓库概论</h4><p>数据仓库（Data Warehouse，DW）：为企业所有级别的决策制度过程，提供数据资源集合，出于分析性报告和决策支持目的而创建。是未面向分析的集成化数据环境。</p><p>数据仓库的特点：</p><ul><li>数据是面向主题的：具有更高的数据抽象级别</li><li>数据是集成的：数据源于不同的联机系统，进入仓库前必须经过统一和综合</li><li>数据是不可更新的</li><li>数据是随时间不断变化的</li></ul><h2 id="数据仓库建模"><a href="#数据仓库建模" class="headerlink" title="数据仓库建模"></a>数据仓库建模</h2><h4 id="范式理论"><a href="#范式理论" class="headerlink" title="范式理论"></a>范式理论</h4><p>使用范式的根本目的包括：</p><ul><li>减少数据冗余，尽量让每个数据只出现一次</li><li>保证数据的一致性</li></ul><p>联机事务处理(On-Line Transaction Processing，OLTP)：传统关系数据库的主要应用，保证数据的一致性及避免冗余。<br>联机分析处理(On-Line Analytical Processing，OLAP)：数据仓库系统主要应用，通常以某一张事实表为中心进行表的组织，面向业务，可能存在数据的冗余，通常采用维度模型建模。</p><p>维度模型：包括星型模型、雪花模型、星座模型</p><h4 id="表的分类"><a href="#表的分类" class="headerlink" title="表的分类"></a>表的分类</h4><p>事实表：每行数据代表一个业务事件。”事实”这个术语表示的是业务事件的度量值。如：订单金额</p><p>事实表分类：</p><ul><li>事务型事实表（每个事务或事件产生一行数据）</li><li>周期型快照事实表（保留固定时间间隔的数据）</li><li>累积型快照事实表（用于跟踪业务事实的变化）</li></ul><p>维度表：指对业务状态编码的解释表，又称为码表。如：订单状态表、商品分类</p><h4 id="逻辑分层"><a href="#逻辑分层" class="headerlink" title="逻辑分层"></a>逻辑分层</h4><p>分层：</p><ul><li>ODS（原始数据层，Operational Data Store）：加载原始日志</li><li>DWD（明细数据层，Data Warehouse Detail ）：结构和粒度与ODS保持一致，对数据进行清洗、维度退化、脱敏、数据压缩等（仅关注事实表的相关维度及度量值字段）</li><li>DWS（服务数据层，Data Warehouse Service ）：宽表化手段构建公共指标数据，不同的主题按天进行轻度汇总</li><li>DWT（主题数据层，Data Warehouse Topic）：按主题进行汇总，获得每个主题的全量数据表</li><li>ADS（应用数据层，Application Data Store）：面向实际的数据需求，为各统计报表提供数据</li></ul><p>好处：</p><ul><li>【易维护】高效的数据组织形式，清洗和过滤，规范化，血缘追踪</li><li>【高性能】时间价值，数据集合，维度汇总，查询效率</li><li>【简单化】集成价值，多维度数据整合，多角度多层次的数据分析</li><li>【历史性】历史数据，回溯历史，预测未来</li></ul><p>DWD构建维度模型的四个步骤：</p><ol><li>选择业务过程：一条业务线对应一张事实表。如：下单业务，支付业务</li><li>声明粒度：精确定义事实表中一行数据所表示的内容，尽可能选择最细粒度</li><li>确定维度：主要作用是描述业务事实，表示的是”谁、何处、何时”等信息。如时间维度，用户维度</li><li>确定事实：指的是业务中的度量值，如订单件数，订单金额等</li></ol><p>得出业务总线矩阵：将维度表进行退化，地区表和省份表退化为地区维度表，商品类目退化为商品维度表等<br><img src="https://gitee.com/lights8080/lights8080-oss/raw/master/2021/09/d4oJdU.jpg" alt="业务总线矩阵"></p><p>DWS、DWT层都是按照主题来创建宽表的，而主题相当于观察问题的角度，不同的维度表意味着不同的角度。<br><img src="https://gitee.com/lights8080/lights8080-oss/raw/master/2021/09/rxAni4.jpg"></p><p>DWS层用于统计各主题对象的当天行为，服务于DWT层的主题宽表，宽表字段是站在不同维度的视角去看事实表的，重点关注事实表的度量值。<br><img src="https://gitee.com/lights8080/lights8080-oss/raw/master/2021/09/4onPTr.jpg"></p><p>DWT层以分析的主题对象为建模驱动，基于上层应用和产品指标需求，构建主题对象的全量宽表。<br><img src="https://gitee.com/lights8080/lights8080-oss/raw/master/2021/09/puooTc.jpg"></p><p>ADS层分别对不同的主题进行指标分析。</p><h2 id="技术选型和架构选型"><a href="#技术选型和架构选型" class="headerlink" title="技术选型和架构选型"></a>技术选型和架构选型</h2><p>技术选型：<br>数据采集与传输：Flume、Kafka、Sqoop<br>数据存储：MySQL、HDFS<br>数据计算：Hive、Tez<br>任务调度：Azkaban<br>即席查询：Presto、Druid、Kylin<br>元数据管理：Atlas</p><p>框架选型：<br>Apache：可以自由定制所需功能组件，运维过程烦琐，组件间的兼容性需要自己调研<br>CDH：国内使用较多，不开源，不用担心组件兼容问题<br>HDP：开源，但没有CDH稳定，使用较少</p><h2 id="数据集市"><a href="#数据集市" class="headerlink" title="数据集市"></a>数据集市</h2><p>数据集市本质上是一个数据交易市场，就像宜家楼上的展厅，这是一个面向最终用户的数据市场。数据（家具）以一种更加容易被业务人员接受的方式组合在一起。<br>数据集市提供数据交易服务的最终实现，为用户提供各种数据服务支持。</p><p>特征：</p><ul><li>有特定的应用主题</li><li>业务部门管理和维护</li><li>聚焦具体领域，要满足低延迟，高并发的数据查询要求</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;读书笔记-《大数据分析：数据仓库项目实战》&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="技术" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="读书笔记" scheme="http://www.lights8080.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="大数据" scheme="http://www.lights8080.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    <category term="数据仓库" scheme="http://www.lights8080.com/tags/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>2109-1-对面大哥都是我祖宗</title>
    <link href="http://www.lights8080.com/p/342ac289.html"/>
    <id>http://www.lights8080.com/p/342ac289.html</id>
    <published>2021-09-02T16:00:00.000Z</published>
    <updated>2021-09-17T01:40:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>如题</p><span id="more"></span><h2 id="话题：对面大哥都是我祖宗"><a href="#话题：对面大哥都是我祖宗" class="headerlink" title="话题：对面大哥都是我祖宗"></a>话题：对面大哥都是我祖宗</h2><p>最近这几天在微信直播关注了一个逗比主播，分享一下这其中的故事。<br>晚上无事，打开手机漫无目的的乱滑着。进到一个直播间，两个人正在PK，热度和观看人数都很高。<br>出于好奇心，就持续看了下去。</p><p>左面是凡达（后面看粉丝说凡家主播占了微信直播的一半流量），右面是马猴。<br>PK期间，热度低的一方要不停的喊出一句话“对面的大哥都是我祖宗”（他们约定的游戏规则）。<br>PK结束，右边马猴小优势获胜。然后就是惩罚阶段，左边凡达撅着拿铁盆扣在屁股，用脚踢铁盆50下。<br>凡达各种挑衅问对面敢不敢再开一局，双方你一句我一句谁也让谁，又开了一局。（现在想想，PK主播想要的就是这种直播效果，线下可以是朋友，线上那就是损友）<br>这局凡达以碾压式的优势获胜。<br>马猴虽然输了，但整个状态就跟赢了对面十万票似的，连喊“对面的大哥都是我祖宗！！！”都底气十足。<br>惩罚是剪掉一个裤腿，也一样干净利索，说话气势态度上甚至比对面还强势。<br>我心想你都输成这样了，看你后面还咋直播，转而进了他的直播间。</p><p>俩人连线结束后不一会儿，一个大哥就上来语音连线了，后面就称他为X吧。（应该是经常给马猴打赏的粉丝）</p><p>X说：<br>“””<br>你这样还咋玩儿啊，你第一局赢了，你的粉丝大哥们这么支持你，给你刷礼物为啥啊？<br>你认为你把把都能赢凡达啊，人家多少粉丝什么级别，你这一局赢的就是侥幸，你知道吧。<br>我们这么给你刷礼物，就是要让你赢一次，他是大号，让他没有面子，后面才有机会再打，多吸引点他的粉丝过来，你才能火啊。<br>他为啥要各种刺激你，非要跟你打第二局啊，他要找回面子来的啊。<br>结果呢，你被他一刺激就开打了，你没有看你的聊天啊，都刷屏了让你别打！别打！<br>你鸟他干嘛啊，你对他那么实在有鸟用，你就照顾好你的粉丝就行了。<br>你看第二局打的，说真的，你这多伤你直播间儿大哥的心啊。<br>“””</p><p>这时候马猴的气势和心态都蔫了，他说：<br>我没想那么多，我就是玩儿，打的时候我说了，赢他凡达一次就够了，输多少次我都赢了。<br>如果伤害了直播间的大哥，我道歉，对不起。<br>我就是一个小主播，没法跟人家凡达比。<br>你说我没啥才艺，不会唱歌跳舞，我就是个PK主播，不PK那我主播什么，别的我也不会。<br>这是实话，真的。</p><p>X说：<br>“””<br>就你实在。<br>你赢了，第二局你不跟他打了，你放心第二天他肯定会主动找你连麦的。<br>他要找机会出气啊，他房间的大哥要给他撑腰啊，给他的粉丝要回面子啊。<br>你这样又打输了，他面子也找回去了，人家还会找你连麦吗？<br>就你这智商，连点战术都没有，你怎么火的起来哦，打仗不是光靠拼的。<br>“””</p><p>这时，又有人找他连麦PK。聊了一会儿，马猴说等会儿，我开个会。</p><p>X说：<br>“””<br>不要跟他开打，这人就是凡家的小弟。<br>你赢了一局，他还是咽不下这口气，找个小弟过来PK侮辱你的。<br>你就跟他磨嘴皮子，没话说了就撂下一句话，先打赢你师傅再来找我打。<br>我跟你讲，如果这次你连他小弟都打输了，你就再没机会了。<br>你放心，只有这样凡达才会再找你连麦，连这个都看不明白吗？<br>你照顾好你房间的大哥就行了，你对他那么实在干嘛。<br>“””</p><p>细品X说的这些话，真是战术大师，对方心理琢磨的透透的。<br>直播中还有这么多门道，这是我没有想到的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如题&lt;/p&gt;</summary>
    
    
    
    <category term="weekly" scheme="http://www.lights8080.com/categories/weekly/"/>
    
    
    <category term="weekly" scheme="http://www.lights8080.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>2108-4-企业文化</title>
    <link href="http://www.lights8080.com/p/7fc5d86f.html"/>
    <id>http://www.lights8080.com/p/7fc5d86f.html</id>
    <published>2021-08-26T16:00:00.000Z</published>
    <updated>2021-09-02T02:03:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>如题</p><span id="more"></span><h2 id="话题：企业文化"><a href="#话题：企业文化" class="headerlink" title="话题：企业文化"></a>话题：企业文化</h2><p>相信大部分人都非常向往大厂的企业文化吧。<br>比如：扁平化管理、没有考勤管理和休假制度、没有主管和考核、不建立统一技术规范、没有测试团队等。<br>天啊！很难想象这样的制度，公司怎样运营？</p><p>那大厂为什么会这样，且还能运营的很好？又是如何组织上万人朝着同一个目标前进呢。<br>我觉得关键是公司里是一群什么样的人。大厂的竞争实际是人才的竞争，而公司的企业文化就是要保证吸引和留住人才。<br>”“”<br>对于程序型的工作，顶级员工的输出量是一般员工的2倍。<br>对于创新型/创意型的工作，顶级员工的输出量是一般员工的10倍!<br>”“”</p><p>工程师人天生带有一种工匠式的图腾崇拜精神，奉行达者为师，不迷信管理他们的人，但充分尊重能够指导他们的人。<br>他们都非常的自律性，有目标，有责任感。企业里有这样一群优秀的人，还需要管理吗？</p><p>优秀的人从来不怕麻烦，如果是一个好的方案，大家就会趋同。所以不设立统一的技术规范，反而进化迭代出更好的规范。</p><p>公司的目标靠产品驱动，落实到人，分配给团队，团队就需要对自己做出来的东西负责任。<br>团队内有不同意见时，听谁的呢？<br>那就是谁对这个产品负责就听谁的，一旦负责人决定了，团队内不同意见的人，要迅速调整。</p><p>能力差的，不认可公司文化和价值观的人，最终会被淘汰掉，或主动离职。<br>所以企业文化和有这样一群人是密不可分的。<br>有这样的文化，没有这样一群优秀的人，是支撑不了企业成长的；<br>没有这样的文化，即使有这样一群优秀的人，最终也会人才流失。<br>大厂为啥热衷于要搞开源？互联网企业技术就是核心价值，这不是帮助同业成长吗？<br>核心还是建立行业标准和最佳实践，建立技术品牌，留住和吸引顶级工程师，并从共享生态中获得反馈输入受益。</p><p>多美好，相辅相成，但小厂照搬过来，大概率是行不通的。<br>原因是小厂没有能力招到一群优秀的人。基本都是一个大牛，带一堆小兵。<br>是小兵也就意味着能力水平和意识，都达不到水平，只能靠管理，靠规范，靠大牛的指导，才能朝着目标前进。</p><h2 id="语录"><a href="#语录" class="headerlink" title="语录"></a>语录</h2><ol><li>如果你想造一艘船，先不要雇人去收集木头， 也不要给他们分配任何任务，而是去激发他们对浩瀚汪洋的渴望。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;如题&lt;/p&gt;</summary>
    
    
    
    <category term="weekly" scheme="http://www.lights8080.com/categories/weekly/"/>
    
    
    <category term="weekly" scheme="http://www.lights8080.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>2108-3-从NBA看职场</title>
    <link href="http://www.lights8080.com/p/418eb76d.html"/>
    <id>http://www.lights8080.com/p/418eb76d.html</id>
    <published>2021-08-19T16:00:00.000Z</published>
    <updated>2021-09-02T02:03:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>如题</p><span id="more"></span><h2 id="话题：从NBA看职场"><a href="#话题：从NBA看职场" class="headerlink" title="话题：从NBA看职场"></a>话题：从NBA看职场</h2><p>球员背景：</p><p>施罗德：<br>市场上没有比施罗德更适合湖人的首发控卫了，从赛季中期湖人的报价来看，确实把施罗德当第三巨头来看待了。<br>施罗德也正是看中了这点，要求球队首发和顶薪，拒绝湖人平均年薪2000w报价的资本。</p><p>霍华德：<br>19-20赛季湖人获得NBA总冠军，霍华德在夺冠道路上也发挥了应有价值，选择续约湖人是自然的事情。<br>湖人从市场签约了小加索尔和哈雷尔，账目实力远大于霍华德，霍华德上场时间被挤没了，只能离队最终一年签约76人。</p><p>库兹马+波普：<br>库兹马、波普都处于合同年，因为19-20赛季在季后赛中发挥作用，提升了市场价值。湖人分别签了平均年薪超千万的长约。<br>但上赛季表现中规中矩，没有达到预期。</p><hr><p>我有时候会想如果我是湖人总经理，面对这个局面，我该如何操作呢？<br>尤其是对施罗德的续约上，顶薪明显是溢价合同，但是市场上又没有更好的选择了。放走施罗德湖人后卫就是问题？</p><p>下面来看看湖人总经理的操作：<br>1。 果断放弃表现不好的球员（库兹马+波普+哈雷尔），打包交易换来即战力很强的威少，组成三巨头，从侧面直接解决了施罗德的难题。<br>而施罗德，最终一年590w签约凯尔特人。</p><ol start="2"><li><p>毫不犹豫的重新签回霍华德。从上赛季的表现来看，去年的操作是失败的，小加索尔和哈雷尔和球队的化学反应并不好。</p></li><li><p>依靠巨星光环和总冠军，吸引优质球员底薪签约。</p></li></ol><h2 id="语录"><a href="#语录" class="headerlink" title="语录"></a>语录</h2><ol><li><p>当你有选择的时候，选择更重要；而当你没有选择的时候，努力才重要。努力是为了让你有更好的选择。</p></li><li><p>人不是因为变老了才没有热情，而是因为你没有热情才变老了。</p></li><li><p>成年人面对的第一个挑战就是没时间，我们需要解决的问题就是，在资源匮乏的情况下，还能够把事情做成。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;如题&lt;/p&gt;</summary>
    
    
    
    <category term="weekly" scheme="http://www.lights8080.com/categories/weekly/"/>
    
    
    <category term="weekly" scheme="http://www.lights8080.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>2108-2-K12双减的深度思考</title>
    <link href="http://www.lights8080.com/p/197f72b3.html"/>
    <id>http://www.lights8080.com/p/197f72b3.html</id>
    <published>2021-08-12T16:00:00.000Z</published>
    <updated>2021-09-02T02:03:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>如题</p><span id="more"></span><h2 id="话题：K12双减的深度思考"><a href="#话题：K12双减的深度思考" class="headerlink" title="话题：K12双减的深度思考"></a>话题：K12双减的深度思考</h2><p>认真观察身边的朋友同事，有一个现象比较明显。<br>肯吃苦努力工作的人基本都是穷人家庭出身，而那些对工作没有什么追求的人往往家庭条件比较优越。</p><p>都市剧《谁说我结不了婚》中有这样一段对话，我感触很深。<br>”“”<br>许海峰：至于这么拼吗？<br>田雷：我没有光鲜的学历，也没有丰厚的背景，我从实习生做起，一步一步拼到现在，才走到现在的位置。我拼尽全力，也只是你的起点而已。<br>”“”</p><p>我是农村出身，有时候真的会觉得很气，凭什么啊！<br>低收入家庭要想跃迁到中产阶级需要付出非常大的努力，而且不一定就能成功。而中产阶级家的孩子可以很轻松的享受并维持这个水平。</p><p>这也是年轻人躺平的原因吧，没有晋升希望。</p><p>贫富差距大，穷人太多，晋升的机会小，从宏观角度看，这是资本分配的问题。</p><p>经济内循环，关键还是要看中产阶级力量。中产阶级才是消费主力军，内循环的驱动力。（有钱的人占比太少拉动不起来，低收入家庭没钱去拉动，中产阶级是有欲望和有能力消费的群体）</p><p>20年统计，国家6亿人每月收入1000元。实现内循环，现存的中产阶级还不够。根本的解决办法，是让穷人变富。<br>如何变富？ - 靠自己。</p><p>国家层面要做的就是，尽可能保障赛道公平，让那些有天赋，肯吃苦，努力的人更容易实现阶层跃迁，给更多的低收入家庭以希望。<br>不能因为出身家庭财富和其他后天的限制就剥夺了成功的机会。要让后来人看到希望，带动更多的人步入中产。</p><p>K12双减，明面上是配合三胎政策，降低养育成本，实则是对中产阶级的降维打击。<br>强行拉平中产阶级家庭孩子和低收入家庭孩子到同一起跑线（低收入家庭没有经济能力上辅导班，那就让中产阶级家庭的孩子没有课外辅导班可上），降低底层民众晋升中产阶级的难度。</p><p>K12双减政策这只是国家层面调整社会资本结构的一部分。要求给外卖小哥和快递员上社保、加强反垄断等等，你细品其实都有其影子。</p><p>回到开头的所说的内容，年轻人躺平。<br>国家正在极力扭转这种局面，尽可能降低底层民众晋升中产阶级的难度，靠自己的努力实现富裕，去卷中产阶级。促进中产阶级的孩子努力去卷更高的阶级。</p><p>生病了，药再苦也得吃啊，总不能等到无药可救吧。</p><hr><p>要求给外卖小哥和快递员上社保，平台给骑手买社保，平台的利润减少了，最终肯定会转移到骑手和商家上。<br>外卖提价，高端的店留在平台，低端的店退出；<br>优秀的骑手收入会增加，大量混日子的骑手退出；<br>有钱人外卖贵点也会点，没钱人没钱点外卖了，去线下小店吃吧。</p><p>反垄断，会让资本更多的流向中小企业，中小企业是吸纳就业的重要力量。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如题&lt;/p&gt;</summary>
    
    
    
    <category term="weekly" scheme="http://www.lights8080.com/categories/weekly/"/>
    
    
    <category term="weekly" scheme="http://www.lights8080.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>凤凰架构-透明多层分流系统</title>
    <link href="http://www.lights8080.com/p/fd2df2c4.html"/>
    <id>http://www.lights8080.com/p/fd2df2c4.html</id>
    <published>2021-08-08T16:00:00.000Z</published>
    <updated>2021-09-07T03:50:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>周志明《凤凰架构：构建可靠的大型分布式系统》<br><a href="https://icyfenix.cn/">https://icyfenix.cn/</a></p><p>包括：域名解析，客户端缓存，传输链路，传输压缩，内容分发，负载均衡</p><span id="more"></span><p>透明多级分流系统的设计原则：</p><ul><li>第一个原则是尽可能减少单点部件，如果某些单点是无可避免的，则应尽最大限度减少到达单点部件的流量。</li><li>第二个原则是奥卡姆剃刀原则，它更为关键。”如无必要，勿增实体“</li></ul><h2 id="域名解析-DNS"><a href="#域名解析-DNS" class="headerlink" title="域名解析(DNS)"></a>域名解析(DNS)</h2><p>以 <a href="http://www.icyfenix.com.cn/">www.icyfenix.com.cn</a> 为例，介绍DNS把域名解析成IP地址的过程：</p><ol><li>客户端先检查本地的 DNS 缓存，查看是否存在并且是存活着的该域名的地址记录。</li><li>客户端将地址发送给本机操作系统中配置的本地 DNS（Local DNS）</li><li>本地 DNS 收到查询请求后，会按照顺序依次查找地址记录，“ <a href="http://www.icyfenix.com.cn/">www.icyfenix.com.cn</a> 的权威服务器”→“ icyfenix.com.cn 的权威服务器”→“ com.cn 的权威服务器”→“cn 的权威服务器”→“根域名服务器“。</li><li>现在假设本地 DNS 是全新的，上面不存在任何域名的权威服务器记录，当 DNS 查询请求一直查到根域名服务器之后，会得到“cn 的权威服务器”的地址记录，然后通过“cn 的权威服务器”，得到“com.cn 的权威服务器”的地址记录，以此类推，最后找到能够解释 <a href="http://www.icyfenix.com.cn/">www.icyfenix.com.cn</a> 的权威服务器地址。</li><li>通过“<a href="http://www.icyfenix.com.cn/">www.icyfenix.com.cn</a> 的权威服务器”，查询 <a href="http://www.icyfenix.com.cn/">www.icyfenix.com.cn</a> 的地址记录。</li></ol><p>DNS 的分级查询都有可能受到中间人攻击的威胁，产生被劫持的风险。</p><p>HTTPDNS（也称为 DNS over HTTPS，DoH）：它把原本的 DNS 解析服务开放为一个基于 HTTPS 协议的查询服务，替代基于 UDP 传输协议的 DNS 域名解析，通过程序代替操作系统直接从权威 DNS，或者可靠 Local DNS 获取解析数据，从而绕过传统 Local DNS。</p><blockquote><p>“切勿浪费较多东西，去做‘用较少的东西，同样可以做好的事情’。”<br>手上有个新锤子，看啥都是对口的钉子。</p></blockquote><h2 id="客户端缓存"><a href="#客户端缓存" class="headerlink" title="客户端缓存"></a>客户端缓存</h2><p>分为强制缓存和协商缓存，这两套机制是并行工作。当强制缓存超过时效或者被禁用，协商缓存也仍然可以正常工作。</p><h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h3><p>根据资源的修改时间进行检查</p><h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p>Expires 是 HTTP/1.0 协议中开始提供的 Header，后面跟随了一个截止时间参数</p><blockquote><p>HTTP/1.1 200 OK<br>Expires: Wed, 8 Apr 2020 07:28:00 GMT</p></blockquote><p>问题：</p><ul><li>受限于客户端的本地时间</li><li>无法处理涉及到用户身份的私有资源</li><li>无法描述“不缓存”的语义</li></ul><h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p>Cache-Control 是 HTTP/1.1 协议中定义的强制缓存 Header，与 Expires 同时存在，且语义存在冲突时，IETF 规定必须以 Cache-Control 为准。</p><blockquote><p>HTTP/1.1 200 OK<br>Cache-Control: max-age=600</p></blockquote><ul><li>max-age：相对于请求时间多少秒内，缓存是有效的</li><li>s-maxage：“共享缓存”的有效时间，即允许被 CDN、代理等持有的缓存有效时间</li><li>public：意味着资源可以被代理、CDN 等缓存</li><li>private：就意味着只能由用户的客户端进行私有缓存</li><li>no-cache：表明该资源不应该被缓存，哪怕是同一个会话中对同一个 URL 地址的请求</li><li>no-store：不强制会话中是否重复获取相同的 URL 资源，禁止浏览器、CDN 等以任何形式保存该资源</li><li>no-transform：禁止资源以任何形式被修改，包括Content-Encoding、Content-Range、Content-Type</li><li>min-fresh：仅用于客户端的请求 Header，用于建议服务器能返回一个不少于该时间的缓存资源</li><li>only-if-cached：表示客户端只会接受代理缓存，而不会接受源服务器的响应。如果代理缓存无效，就直接返回 503/Service Unavailable 错误</li><li>must-revalidate：表示在资源过期后，一定要从服务器中进行获取</li><li>proxy-revalidate：用于提示代理、CDN 等设备资源过期后的缓存行为，语义与 must-revalidate 完全一致</li></ul><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>根据资源唯一标识是否发生变化来进行检查</p><h4 id="根据资源的修改时间进行检查"><a href="#根据资源的修改时间进行检查" class="headerlink" title="根据资源的修改时间进行检查"></a>根据资源的修改时间进行检查</h4><p>Last-Modified：服务器的响应 Header，用来告诉客户端这个资源的最后修改时间<br>If-Modified-Since：客户端再次请求时，会通过 If-Modified-Since，把之前收到的资源最后修改时间发送回服务端</p><p>服务端发现资源在该时间后没有被修改过，就只要返回一个 304/Not Modified 的响应即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 304 Not Modified</span><br><span class="line">Cache-Control: public, max-age=600</span><br><span class="line">Last-Modified: Wed, 8 Apr 2020 15:31:30 GMT</span><br></pre></td></tr></table></figure><h4 id="根据资源唯一标识是否发生变化来进行检查"><a href="#根据资源唯一标识是否发生变化来进行检查" class="headerlink" title="根据资源唯一标识是否发生变化来进行检查"></a>根据资源唯一标识是否发生变化来进行检查</h4><p>Etag：是服务器的响应 Header，用于告诉客户端这个资源的唯一标识<br>If-None-Match：当客户端需要再次请求时，就会通过 If-None-Match，把之前收到的资源唯一标识发送回服务端</p><h2 id="传输链路"><a href="#传输链路" class="headerlink" title="传输链路"></a>传输链路</h2><h3 id="前端网页的优化技巧"><a href="#前端网页的优化技巧" class="headerlink" title="前端网页的优化技巧"></a>前端网页的优化技巧</h3><ul><li>最少请求数量：TCP连接开销很大，解决手段有雪碧图，文件合并，媒体内联等</li><li>扩大并发请求数：现代浏览器一般支持6个并发请求，解决手段域名分片</li><li>启用压缩传输：减少网络传输内容的大小</li><li>避免页面重定向：页面发生了重定向，就会延迟整个文档的传输</li><li>按重要性调节资源优先级：对客户端展示影响大的资源，放在 HTML 的头部，以便优先下载</li><li>…</li></ul><p>因为 HTTP 协议还在持续发展，这些优化技巧可能会成为反模式。<br>HTTP/3以前是以 TCP 为传输层的应用层协，TCP 协议本身是面向长时间、大数据传输来设计的。<br>而每个页面包含的资源（HTML、CSS、JS、图片等）的特征是，数量多，资源小。<br>以至于 HTTP/1.x 时代，大量短而小的 TCP 连接导致了网络性能的瓶颈。</p><h3 id="Keep-Alive-机制"><a href="#Keep-Alive-机制" class="headerlink" title="Keep-Alive 机制"></a>Keep-Alive 机制</h3><p>（HTTP/1.0 中不是默认开启的，HTTP/1.1 中变为默认）<br>原理是让客户端对同一个域名长期持有一个或多个不会用完即断的 TCP 连接。客户端维护一个 FIFO 队列，每次取完数据之后的一段时间内，不自动断开连接，下一个资源时可以直接复用，避免创建 TCP 连接的成本。</p><p>副作用：队首阻塞，首个资源是一个复杂的请求，导致后面的请求必须阻塞等待。</p><h3 id="HTTP-2-的多路复用技术"><a href="#HTTP-2-的多路复用技术" class="headerlink" title="HTTP/2 的多路复用技术"></a>HTTP/2 的多路复用技术</h3><p>在 HTTP/1.x 中，HTTP 请求就是传输过程中最小粒度的信息单位，如果将多个请求切碎，再混杂在一块传输，客户端难以分辨重组出有效信息。<br>而在 HTTP/2 中，帧（Frame）才是最小粒度的信息单位。它可以用来描述各种数据，比如请求的 Headers、Body，或者是用来做控制标识，如打开流、关闭流。<br>流（Stream）是一个逻辑上的数据通道概念，每个帧都附带有一个流 ID，以标识这个帧属于哪个流。</p><p>多路复用的支持，HTTP/2 就可以对每个域名只维持一个 TCP 连接，开发者也不用去考虑并发请求数限制，客户端就不需要再刻意压缩 HTTP 请求。</p><p>在 HTTP 传输中，Headers 占传输成本的比重是相当地大，HTTP/2 中专门考虑如何进行 Header 压缩的问题，同一个连接上产生的请求和响应越多，头部压缩效果也就越好。所以 HTTP/2 是单域名单连接的机制，合并资源和域名分片反而对性能提升不利。</p><p>与 HTTP/1.x 相反，HTTP/2 本身反而变得更适合传输小资源。</p><h3 id="传输压缩"><a href="#传输压缩" class="headerlink" title="传输压缩"></a>传输压缩</h3><p>当客户端可以接受压缩版本的资源时（请求的 Header 中包含 Accept-Encoding: gzip），就返回压缩后的版本（响应的 Header 中包含 Content-Encoding: gzip），否则就返回未压缩的原版。</p><h4 id="静态预压缩"><a href="#静态预压缩" class="headerlink" title="静态预压缩"></a>静态预压缩</h4><p>在网络时代的早期，服务器的处理能力还很薄弱，为了启用压缩，会把静态资源预先压缩为.gz 文件的形式给存放起来。</p><h4 id="即时压缩"><a href="#即时压缩" class="headerlink" title="即时压缩"></a>即时压缩</h4><p>现代的 Web 服务器处理能力有了大幅提升，整个压缩过程全部在内存的数据流中完成，不必等资源压缩完成再返回响应，这样可以显著提高首字节时间，改善 Web 性能体验。</p><p>在 HTTP/1.0 时，资源结束判断的机制，只有根据 Content-Length 判断。<br>但即时压缩时，服务器再也没有办法给出 Content-Length 这个响应 Header 了。<br>所以，如果是 HTTP/1.0 的话，持久连接和即时压缩只能二选其一。<br>在 HTTP/1.0 中这两者都支持，却默认都是不启用。</p><h4 id="分块编码"><a href="#分块编码" class="headerlink" title="分块编码"></a>分块编码</h4><p>HTTP/1.1中，增加了另一种资源结束判断的机制，“分块传输编码”（Chunked Transfer Encoding）。</p><p>工作原理：在响应 Header 中加入“Transfer-Encoding: chunked”之后，就代表这个响应报文将采用分块编码。此时，报文中的 Body 需要改为用一系列“分块”来传输。每个分块包含十六进制的长度值和对应长度的数据内容，长度值独占一行，数据从下一行开始。最后以一个长度值为 0 的分块，来表示资源结束。</p><h3 id="快速-UDP-网络连接"><a href="#快速-UDP-网络连接" class="headerlink" title="快速 UDP 网络连接"></a>快速 UDP 网络连接</h3><p>想从根本上改进 HTTP，就必须直接替换掉 HTTP over TCP 的根基，即 TCP 传输协议。2018 年末，IETF 正式批准了 HTTP over QUIC 使用 HTTP/3 的版本号，它会以 UDP 协议作为基础。</p><h2 id="内容分发网络-CDN"><a href="#内容分发网络-CDN" class="headerlink" title="内容分发网络(CDN)"></a>内容分发网络(CDN)</h2><p>CDN 其实就是做“内容分销”工作的。</p><p>内容分发网络的工作过程，主要涉及到路由解析、内容分发、负载均衡和它所能支持的应用内容四个方面。</p><p>仅从网络传输的角度来看，一个互联网系统的速度快慢，主要取决于以下四点因素：</p><ol><li>网站服务器接入网络运营商的链路所能提供的出口带宽。</li><li>用户客户端接入网络运营商的链路所能提供的入口带宽。</li><li>从网站到用户之间，经过的不同运营商之间互联节点的带宽。</li><li>从网站到用户之间的物理链路传输时延。</li></ol><h3 id="路由解析"><a href="#路由解析" class="headerlink" title="路由解析"></a>路由解析</h3><p><img src="https://gitee.com/lights8080/lights8080-oss/raw/master/2021/08/kCQhKS.png" alt="CDN 路由解析"></p><h3 id="内容分发"><a href="#内容分发" class="headerlink" title="内容分发"></a>内容分发</h3><p>无论是对用户还是服务器，内容分发网络都可以是完全透明的，CDN需要解决两个问题：“如何获取源站资源”和“如何管理（更新）资源”。</p><h4 id="第一种：主动分发（Push）"><a href="#第一种：主动分发（Push）" class="headerlink" title="第一种：主动分发（Push）"></a>第一种：主动分发（Push）</h4><p>主动分发就是由源站主动发起，将内容从源站或者其他资源库推送到用户边缘的各个 CDN 缓存节点上。</p><p>通常需要源站、CDN 服务双方提供的程序 API 接口层面的配合。</p><h4 id="第二种：被动回源（Pull）"><a href="#第二种：被动回源（Pull）" class="headerlink" title="第二种：被动回源（Pull）"></a>第二种：被动回源（Pull）</h4><p>由用户访问所触发的全自动、双向透明的资源缓存过程。当某个资源首次被用户请求的时候，CDN 缓存节点如果发现自己没有该资源，就会实时从源站中获取。</p><p>可以做到完全的双向透明，不需要源站在程序上做任何的配合，使用起来非常方便。</p><h4 id="如何管理（更新）资源"><a href="#如何管理（更新）资源" class="headerlink" title="如何管理（更新）资源"></a>如何管理（更新）资源</h4><p>对于Cache-Control的 s-maxage，是否遵循，完全取决于 CDN 本身的实现策略。</p><p>CDN 缓存的管理没有通用的准则，最常见的管理（更新）资源的做法是超时被动失效与手工主动失效相结合。</p><h3 id="CDN-应用"><a href="#CDN-应用" class="headerlink" title="CDN 应用"></a>CDN 应用</h3><ul><li>加速静态资源</li><li>安全防御，DDoS攻击</li><li>协议升级，https，IPv6</li><li>状态缓存</li><li>修改资源，给源站不支持跨域的资源提供跨域能力</li><li>访问控制，QoS控制，referer防盗链</li><li>注入功能，Google Analytics等</li></ul><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>“负载均衡器”（Load Balancer）：承担了调度后方的多台机器，以统一的接口对外提供服务的技术组件。</p><p>从形式上来说都可以分为两种：四层负载均衡和七层负载均衡。四层负载均衡的优势是性能高，七层负载均衡的优势是功能强。</p><table><thead><tr><th></th><th><div style="width:135px"><strong>层</strong></div></th><th><div style="width:75px"><strong>数据单元</strong></div></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>7</td><td>应用层 <br/>Application Layer</td><td>数据<br/>Data</td><td>提供为应用软件提供服务的接口，用于与其他应用软件之间的通信。典型协议：HTTP、HTTPS、FTP、Telnet、SSH、SMTP、POP3 等</td></tr><tr><td>6</td><td>表达层<br/>Presentation Layer</td><td>数据 <br/>Data</td><td>把数据转换为能与接收者的系统格式兼容并适合传输的格式。</td></tr><tr><td>5</td><td>会话层 <br/>Session Layer</td><td>数据 <br/>Data</td><td>负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接。</td></tr><tr><td>4</td><td>传输层 <br/>Transport Layer</td><td>数据段<br/>Segments</td><td>把传输表头加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。典型协议：TCP、UDP、RDP、SCTP、FCP 等</td></tr><tr><td>3</td><td>网络层 <br/>Network Layer</td><td>数据包<br/>Packets</td><td>决定数据的传输路径选择和转发，将网络表头附加至数据段后以形成报文（即数据包）。典型协议：IPv4/IPv6、IGMP、ICMP、EGP、RIP 等</td></tr><tr><td>2</td><td>数据链路层 <br/>Data Link Layer</td><td>数据帧<br/>Frame</td><td>负责点对点的网络寻址、错误侦测和纠错。当表头和表尾被附加至数据包后，就形成数据帧（Frame）。典型协议：WiFi（802.11）、Ethernet（802.3）、PPP 等。</td></tr><tr><td>1</td><td>物理层<br/>Physical Layer</td><td>比特流<br/>Bit</td><td>在局域网上传送数据帧，它负责管理电脑通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机接口卡等。</td></tr></tbody></table><h4 id="四层负载均衡"><a href="#四层负载均衡" class="headerlink" title="四层负载均衡"></a>四层负载均衡</h4><p>四层负载均衡的工作模式都属于“转发”，即直接将承载着 TCP 报文的底层数据格式（IP 数据包或以太网帧），转发到真实服务器上，此时客户端到响应请求的真实服务器维持着同一条 TCP 通道。</p><p><strong>数据链路层负载均衡</strong><br>数据链路层传输的内容是数据帧（Frame），只需要注意到“MAC 目标地址”和“MAC 源地址”两项即可。</p><p>工作原理：修改请求的数据帧中的 MAC 目标地址，让用户原本是发送给负载均衡器的请求的数据帧，被二层交换机根据新的 MAC 目标地址，转发到服务器集群中，对应的服务器的网卡上，这样真实服务器就获得了一个原本目标并不是发送给它的数据帧。</p><p>数据链路层负载均衡的工作模式是，只有请求会经过负载均衡器，而服务的响应不需要从负载均衡器原路返回，整个请求、转发、响应的链路形成了一个“三角关系”，又叫“三角传输模式”，“单臂模式”，“直接路由”。</p><p>二层负载均衡器工作原理决定了，它们必须位于同一个子网当中，无法跨 VLAN。这个优势（效率高）和劣势（不能跨子网）就共同决定了，数据链路层负载均衡最适合用来做数据中心的第一级均衡设备，用来连接其他的下级负载均衡器。</p><p><strong>网络层负载均衡</strong><br>网络层传输的单位是分组数据包（Packets），只要知道在 IP 分组数据包的 Headers 带有源和目标的 IP 地址即可。</p><p>第一种：保持原来的数据包不变，新创建一个数据包。(IP隧道)<br>优点：</p><ul><li>并没有修改原有数据包中的任何信息，仍然具备三角传输特性</li><li>IP 隧道工作在网络层，所以可以跨越 VLAN</li></ul><p>缺点：</p><ul><li>真实服务器收到数据包后，必须在接收入口处，设计拆包机制。(几乎所有Linux系统都支持IP隧道协议)</li><li>必须保证所有的真实服务器与均衡器有着相同的虚拟 IP 地址</li></ul><p>第二种：改变目标数据包，直接把数据包 Headers 中的目标地址改掉(NAT 模式)<br>NAT模式：充当了家里、公司、学校的上网路由器的作用。</p><p>优点：</p><ul><li>没有经过 IP 隧道的额外包装，无需再拆包了</li><li>彻底的透明，真实服务器连网关都不需要配置，均衡器在转发时不仅修改目标 IP 地址，连源 IP 地址也一起改了</li></ul><p>缺点：</p><ul><li>不具备三角传输特性，必须回到负载均衡，改回自己的IP，再发给客户端。流量压力比较大时，带来较大的性能损失</li><li>真实服务器处理请求时就无法拿到客户端的 IP 地址</li></ul><h4 id="应用层负载均衡"><a href="#应用层负载均衡" class="headerlink" title="应用层负载均衡"></a>应用层负载均衡</h4><p>工作在四层之后的负载均衡模式就无法再进行转发了，只能进行代理。此时正式服务器、负载均衡器、客户端三者之间，是由两条独立的 TCP 通道来维持通讯的。</p><p><img src="https://gitee.com/lights8080/lights8080-oss/raw/master/2021/08/uHa47g.jpg" alt="转发与代理"></p><p>分类：</p><ul><li>正向代理就是我们通常简称的代理，意思就是在客户端设置的、代表客户端与服务器通讯的代理服务。它是客户端可知，而对服务器是透明的。</li><li>反向代理是指设置在服务器这一侧，代表真实服务器来与客户端通讯的代理服务。此时它对客户端来说是透明的。</li><li>透明代理是指对双方都透明的，配置在网络中间设备上的代理服务。比如，架设在路由器上的透明翻墙代理。</li></ul><p>七层负载均衡器，不能去做下载站、视频站这种流量应用，起码不能作为第一级均衡器。<br>缺点：网络性能比不过四层负载均衡器，多一轮TCP握手，还有 NAT 转发模式一样的带宽问题<br>优点：可以感知应用层通讯的具体内容，往往能够做出更明智的决策</p><p>应用：</p><ul><li>缓存方面的工作，比如静态资源缓存、协议升级、安全防护、访问控制等</li><li>更智能化的路由，比如Session 路由、亲和性集群、URL路由、根据用户路由等</li><li>某些安全攻击可以由七层负载均衡器来抵御，比如DDoS 手段是 SYN Flood 攻击</li><li>链路治理措施，比如服务降级、熔断、异常注入等</li><li>…</li></ul><h4 id="均衡策略与实现"><a href="#均衡策略与实现" class="headerlink" title="均衡策略与实现"></a>均衡策略与实现</h4><p>均衡策略与实现</p><ul><li>轮循均衡</li><li>权重轮循均衡</li><li>随机均衡</li><li>权重随机均衡</li><li>一致性哈希均衡</li><li>响应速度均衡</li><li>最少连接数均衡</li></ul><p>负载均衡器的实现有“软件均衡器”和“硬件均衡器”两类。</p><p>软件均衡器又分为直接建设在操作系统内核的均衡器和应用程序形式的均衡器两种。前者的代表是 LVS（Linux Virtual Server），后者的代表有 Nginx、HAProxy、KeepAlived，等等；前者的性能会更好，因为它不需要在内核空间和应用空间中来回复制数据包；而后者的优势是选择广泛，使用方便，功能不受限于内核版本。</p><p>硬件均衡器，往往会直接采用应用专用集成电路来实现。因为它有专用处理芯片的支持，可以避免操作系统层面的损耗，从而能够达到最高的性能。这类的代表就是著名的 F5 和 A10 公司的负载均衡产品。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;周志明《凤凰架构：构建可靠的大型分布式系统》&lt;br&gt;&lt;a href=&quot;https://icyfenix.cn/&quot;&gt;https://icyfenix.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;包括：域名解析，客户端缓存，传输链路，传输压缩，内容分发，负载均衡&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="技术" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="凤凰架构" scheme="http://www.lights8080.com/tags/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>2108-1-什么才是给孩子最好的礼物</title>
    <link href="http://www.lights8080.com/p/f438d8cc.html"/>
    <id>http://www.lights8080.com/p/f438d8cc.html</id>
    <published>2021-08-05T16:00:00.000Z</published>
    <updated>2021-09-02T02:03:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>如题</p><span id="more"></span><h2 id="话题：什么才是给孩子最好的礼物"><a href="#话题：什么才是给孩子最好的礼物" class="headerlink" title="话题：什么才是给孩子最好的礼物"></a>话题：什么才是给孩子最好的礼物</h2><p>如果说“给孩子最好的礼物是陪伴”，相信大部分人都不会反驳，且还能说出一大堆的理由来。</p><p>我试着脑补了一下，在孩子的不同时期，问他俩个问题：<br>“”“<br>孩子10岁，你问他什么最重要？他会回答是陪伴；<br>20岁问他什么最重要，他会说钱；你再问快乐的童年重要吗，他会想想说也重要。<br>30岁问他什么最重要，他会告诉你是环境和成长经历；快乐的童年重要吗，没那么重要。<br>“”“</p><p>如果在读的你现在已经三十几岁已经有孩子，对于上面这个回答并不排斥吧    </p><p>为什么家长从小就给孩子报各种补习班？那是因为我们都知道相比于快乐的童年，孩子的未来更重要，孩子将来长大了一定不会怪我。</p><p>我们都很想时刻陪在孩子身边，但是总得想想孩子20岁，30岁时最需要的是什么。真的在乎童年的陪伴吗？</p><p>我这样说，并不是我认为小时候对孩子的陪伴不重要。相反，我也认为很重要，但我想表达的是陪伴的重要性是要建立在生长环境、成长经历和财务支持等基础之上的。</p><p>如果你有能力把这些都平衡好，那真的很完美，对于普通人而言，必须有所取舍。</p><p>很遗憾没有给你美好的童年，如果现在有机会能让你在20岁，30岁时多一点点的选择，那就够了。</p><hr><p>这个思考来源于，最近二姐一家五口驱车从天津出发开往西藏。一次说走就走的旅行，这一定是很多人羡慕和向往的生活方式。</p><p>在这之前说实话我对姐夫有一定的偏见，而且是很固执的，根本原因就是没有对家庭的陪伴。</p><p>“我也想天天在家里陪着他们，你知道仨孩子上学要多少钱，将来出国留学，结婚要多少钱。我不出去挣钱，日子怎么过，她们不理解我，咱俩是男的，我以为你能理解我”<br>上面这句话是我俩单独聊天他说的（并非原话，意思一样）。</p><p>说实话，当时我并没有理解。但是随着年龄的增长，我越来越能get到他的点。<br>抛去那些分支乱插，从现在的结果来看，我觉得他并没有敷衍，而且正在一步一步的践行自己的承诺。</p><p>初心未变，负重前行。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如题&lt;/p&gt;</summary>
    
    
    
    <category term="weekly" scheme="http://www.lights8080.com/categories/weekly/"/>
    
    
    <category term="weekly" scheme="http://www.lights8080.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>凤凰架构-分布式事务</title>
    <link href="http://www.lights8080.com/p/c901dee9.html"/>
    <id>http://www.lights8080.com/p/c901dee9.html</id>
    <published>2021-08-04T16:00:00.000Z</published>
    <updated>2021-09-07T03:50:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>周志明《凤凰架构：构建可靠的大型分布式系统》<br><a href="https://icyfenix.cn/">https://icyfenix.cn/</a></p><p>包括：CAP、BASE理论。实现分布式事务的三种解决方案，可靠消息队列、TCC、SAGA事务。</p><p>可靠消息队列：简单、无法解决隔离性问题<br>TCC：编码实现业务隔离性，但要求技术可控性（预留资源接口），硬编码可以使用Seata<br>SAGA事务：编码实现业务隔离性和补偿机制，不要求技术可控性，硬编码可以使用Seata</p><span id="more"></span><p>分布式事务（Distributed Transaction）特指<strong>多个服务同时访问多个数据源</strong>的事务处理机制。</p><h4 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h4><p>分布式系统（distributed system）的最大难点，就是各个节点的状态如何同步。CAP 定理是这方面的基本定理。</p><ul><li><p>一致性（Consistency）：代表在任何时刻、任何分布式节点中所看到的数据都是符合预期的。</p></li><li><p>可用性（Availability）：代表系统不间断地提供服务的能力。密切相关两个指标：可靠性（平均无故障时间：MTBF）和可维护性（平均可修复时间：MTTR）。</p></li><li><p>分区容忍性（Partition Tolerance）：代表分布式环境中部分节点因网络原因而彼此失联（即与其他节点形成“网络分区”）时，系统仍能正确地提供服务的能力。</p></li><li><p>如果放弃分区容忍性（CA without P），意味着我们将假设节点之间通信永远是可靠的。永远可靠的通信在分布式系统中必定不成立的。主流的 RDBMS（关系数据库管理系统）集群通常就是采用放弃分区容错性的工作模式。</p></li><li><p>如果放弃可用性（CP without A），意味着我们将假设一旦网络发生分区，节点之间的信息同步时间可以无限制地延长，此时，问题相当于退化到前面“全局事务”中讨论的一个系统使用多个数据源的场景之中，我们可以通过 2PC/3PC 等手段，同时获得分区容忍性和一致性。著名的 HBase 也是属于 CP 系统。</p></li><li><p>如果放弃一致性（AP without C），意味着我们将假设一旦发生分区，节点之间所提供的数据可能不一致。选择放弃一致性的 AP 系统目前是设计分布式系统的主流选择，因为 P 是分布式网络的天然属性，而 A 通常是建设分布式的目的。目前大多数 NoSQL 库和支持分布式的缓存框架都是 AP 系统，如Redis集群。</p></li></ul><p>CAP、ACID 中讨论的一致性称为“强一致性”（Strong Consistency）。把牺牲了 C 的 AP 系统，叫做“最终一致性”（Eventual Consistency）。它是指，如果数据在一段时间内没有被另外的操作所更改，那它最终将会达到与强一致性过程相同的结果，有时候面向最终一致性的算法，也被称为“乐观复制算法”。</p><h4 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h4><p>BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的结论，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。</p><p>BASE 分别是基本可用性（Basically Available）、柔性事务（Soft State）和最终一致性（Eventually Consistent）的缩写。</p><ul><li>基本可用性（Basically Available）：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。</li><li>柔性事务（Soft State）：允许系统存在中间状态，而该中间状态不会影响系统整体可用性。这里的中间状态就是 CAP 理论中的数据不一致。</li><li>最终一致性（Eventually Consistent）：系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。</li></ul><h2 id="可靠消息队列"><a href="#可靠消息队列" class="headerlink" title="可靠消息队列"></a>可靠消息队列</h2><p>前面这种靠着持续重试来保证可靠性的操作，在计算机中就非常常见，它有个专门的名字，叫做“最大努力交付”（Best-Effort Delivery），比如 TCP 协议中的可靠性保障，就属于最大努力交付。</p><p>支持分布式事务的消息框架，如 RocketMQ，原生就支持分布式事务操作。</p><h2 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h2><p>可靠消息队列虽然能保证最终的结果是相对可靠的，过程也足够简单（相对于 TCC 来说），但整个过程完全没有任何隔离性可言，有一些业务中隔离性是无关紧要的，但有一些业务中缺乏隔离性就会带来许多麻烦。譬如：超售。</p><p>TCC 是另一种常见的分布式事务机制，它是“Try-Confirm-Cancel”三个单词的缩写。</p><p>TCC 的实现过程分为了三个阶段：</p><ul><li>Try：尝试执行阶段，完成所有业务可执行性的检查（保障一致性），并且预留好全部需用到的业务资源（保障隔离性）。</li><li>Confirm：确认执行阶段，不进行任何业务检查，直接使用 Try 阶段准备的资源来完成业务处理。Confirm 阶段可能会重复执行，因此本阶段所执行的操作需要具备幂等性。</li><li>Cancel：取消执行阶段，释放 Try 阶段预留的业务资源。Cancel 阶段可能会重复执行，也需要满足幂等性。</li></ul><p>它是一种业务侵入性较强的事务方案，要求业务处理过程必须拆分为“预留业务资源”和“确认 / 释放消费资源”两个子过程。</p><p>TCC 其实有点类似 2PC 的准备阶段和提交阶段，但 TCC 是位于用户代码层面，而不是在基础设施层面，这为它的实现带来了较高的灵活性，可以根据需要设计资源锁定的粒度。TCC 在业务执行时只操作预留资源，几乎不会涉及锁和资源的争用，具有很高的性能潜力。但是 TCC 并非纯粹只有好处，它也带来了更高的开发成本和业务侵入性，意味着有更高的开发成本和更换事务实现方案的替换成本。</p><p>通常我们并不会完全靠裸编码来实现 TCC，而是基于某些分布式事务中间件（譬如阿里开源的Seata）去完成，尽量减轻一些编码工作量。</p><h2 id="SAGA事务"><a href="#SAGA事务" class="headerlink" title="SAGA事务"></a>SAGA事务</h2><p>TCC 事务具有较强的隔离性，避免了“超售”的问题，而且其性能一般来说是本篇提及的几种柔性事务模式中最高的，但它仍不能满足所有的场景。TCC 的最主要限制是它的业务侵入性很强，不止是它需要开发编码配合所带来的工作量，而更多的是指它所要求的技术可控性上的约束。譬如，网银支付，通常也就无法完成冻结款项、解冻、扣减这样的操作。</p><p>SAGA 事务基于数据补偿代替回滚的解决思路。大致思路是把一个大事务分解为可以交错运行的一系列子事务集合。每个子事务都应该是或者能被视为是原子行为；为每一个子事务设计对应的补偿动作。</p><p>两种恢复策略：<br>正向恢复（Forward Recovery）：T1，T2，…，Ti（失败），Ti（重试）…，Ti+1，…，Tn<br>反向恢复（Backward Recovery）：T1，T2，…，Ti（失败），Ci（补偿），…，C2，C1。</p><p>与 TCC 相比，SAGA 不需要为资源设计冻结状态和撤销冻结的操作，补偿操作往往要比冻结操作容易实现得多。</p><p>SAGA 事务通常也不会直接靠裸编码来实现，一般也是在事务中间件的基础上完成，前面提到的 Seata 就同样支持 SAGA 事务模式。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;周志明《凤凰架构：构建可靠的大型分布式系统》&lt;br&gt;&lt;a href=&quot;https://icyfenix.cn/&quot;&gt;https://icyfenix.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;包括：CAP、BASE理论。实现分布式事务的三种解决方案，可靠消息队列、TCC、SAGA事务。&lt;/p&gt;
&lt;p&gt;可靠消息队列：简单、无法解决隔离性问题&lt;br&gt;TCC：编码实现业务隔离性，但要求技术可控性（预留资源接口），硬编码可以使用Seata&lt;br&gt;SAGA事务：编码实现业务隔离性和补偿机制，不要求技术可控性，硬编码可以使用Seata&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="技术" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="凤凰架构" scheme="http://www.lights8080.com/tags/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84/"/>
    
    <category term="事务" scheme="http://www.lights8080.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>凤凰架构-全局事务和共享事务</title>
    <link href="http://www.lights8080.com/p/53149592.html"/>
    <id>http://www.lights8080.com/p/53149592.html</id>
    <published>2021-08-03T16:00:00.000Z</published>
    <updated>2021-09-07T03:50:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>周志明《凤凰架构：构建可靠的大型分布式系统》<br><a href="https://icyfenix.cn/">https://icyfenix.cn/</a></p><p>XA、JTA、两阶段提交、三阶段提交</p><span id="more"></span><h2 id="全局事务"><a href="#全局事务" class="headerlink" title="全局事务"></a>全局事务</h2><p>在本节里，全局事务被限定为一种<strong>适用于单个服务使用多个数据源场景</strong>的事务解决方案。</p><p>为了解决分布式事务的一致性问题，X/Open组织提出了一套名为X/Open XA（XA 是 eXtended Architecture 的缩写）的处理事务架构，其核心内容是定义了全局的事务管理器（Transaction Manager，用于协调全局事务）和局部的资源管理器（Resource Manager，用于驱动本地事务）之间的通信接口。</p><p>XA 接口是双向的，能在一个事务管理器和多个资源管理器（Resource Manager）之间形成通信桥梁，通过协调多个数据源的一致动作，实现全局事务的统一提交或者统一回滚。</p><p>JTA（Java Transaction API）是基于 XA 模式在 Java 语言中的实现了全局事务处理的标准。</p><p>XA 将事务提交拆分成为两阶段过程，两阶段式提交（2 Phase Commit，2PC）：</p><ul><li>准备阶段（又叫作投票阶段，对于数据库来说，它与本地事务中真正提交的区别只是暂不写入最后一条 Commit Record 而已，并不立即释放隔离性，即仍继续持有锁）</li><li>提交阶段（又叫作执行阶段，对于数据库来说，这个阶段的提交操作应是很轻量的，仅仅是持久化一条 Commit Record 而已，通常能够快速完成）</li></ul><p>缺点：</p><ul><li>单点问题：协调者宕机，所有参与者都必须一直等待</li><li>性能问题：两段提交过程中，所有参与者相当于被绑定成为一个统一调度的整体，期间要经过两次远程服务调用，三次数据持久化（准备阶段写重做日志，协调者做状态持久化，提交阶段在日志写入 Commit Record）</li><li>一致性风险：前面已经提到，两段式提交的成立是有前提条件的，当网络稳定性和宕机恢复能力的假设不成立时，仍可能出现一致性问题。</li></ul><p>为了缓解两段式提交协议的一部分缺陷，具体地说是协调者的单点问题和准备阶段的性能问题，后续又发展出了“三段式提交”（3 Phase Commit，3PC）协议。<br>三段式提交把原本的两段式提交的准备阶段再细分为两个阶段，分别称为 CanCommit、PreCommit，把提交阶段改称为 DoCommit 阶段。</p><h2 id="共享事务"><a href="#共享事务" class="headerlink" title="共享事务"></a>共享事务</h2><p>共享事务（Share Transaction）是指<strong>多个服务共用同一个数据源</strong>。这里有必要再强调一次“数据源”与“数据库”的区别：数据源是指提供数据的逻辑设备，不必与物理设备一一对应。</p><p>如果直接将不同数据源视为不同的数据库，那完全可以用全局事务或者下一讲要学习的分布式事务来实现。</p><p>如果针对每个数据源连接的都是同一个物理数据库的特例，一种理论可行的方案是，直接让各个服务共享数据库连接。同一个应用进程中共享数据库连接并不困难，但不同服务节点共享数据库连接很难做到，为了实现共享事务，就必须新增一个中间角色。</p><p>这在分布式的场景下是个伪需求，你有充足理由让多个微服务去共享数据库，那就必须找到更加站得住脚的理由，来向团队解释拆分微服务的目的是什么。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;周志明《凤凰架构：构建可靠的大型分布式系统》&lt;br&gt;&lt;a href=&quot;https://icyfenix.cn/&quot;&gt;https://icyfenix.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;XA、JTA、两阶段提交、三阶段提交&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="技术" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="凤凰架构" scheme="http://www.lights8080.com/tags/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84/"/>
    
    <category term="事务" scheme="http://www.lights8080.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>大数据中台架构</title>
    <link href="http://www.lights8080.com/p/27c771b.html"/>
    <id>http://www.lights8080.com/p/27c771b.html</id>
    <published>2021-08-01T16:00:00.000Z</published>
    <updated>2021-09-08T10:09:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>以奈学教育大数据架构师训练营为大纲，关于数据仓库的学习笔记</p><span id="more"></span><h2 id="大数据中台架构"><a href="#大数据中台架构" class="headerlink" title="大数据中台架构"></a>大数据中台架构</h2><p><img src="https://gitee.com/lights8080/lights8080-oss/raw/master/2021/08/5BVKI1.jpg" alt="大数据中台架构设计实践"></p><p>大数据中台演进三阶段：</p><p>定位和价值：</p><ul><li>降低数据使用门槛</li><li>提升决策利用效率</li><li>数据驱动业务增长</li></ul><p>第一阶段：</p><ul><li>定位：快速描述业务事实，提供数据分析的原材料</li><li>价值：为决策提供支持，评估业务效果</li><li>形式：数据提取-&gt;数据计算-&gt;数据仓库建设-&gt;指标体系-&gt;报表</li></ul><p>第二阶段：</p><ul><li>定位：波动根因分析</li><li>价值：辅助/诊断业务</li><li>形式：专题分析-&gt;分析框架-&gt;分析工具-&gt;多维分析模型</li></ul><p>第三阶段：</p><ul><li>定位：数据化运营实践落地</li><li>价值：业务数据统计分析-&gt;数据驱动运营闭环-&gt;良性循环</li><li>形式：分析报告</li></ul><p>大数据仓库中台建设目标：</p><ul><li>响应：监视事件计量标准，与历史数据相关联，制定及时的应对策略</li><li>分析：分析盈利价值链，内部运营的状况和风险，外部市场变化</li><li>决策：大数据中找出价值信息，对管理和分析人员精准及时的报告</li><li>计划：预测和趋势分析，感知风险</li></ul><p>大数据仓库中台建设实现功能：</p><ul><li>逻辑分层：数据采集层-&gt;原始数据层-&gt;数据仓库层-&gt;数据集市层-&gt;数据应用层</li><li>数仓规范：开发标准，命名规范，开放的数据存储、建模、计算能力</li><li>主题域划分：一致性维度与事实；业务数据矩阵（明确各业务分析的主题模块、业务过程所属的数据域）</li><li>数据建模：构建维度和事实总线矩阵，维度和事实模型设计；明确统计指标，指标结果表设计；维度总线矩阵（明确维度和业务过程之间的关系）</li><li>数据治理：元数据管理，数据安全，数据治理，数据生命周期管理</li><li>智能分析：数据挖掘（精细化运营、竞对抓取分析、商业广告），实时预测分析，多维根因分析</li></ul><h2 id="数据仓库建模"><a href="#数据仓库建模" class="headerlink" title="数据仓库建模"></a>数据仓库建模</h2><h5 id="事实表"><a href="#事实表" class="headerlink" title="事实表"></a>事实表</h5><p>又叫事实数据表，主要特点是含有大量的数据，并且这些数据是可以汇总，并被记录的。</p><p>表格里存储了能体现实际数据或详细数值，一般由维度编码和事实数据组成。事实表作为数据仓库维度建模的核心，紧紧围绕着业务过程进行设计。</p><p>事实数据表不应该包含描述性的信息，也不应该包含除数字度量字段及使事实与纬度表中对应项的相关索引字段之外的任何数据。</p><p>事实表数据列组成部分：</p><ul><li>键值列</li><li>度量值（分为可以累计的度量值，非累计的度量值）</li></ul><p>事实表分类：</p><ul><li>事务型事实表（每个事务或事件产生一行数据）</li><li>周期型快照事实表（保留固定时间间隔的数据）</li><li>累积型快照事实表（用于跟踪业务事实的变化）</li></ul><h5 id="维度表"><a href="#维度表" class="headerlink" title="维度表"></a>维度表</h5><p>数据仓库中的表，其条目描述事实数据表中的数据。</p><p>表格里存放了具有独立属性和层次结构的数据，一般由维度编码和对应的维度说明组成。</p><p>维度表可以看作是用户来分析数据的窗口，纬度表中包含事实数据表中事实记录的特性，有些特性提供描述性信息，有些特性指定如何汇总事实数据表数据，以便为分析者提供有用的信息，维度表包含帮助汇总数据的特性的层次结构。</p><h4 id="逻辑分层"><a href="#逻辑分层" class="headerlink" title="逻辑分层"></a>逻辑分层</h4><p><img src="https://gitee.com/lights8080/lights8080-oss/raw/master/2021/08/EbqvFO.jpg" alt="离线数据仓库中台系统架构—逻辑分层"></p><ul><li>ODS（操作数据层，Operational Data Store）：将原始数据几乎无处理地存放在数据仓库系统中，看数据量和存储预算决定保留时间</li><li>DM（Data Warehouse）/CDM（数据公共层，Common Dimenions Model）：包括DIM、DWD、DWM、DWS，采取更多的宽表化手段构建公共指标数据层，提升公共指标的复用性，减少重复加工<ul><li>DIM（维表，Dimension）：以维度作为建模驱动</li><li>DWD（明细事实表，Data Warehouse Detail）：以业务过程作为建模驱动，基于每个具体的业务过程特点，构建最细粒度的明细事实表</li><li>DWM（轻度汇总层，Data WareHouse Middle）</li><li>DM（数据集市/宽表，Data Market）/DWS（汇总数据层，Data Warehouse Summary）：以分析的主题对象作为建模驱动</li></ul></li><li>ADS（应用数据层，Application Data Store）：存放数据产品个性化的统计指标数据</li></ul><h5 id="粒度"><a href="#粒度" class="headerlink" title="粒度"></a>粒度</h5><p>粒度就是业务流程中对度量的单位，比如商品是按件记录度量，还是按批记录度量。</p><h5 id="度量"><a href="#度量" class="headerlink" title="度量"></a>度量</h5><p>度量是业务流程节点上的一个数值。比如销量，价格，成本等等。</p><h5 id="宽表"><a href="#宽表" class="headerlink" title="宽表"></a>宽表</h5><p>通常是指业务主题相关的指标、维度、主题属性关联在一起的一张数据库表。</p><h4 id="逻辑分层-业务架构"><a href="#逻辑分层-业务架构" class="headerlink" title="逻辑分层(业务架构)"></a>逻辑分层(业务架构)</h4><p><img src="https://gitee.com/lights8080/lights8080-oss/raw/master/2021/08/4EEWgS.jpg" alt="离线数据仓库中台系统架构—逻辑分层(业务架构)"></p><p>数仓数据分层好处：</p><ul><li>【易维护】高效的数据组织形式，清洗和过滤，规范化，血缘追踪</li><li>【高性能】时间价值，数据集合，维度汇总，查询效率</li><li>【简单化】集成价值，多维度数据整合，多角度多层次的数据分析</li><li>【历史性】历史数据，回溯历史，预测未来</li></ul><h4 id="数据建模"><a href="#数据建模" class="headerlink" title="数据建模"></a>数据建模</h4><p>DWD层需构建维度模型：选择业务过程→声明粒度→确认维度→确认事实</p><h5 id="维度总线矩阵"><a href="#维度总线矩阵" class="headerlink" title="维度总线矩阵"></a>维度总线矩阵</h5><p><img src="https://gitee.com/lights8080/lights8080-oss/raw/master/2021/08/ZOAcu7.jpg" alt="维度总线矩阵"></p><h2 id="Skynet调度中台"><a href="#Skynet调度中台" class="headerlink" title="Skynet调度中台"></a>Skynet调度中台</h2><p><img src="https://gitee.com/lights8080/lights8080-oss/raw/master/2021/08/dFtbBY.jpg" alt="Skynet调度中台—总体架构设计与实践"></p><h2 id="Lambda-VS-Kappa架构"><a href="#Lambda-VS-Kappa架构" class="headerlink" title="Lambda VS Kappa架构"></a>Lambda VS Kappa架构</h2><p><a href="https://www.cnblogs.com/xiaodf/p/11642555.html">https://www.cnblogs.com/xiaodf/p/11642555.html</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://help.aliyun.com/document_detail/126215.html?spm=a2c4g.11186623.6.586.245d38acj9VNpD">阿里云-数仓分层</a><br><a href="https://www.cnblogs.com/shengyang17/p/10558342.html#_lab2_0_1">数据仓库 |1.3 数仓分层| 建模</a><br><a href="https://www.cnblogs.com/shengyang17/p/10545198.html#_lab2_0_1">数据仓库| 1.4 ODS&amp; DWD&amp; DWS&amp;DWT&amp; ADS</a><br><a href="https://blog.csdn.net/u010999396/article/details/68488981">数据仓库事实表和维表</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;以奈学教育大数据架构师训练营为大纲，关于数据仓库的学习笔记&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://www.lights8080.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="大数据" scheme="http://www.lights8080.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    <category term="数据仓库" scheme="http://www.lights8080.com/tags/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"/>
    
    <category term="中台" scheme="http://www.lights8080.com/tags/%E4%B8%AD%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>2107-5-终身成长</title>
    <link href="http://www.lights8080.com/p/a62366c0.html"/>
    <id>http://www.lights8080.com/p/a62366c0.html</id>
    <published>2021-07-29T16:00:00.000Z</published>
    <updated>2021-09-24T10:44:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>如题</p><span id="more"></span><h2 id="话题：《终身成长》"><a href="#话题：《终身成长》" class="headerlink" title="话题：《终身成长》"></a>话题：《终身成长》</h2><p>《终身成长》整本书都在介绍固定型思维模式和成长型思维模式对人产生的影响。</p><p>认真观察身边的人会发现，那些职级高能力强的人，比较符合成长型思维模式；而那些在基层深耕多年的人，更匹配固定型思维模式。虽然会有个例，但是请相信，那些靠运气赢来的，终会凭能力输回去。当然这其中还会有个例存在。</p><p>“只有缺乏天赋的人才需要努力”，曾就一个同事跟我说过类似的话”能力不行才加班“。固定思维的人害怕让别人知道自己不够聪明，还会通过抱怨和责怪别人来保护他们自己，认为别人成功是靠运气而不是努力，常常把自己的问题归于外部因素导致。成长型思维的人承认自己的不完美，愿意听取不同建议。面对挑战的更关注如何提高自己。</p><p>固定型思维的人喜欢包装自己，成长型思维的人喜欢剖析自己。</p><h2 id="语录"><a href="#语录" class="headerlink" title="语录"></a>语录</h2><ol><li><p>固定型思维模式让你更关心别人如何看待你；而成长型思维模式让你更关心你能否提高自己。</p></li><li><p>固定型思维模式者告诉我们：“如果你需要为某事付出努力，那么你肯定不擅长做这件事。”</p></li><li><p>在固定型思维模式者的眼中，努力是有缺陷和不足的人需要做的。</p></li><li><p>固定型思维模式中，无论是肯定的还是否定的标签都会扰乱你的思绪：当你被贴上肯定的标签时，你害怕会失去它；而当你不幸被贴上否定的标签时，你会害怕自己正如标签所说。</p></li><li><p>不把失败看作愚蠢的象征，而是去认识到这是因为自己缺乏经验和技能。</p></li><li><p>成功意味着做到最好的自己，而不是要强于他人；失败是一次机会，而不是死刑；努力是通往成功的关键。</p></li><li><p>考试成绩和对成就的评估只会告诉你目前这个学生处在什么位置，而不会告诉你将来他会达到什么高度。</p></li></ol><h2 id="对话"><a href="#对话" class="headerlink" title="对话"></a>对话</h2><p>菲利普：天呐，我太笨手笨脚了。<br>父亲：我们把钉子撒了的时候，不应该说这样的话。<br>菲利普：那应该说什么呢？<br>父亲：你应该说，钉子撒了——我要把它们捡起来！<br>菲利普：就这样？<br>父亲：就这样。<br>菲利普：谢谢，爸爸。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如题&lt;/p&gt;</summary>
    
    
    
    <category term="weekly" scheme="http://www.lights8080.com/categories/weekly/"/>
    
    
    <category term="weekly" scheme="http://www.lights8080.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>凤凰架构-本地事务</title>
    <link href="http://www.lights8080.com/p/4bfa4595.html"/>
    <id>http://www.lights8080.com/p/4bfa4595.html</id>
    <published>2021-07-29T16:00:00.000Z</published>
    <updated>2021-09-07T03:50:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>周志明《凤凰架构：构建可靠的大型分布式系统》<br><a href="https://icyfenix.cn/">https://icyfenix.cn/</a></p><p>包括：ACID、如何实现原子性和持久性、如何实现隔离性、事务隔离级别、多版本并发控制-MVCC、悲观锁和乐观锁</p><span id="more"></span><h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><ul><li>一致性（Consistency）：保证系统中所有的数据都是符合期望的，且相互关联的数据之间不会产生矛盾。</li><li>原子性（Atomic）：在同一项业务处理过程中，事务保证了对多个数据的修改，要么同时成功，要么同时被撤销。</li><li>隔离性（Isolation）：在不同的业务处理过程中，事务保证了各自业务正在读、写的数据互相独立，不会彼此影响。</li><li>持久性（Durability）：事务应当保证所有成功被提交的数据修改都能够正确地被持久化，不丢失数据。</li></ul><p>原子性，隔离性和持久性是数据库的属性，是手段，而一致性（在ACID意义上）是应用程序的属性，是目的。应用可能依赖数据库的原子性和隔离属性来实现一致性，但这并不仅取决于数据库。</p><p>本地事务是最基础的一种事务处理方案，通常只<strong>适用于单个服务使用单个数据源的场景</strong>，它是直接依赖于数据源（通常是数据库系统）本身的事务能力来工作的。</p><h2 id="如何实现原子性和持久性"><a href="#如何实现原子性和持久性" class="headerlink" title="如何实现原子性和持久性"></a>如何实现原子性和持久性</h2><p>实现原子性和持久性的最大困难是“写入磁盘”这个操作并不是原子的（比如要写入到不同的磁盘块上），不仅有“写入”与“未写入”状态，还客观地存在着“正在写”的中间状态。</p><p><strong>未提交事务，写入后崩溃</strong>，要将已经修改过的数据从磁盘中恢复成没有改过的样子，以保证原子性。<br><strong>已提交事务，写入前崩溃</strong>，要将没来得及写入磁盘的数据重新写入，以保证持久性。</p><p>由于写入中间状态与崩溃都是无法避免的，为了保证原子性和持久性，就只能在崩溃后采取恢复的补救措施，这种数据恢复操作被称为“崩溃恢复”。</p><p>为了能够顺利地完成崩溃恢复，会以日志的形式先记录到磁盘，日志记录全部落盘后为Commit Record，表示事务成功。根据日志上的信息对真正的数据进行修改，修改完成后为End Record，表示事务已完成持久化。这种事务实现方法被称为Commit Logging。</p><p>Commit Logging的原理很清晰，但缺陷是，即使磁盘 I/O 有足够空闲、即使某个事务修改的数据量非常庞大，都不允许在事务提交前就修改磁盘上的真实数据，这对提升数据库的性能是否不利。<br>为了解决这个问题，ARIES提出所谓“提前写入”（Write-Ahead），就是允许在事务提交之前，提前写入变动数据的意思。</p><p>按照事务提交时点为界，划分为 FORCE 和 STEAL 两类情况：</p><ul><li>FORCE：当事务提交后，要求变动数据必须同时完成写入。</li><li>NO-FORCE：当事务提交后，不强制变动数据必须同时完成写入。</li><li>STEAL：在事务提交前，允许变动数据提前写入。</li><li>NO-STEAL：在事务提交前，不允许变动数据提前写入。(从优化磁盘 I/O 性能考虑，没有必要强制数据写入立即进行)</li></ul><p>从优化磁盘 I/O 性能考虑，没有必要强制数据写入立即进行。允许数据提前写入（NO-STEAL），有利于利用空闲 I/O 资源，也有利于节省数据库缓存区的内存。<br>从优化磁盘 I/O 的角度看，NO-FORCE + STEAL 组合的性能无疑是最高的；从算法实现与日志的角度看 NO-FORCE + STEAL 组合的复杂度无疑也是最高的。<br><img src="https://gitee.com/lights8080/lights8080-oss/raw/master/2021/07/sbc3jM.jpg" alt="FORCE 和 STEAL 的四种组合关系"></p><p>Write-Ahead Logging 允许 NO-FORCE，也允许 STEAL。解决办法是增加了另一种被称为 Undo Log 的日志类型，当变动数据写入磁盘前，必须先记录 Undo Log，以便在事务回滚或者崩溃恢复时根据 Undo Log 对提前写入的数据变动进行擦除。<br>崩溃恢复时会执行以下三个阶段的操作：分析阶段（Analysis）、重做阶段（Redo）、回滚阶段（Undo）。</p><h2 id="如何实现隔离性"><a href="#如何实现隔离性" class="headerlink" title="如何实现隔离性"></a>如何实现隔离性</h2><p>隔离性保证了每个事务各自读、写的数据互相独立，不会彼此影响。</p><p>串行的数据访问，具有天然的隔离性，现代数据库都提供了以下三种锁：</p><ul><li>写锁（Write Lock，也叫做排他锁，简写为 X-Lock）：只有持有写锁的事务才能对数据进行写入操作，数据加持着写锁时，其他事务不能写入数据，也不能施加读锁。</li><li>读锁（Read Lock，也叫做共享锁，简写为 S-Lock）：多个事务可以对同一个数据添加多个读锁，数据被加上读锁后就不能再被加上写锁，所以其他事务不能对该数据进行写入，但仍然可以读取。对于持有读锁的事务，如果该数据只有一个事务加了读锁，那可以直接将其升级为写锁，然后写入数据。</li><li>范围锁（Range Lock）：对于某个范围直接加排他锁，在这个范围内的数据不能被读取，也不能被写入。</li></ul><p><strong>本地事务的四种隔离级别</strong></p><ul><li>可串行化（Serializable）：隔离性级别最高，对事务所有读、写的数据全都加上读锁、写锁和范围锁即可（这种可串行化的实现方案称为 Two-Phase Lock - 2PL）。</li><li>可重复读（Repeatable Read）：对事务所涉及到的数据加读锁和写锁，并且一直持续到事务结束，但不再加范围锁。可重复读比可串行化弱化的地方在于幻读问题</li><li>读已提交（Read Committed）：对事务涉及到的数据加的写锁，会一直持续到事务结束，但加的读锁在查询操作完成后就马上会释放。读已提交比可重复读弱化的地方在于不可重复读问题</li><li>读未提交（Read Uncommitted）：对事务涉及到的数据只加写锁，这会一直持续到事务结束，但完全不加读锁。读未提交比读已提交弱化的地方在于脏读问题</li></ul><p><strong>事务隔离级别解决的问题</strong></p><ul><li>幻读问题：事务执行的过程中，两个完全相同的范围查询得到了不同的结果集</li><li>不可重复读问题：在事务执行过程中，对同一行数据的两次查询得到了不同的结果</li><li>脏读问题：在事务执行的过程中，一个事务读取到了另一个事务未提交的数据</li></ul><p><strong>多版本并发控制”（Multi-Version Concurrency Control，MVCC）</strong><br>这种“一个事务读 + 另一个事务写”的隔离问题，有一种名为“多版本并发控制”的无锁优化方案被主流的商业数据库广泛采用。</p><p>MVCC 的基本思路是对数据库的任何修改都不会直接覆盖之前的数据，而是产生一个新版副本与老版本共存，以此达到读取时可以完全不加锁的目的。</p><ul><li>隔离级别是可串行化：可串行化本来的语义就是要阻塞其他事务的读取操作，与MVCC无锁优化冲突。</li><li>隔离级别是可重复读：总是读取 CREATE_VERSION 小于或等于当前事务 ID 的记录，在这个前提下，如果数据仍有多个版本，则取最新（事务 ID 最大）的。</li><li>隔离级别是读已提交：总是取最新的版本即可，即最近被 Commit 的那个版本的数据记录。</li><li>隔离级别是读未提交：直接修改原始数据即可，其他事务查看数据的时候立刻可以查看到，无需版本控制。</li></ul><p>MVCC 是只针对“读 + 写”场景的优化，如果是两个事务同时修改数据，即“写 + 写”的情况，那就没有多少优化的空间了，加锁几乎是唯一可行的解决方案，分为悲观锁和乐观锁。</p><ul><li><strong>“悲观锁（悲观并发控制）”</strong>：认为事务之间数据存在竞争是必然情况，竞争越剧烈，性能越好。（即基于锁的并发控制，比如2PL）</li><li><strong>“乐观锁（乐观并发控制）”</strong>：认为事务之间数据存在竞争是偶然情况，竞争越剧烈，性能越差。（基本思路是提交事务前检查有没有更改，如果有就放弃修改并重试）</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;周志明《凤凰架构：构建可靠的大型分布式系统》&lt;br&gt;&lt;a href=&quot;https://icyfenix.cn/&quot;&gt;https://icyfenix.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;包括：ACID、如何实现原子性和持久性、如何实现隔离性、事务隔离级别、多版本并发控制-MVCC、悲观锁和乐观锁&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="技术" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="凤凰架构" scheme="http://www.lights8080.com/tags/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84/"/>
    
    <category term="事务" scheme="http://www.lights8080.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>凤凰架构-RPC vs REST</title>
    <link href="http://www.lights8080.com/p/dcd4b9cd.html"/>
    <id>http://www.lights8080.com/p/dcd4b9cd.html</id>
    <published>2021-07-25T16:00:00.000Z</published>
    <updated>2021-09-07T03:49:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>周志明《凤凰架构：构建可靠的大型分布式系统》<br><a href="https://icyfenix.cn/">https://icyfenix.cn/</a></p><p>RPC发展史、REST风格的面向资源编程思想</p><span id="more"></span><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>RPC出现的最初目的，就是为了让计算机能够跟调用本地方法一样去调用远程方法。</p><p>进程间通信（Inter-Process Communication，IPC）方法：</p><ul><li>管道（Pipe）：类似于两个进程间的桥梁，传递少量的字符流和字节流。如：ps -ef | grep java</li><li>信号（Signal）：通知目标进程有某种事件发生。如：kill -9 pid</li><li>信号量（Semaphore）：信号量用于两个进程之间同步协作手段。如：wait(),notify()</li><li>消息队列（Message Queue）：以上三种方式只适合传递传递少量信息，消息队列用于进程间数据量较多的通信。</li><li>共享内存（Shared Memory）：允许多个进程访问同一块公共的内存空间，这是效率最高的进程间通信形式。</li><li>套接字接口（Socket）：以上两种方式只适合单机多进程间的通信，套接字接口是更为普适的进程间通信机制，可用于不同机器之间的进程通信。</li></ul><h3 id="通信的成本"><a href="#通信的成本" class="headerlink" title="通信的成本"></a>通信的成本</h3><p>最后一种基于套接字接口的通信方式（IPC Socket），它不仅适用于本地相同机器的不同进程间通信，由于 Socket 是网络栈的统一接口，它也理所当然地能支持基于网络的跨机器的进程间通信。</p><p>由于 Socket 是各个操作系统都有提供的标准接口，完全有可能把远程方法调用的通信细节隐藏在操作系统底层，从应用层面上看来可以做到远程调用与本地的进程间通信在编码上完全一致。但这种透明的调用形式却反而造成了程序员误以为通信是无成本的假象。</p><p>在“透明的 RPC 调用”一度成为主流范式的时候，Andrew Tanenbaum教授对此提出了一系列质问。论文的中心观点是：本地调用与远程调用当做一样处理，这是犯了方向性的错误，把系统间的调用做成透明，反而会增加程序员工作的复杂度。</p><p>透明通信的支持者有之，反对者有之，经过此后几年的发展，逐渐证明了Andrew Tanenbaum教授的预言是正确的。最终大佬们共同总结了通过网络进行分布式运算的八宗罪。</p><p>潜台词就是如果远程服务调用要弄透明化的话，就必须为这些罪过买单。至此，RPC 应该是一种高层次的或者说语言层次的特征，而不是像 IPC 那样，是低层次的或者说系统层次的特征成为工业界、学术界的主流观点。</p><h3 id="RPC三个基本问题"><a href="#RPC三个基本问题" class="headerlink" title="RPC三个基本问题"></a>RPC三个基本问题</h3><ul><li>如何表示数据：就是序列化与反序列化。Web Service 的XML Serialization</li><li>如何传递数据：通常指的是应用层协议，实际传输一般是基于标准的 TCP、UDP 等标准的传输层协议来完成的。Web Service 的Simple Object Access Protocol（SOAP）</li><li>如何确定方法：一套语言无关的接口描述语言。Web Service 的Web Service Description Language（WSDL）</li></ul><h3 id="RPC的统一和分裂"><a href="#RPC的统一和分裂" class="headerlink" title="RPC的统一和分裂"></a>RPC的统一和分裂</h3><h4 id="统一"><a href="#统一" class="headerlink" title="统一"></a>统一</h4><p>CORBA本身设计得实在是太过于啰嗦繁琐，制定的规范晦涩难懂脱离实际，没有把握住统一 RPC 的大好机遇。</p><p>后来XML 1.0 发布，并成为W3C的推荐标准，随后SOAP 1.0规范的发布，它代表着一种被称为“Web Service”的全新的 RPC 协议的诞生。随后提交给 W3C 投票成为国际标准，所以也被称为W3C Web Service。Web Service 采用了 XML 作为远程过程调用的序列化、接口描述、服务发现等所有编码的载体。</p><p>Web Service 的一大缺点是它那过于严格的数据和接口定义所带来的性能问题，XML本身信息密度就相对低下，Web Service又是跨语言的 RPC 协议，一个简单的字段为了不会产生歧义，XML严格描述的话，往往比原来多出几十倍的空间。<br>另外一点是，它希望在一套协议上一揽子解决分布式计算中可能遇到的所有问题，除它本身包括的 SOAP、WSDL、UDDI 协议外，还有一堆WS-*命名的、用于解决事务、一致性、事件、通知、业务描述、安全、防重放等子功能协议，这对开发者造成了非常沉重的学习负担。</p><h4 id="分裂"><a href="#分裂" class="headerlink" title="分裂"></a>分裂</h4><p>由于一直没有一个同时满足以上三点的“完美 RPC 协议”出现。今时今日，任何一款具有生命力的 RPC 框架，都不再去追求大而全的“完美”，而是有自己的针对性特点作为主要的发展方向。</p><ul><li>朝着面向对象发展：RMI（Sun/Oracle）、.NET Remoting</li><li>朝着性能发展，代表为 gRPC（Google）、Thrift（Facebook/Apache）</li><li>朝着简化发展，代表为 JSON-RPC</li></ul><p>到了最近几年，RPC 框架有明显的朝着更高层次（不仅仅负责调用远程服务，还管理远程服务）与插件化方向发展的趋势，不再追求独立地解决 RPC 的全部三个问题（表示数据、传递数据、表示方法），而是将一部分功能设计成扩展点，让用户自己去选择。<br>框架聚焦于提供核心的、更高层次的能力，譬如提供负载均衡、服务注册、可观察性等方面的支持。这一类框架的代表有 Facebook 的 Thrift 与阿里的 Dubbo。</p><h2 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h2><p>REST并不是一种远程服务调用协议，它甚至就不是一种协议。虽然它有一些指导原则，但实际上并不受任何强制的约束。经常会有人批评说，某个系统接口“设计得不够 RESTful”，其实这句话本身就有些争议。因为 REST 只能说是一种风格。</p><p>REST是“表征状态转移”（Representational State Transfer）的缩写。可以理解为是“HTT”（Hyper Text Transfer，超文本传输）的进一步抽象，它们就像是接口与实现类之间的关系。</p><p>REST中关键概念：（以阅读文章为例）</p><ul><li>资源（Resource）：可以将其视作是某种信息、数据。如：文章的内容，无论是网页还是报纸，你阅读的仍是同一个“资源”</li><li>表征（Representation）：指信息与用户交互时的表示形式。如：文章的PDF、Markdown等表现形式</li><li>状态（State）：在特定语境中才能产生的上下文信息就被称为“状态”。如：请求“下一篇”文章，依赖当前正在阅读的文章</li><li>转移（Transfer）：服务器通过某种方式，把“用户当前阅读的文章”转变成“下一篇文章”，这就被称为“表征状态转移”</li></ul><h3 id="RESTful的系统"><a href="#RESTful的系统" class="headerlink" title="RESTful的系统"></a>RESTful的系统</h3><p>REST风格的系统应该满足以下六大原则</p><ul><li>服务端与客户端分离（Client-Server）</li><li>无状态（Stateless）</li><li>可缓存（Cacheability）</li><li>分层系统（Layered System）</li><li>统一接口（Uniform Interface）</li><li>按需代码（Code-On-Demand）</li></ul><p>REST以资源为主体进行服务设计的风格，带来了什么好处：</p><ul><li>降低的服务接口的学习成本</li><li>资源天然具有集合与层次结构</li><li>REST 绑定于 HTTP 协议</li></ul><p>RMM成熟度模型</p><ul><li>0级. The Swamp of Plain Old XML：完全不REST，是RPC的风格</li><li>1级. Resources：引入资源的概念</li><li>2级. HTTP Verbs：引入统一接口，映射到HTTP协议的方法上（目前大部分的系统能够达到的REST界别）</li><li>3级. Hypermedia Controls：“超文本驱动”，除了第一个请求是地址栏输入驱动以外，后续请求应该自己描述清楚后续可能发生的状态转移，由超文本自身来驱动。</li></ul><p>编程思想的立场不同：</p><ul><li>面向过程编程时，为什么要以算法和处理过程为中心，输入数据，输出结果？当然是为了符合计算机世界中主流的交互方式。</li><li>面向对象编程时，为什么要将数据和行为统一起来、封装成对象？当然是为了符合现实世界的主流的交互方式。</li><li>面向资源编程时，为什么要将数据（资源）作为抽象的主体，把行为看作是统一的接口？当然是为了符合网络世界的主流的交互方式。</li></ul><h2 id="RPC-vs-REST"><a href="#RPC-vs-REST" class="headerlink" title="RPC vs REST"></a>RPC vs REST</h2><p>REST 与 RPC 在思想上差异的核心是抽象的目标不一样，即面向资源的编程思想与面向过程的编程思想两者之间的区别。</p><p>至于使用范围，REST 与 RPC 作为主流的两种远程调用方式，在使用上是确有重合的，但重合的区域有多大就见仁见智了。</p><p>RPC一些发展方向，如分布式对象、提升调用效率、简化调用复杂性。</p><ul><li>分布式对象：这一条线的应用与 REST 可以说是毫无关联；</li><li>提升调用效率：REST提升传输效率的潜力有限，对于传输协议、序列化器这两点都不会有什么选择的权力</li><li>简化调用复杂性：追求简化调用的场景，众多 RPC 里也就 JSON-RPC 有机会与 REST 竞争</li></ul><p>我们今天再去看这两种编程思想，虽然它们出现的时间有先后，但在人类使用计算机语言来处理数据的工作中，无论用哪种思维来抽象问题都是合乎逻辑的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;周志明《凤凰架构：构建可靠的大型分布式系统》&lt;br&gt;&lt;a href=&quot;https://icyfenix.cn/&quot;&gt;https://icyfenix.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RPC发展史、REST风格的面向资源编程思想&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="技术" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="凤凰架构" scheme="http://www.lights8080.com/tags/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84/"/>
    
    <category term="RPC" scheme="http://www.lights8080.com/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>2107-4-风险意识</title>
    <link href="http://www.lights8080.com/p/8acff730.html"/>
    <id>http://www.lights8080.com/p/8acff730.html</id>
    <published>2021-07-22T16:00:00.000Z</published>
    <updated>2021-09-24T10:42:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>如题</p><span id="more"></span><h2 id="话题：风险意识"><a href="#话题：风险意识" class="headerlink" title="话题：风险意识"></a>话题：风险意识</h2><p>试想一下，如果你下班坐地铁，列车走到一半突然停了，车厢开始渗水，开始淹过膝盖，腰部，胸口，一直到你的脖子，只能靠仰头呼吸，甚至呼吸都变得困难了。你认为这是开玩笑吗？这是真实的河南暴雨亲历者故事。</p><p>这真有点像灾难片了《地铁惊魂》。</p><p>现在的我们不用为饿肚子发愁，不用考虑突然被猛兽攻击，热了有空调，冷了有暖气。我们误以为我们已经足够强大，可以抵御任何风险。然而，灾难来临时真的不会跟你打招呼。</p><p>对于个人来讲，遇到突发情况，在救援人员赶到之前，我们能做的只有自救，然后在自己没有危险的情况下帮助他人。</p><p>我喜欢发散性思考或者叫没事儿瞎寻思的人。<br>比如坐公交我有想过如果撞车会发生什么？站立在什么位置更安全。<br>比如开车前面突然出现了人，该如何操作？到路口之前，我都是有意识的把脚放到刹车上，现在已养成习惯。<br>我甚至还想过，如果坐飞机出现突发情况，我该如何自救（虽然我也知道这无济于事，但我确实脑补过这个场景）。</p><p>这可能跟我喜欢看灾难片有关。<br>我想说风险无法预知，面对风险，你早一步，危险的几率就会下降很多。风险意识，就尽可能的让我们早这一步。当然能做到避免风险，那就更好了。</p><p>PS：我上下班的交通路径有三种，平时只会走最优的那条线，遇到突发情况（封站、人员滞留等），会立马切换到别的路径上，基本不会迟到。</p><h2 id="语录"><a href="#语录" class="headerlink" title="语录"></a>语录</h2><ol><li><p>我现在不和人争吵了，因为我开始意识到，每个人只能在他的认知水平基础上去思考，以后有人告诉我2+2等于10，我会说，你真厉害，你完全正确。<br>——马斯克</p></li><li><p>如果你从太空看地球，它会改变你。它改变了你与这个星球和人类的关系。我想参加这次飞行，因为这是我一生都想做的事情。<br>——贝索斯</p></li><li><p>自知者不怨人，知命者不怨天；怨人者穷，怨天者无志。<br>——荀子荣辱</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;如题&lt;/p&gt;</summary>
    
    
    
    <category term="weekly" scheme="http://www.lights8080.com/categories/weekly/"/>
    
    
    <category term="weekly" scheme="http://www.lights8080.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>凤凰架构-向微服务迈进</title>
    <link href="http://www.lights8080.com/p/70598b0f.html"/>
    <id>http://www.lights8080.com/p/70598b0f.html</id>
    <published>2021-07-22T16:00:00.000Z</published>
    <updated>2021-09-07T03:50:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>周志明《凤凰架构：构建可靠的大型分布式系统》<br><a href="https://icyfenix.cn/">https://icyfenix.cn/</a></p><p>向微服务迈进，目的-&gt;前提-&gt;边界-&gt;治理</p><span id="more"></span><blockquote><p>软件研发中任何一项技术、方法、架构都不可能是银弹。</p></blockquote><p>假如只能用一个词来形容微服务解决问题的核心思想，笔者给的答案就是“分治”，这即是微服务的基本特征，也是微服务应对复杂性的手段。</p><h2 id="目的：微服务的驱动力"><a href="#目的：微服务的驱动力" class="headerlink" title="目的：微服务的驱动力"></a>目的：微服务的驱动力</h2><p>硬件的成本能够持续稳定地下降，而软件开发的成本则不可能。微服务最主要的目的是对系统进行有效的拆分，实现物理层面的隔离，微服务的核心价值就是拆分之后的系统能够让局部的单个服务有可能实现敏捷地卸载、部署、开发、升级，局部的持续更迭。</p><p>外部因素：</p><ul><li>当意识到没有什么技术能够包打天下：java、python、golang不同的语言擅长做不同的事情</li><li>当个人能力因素成为系统发展的明显制约：在单体架构下，系统中“整体”与“部分”的关系没有物理的划分，难以阻止大量螺丝钉式的程序员或外包人员在不起眼的地方犯错并产生全局的影响</li><li>当遇到来自外部商业层面对内部技术层面提出的要求：甲方招投标文件技术规范明文要求</li></ul><p>内部因素：</p><ul><li>变化发展特别快的创新业务系统往往会自主地向微服务架构靠近：需求、开发、运维肯定都是很乐意接受微服务</li><li>大规模的、业务复杂的、历史包袱沉重的系统也可能主动向微服务架构靠近</li></ul><h2 id="前提：微服务需要的条件"><a href="#前提：微服务需要的条件" class="headerlink" title="前提：微服务需要的条件"></a>前提：微服务需要的条件</h2><ul><li>决策者与执行者都能意识到康威定律在软件设计中的关键作用，沟通决定设计，技术层面和组织层面不一致，会造成沟通成本上升或管理成本上升</li><li>组织中具备一些的对微服务有充分理解、有一定实践经验的技术专家，微服务架构对普通开发者友善，对架构者满满的恶意</li><li>系统应具有以自治为目标的自动化与监控度量能力，三个前提：环境预置，基础监控，快速部署</li><li>复杂性已经成为制约生产力的主要矛盾，接受演进式架构</li></ul><h2 id="边界：微服务的粒度"><a href="#边界：微服务的粒度" class="headerlink" title="边界：微服务的粒度"></a>边界：微服务的粒度</h2><p>“识别微服务的边界”其实已取得了较为一致的观点，也找到了指导具体实践的方法论，即领域驱动设计（Domain-Driven Design，DDD）。</p><p>但系统设计是一种创作，而不是应试，不可能每一位架构师设计的服务粒度全都相同，微服务的大小、边界不应该只有唯一正确的答案或绝对的标准，但是应该有个合理的范围，笔者称其为微服务粒度的上下界（下界：表示微服务粒度太小，上界：表示微服务粒度太大）。</p><p>微服务粒度的下界是它至少应满足</p><ul><li>独立：能够独立发布、独立部署、独立运行与独立测试</li><li>内聚：强相关的功能与数据在同一个服务中处理</li><li>完备：一个服务包含至少一项业务实体与对应的完整操作</li></ul><p>微服务的上界并非受限于技术，而是受限于人，更准确地说，受限于人与人之间的社交协作</p><ul><li>微服务粒度的上界是一个 2 Pizza Team 能够在一个研发周期内完成的全部需求范围</li></ul><h2 id="治理：理解系统复杂性"><a href="#治理：理解系统复杂性" class="headerlink" title="治理：理解系统复杂性"></a>治理：理解系统复杂性</h2><blockquote><p>治理就是让产品能够符合预期地稳定运行，并能够持续保持在一定的质量水平上。</p></blockquote><h3 id="静态的治理"><a href="#静态的治理" class="headerlink" title="静态的治理"></a>静态的治理</h3><p>复杂性的来源：</p><ul><li>复杂性来自认知负荷：分布式系统带来更高的认知负荷，面向资源，异步通讯，容错处理，去中心化等。</li><li>复杂性来自协作成本：协作的沟通复杂度，<code>沟通成本= n×(n-1)/2，n 为参与项目的人数</code></li></ul><p>结论：软件规模小时微服务的复杂度高于单体系统，规模大时则相反。这里的原因就是微服务的认知负荷较高，但是协作成本较低。</p><p>假如只能用一个词来形容微服务解决问题的核心思想，笔者给的答案就是“分治”，这即是微服务的基本特征，也是微服务应对复杂性的手段。</p><h3 id="发展的治理"><a href="#发展的治理" class="headerlink" title="发展的治理"></a>发展的治理</h3><p>架构腐化是软件动态发展中出现的问题，任何静态的治理方案都只能延缓，不能根治，必须在发展中才能寻找到彻底解决的办法。治理架构腐化唯一有效的办法是演进式的设计。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;周志明《凤凰架构：构建可靠的大型分布式系统》&lt;br&gt;&lt;a href=&quot;https://icyfenix.cn/&quot;&gt;https://icyfenix.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;向微服务迈进，目的-&amp;gt;前提-&amp;gt;边界-&amp;gt;治理&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="技术" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="凤凰架构" scheme="http://www.lights8080.com/tags/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84/"/>
    
    <category term="微服务" scheme="http://www.lights8080.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>凤凰架构-架构演进</title>
    <link href="http://www.lights8080.com/p/a289ccb9.html"/>
    <id>http://www.lights8080.com/p/a289ccb9.html</id>
    <published>2021-07-22T16:00:00.000Z</published>
    <updated>2021-09-07T03:50:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>周志明《凤凰架构：构建可靠的大型分布式系统》<br><a href="https://icyfenix.cn/">https://icyfenix.cn/</a></p><p>架构演进，原始分布式时代-&gt;单体系统时代-&gt;SOA时代-&gt;微服务时代-&gt;后微服务时代-&gt;无服务时代</p><span id="more"></span><p>架构并不是被“发明”出来的，而是持续进化的结果。</p><p>整个“演进中的架构”这部分，一条重要的逻辑线索就是软件工业对如何拆分业务、隔离技术复杂性的探索。从最初的不拆分，到通过越来越复杂的技术手段逐渐满足了业务的拆分与协作，再到追求隔离掉这些复杂技术手段，将它们掩埋于基础设施之中，到未来（有可能的）重新回到无需考虑算力、无需拆分的云端系统。</p><h2 id="原始分布式时代"><a href="#原始分布式时代" class="headerlink" title="原始分布式时代"></a>原始分布式时代</h2><blockquote><p>Unix的分布式设计哲学：<br>保持接口与实现的简单性，比系统的任何其他属性，包括准确性、一致性和完整性，都来得更加重要。</p></blockquote><p>20世纪70年代末期到80年代初，计算机科学刚经历了从以大型机为主向以微型机为主的蜕变。当时计算机硬件局促的运算处理能力，已直接妨碍到了在单台计算机上信息系统软件能够达到的最大规模。为突破硬件算力的限制，各个高校、研究机构、软硬件厂商开始分头探索，寻找使用多台计算机共同协作来支撑同一套软件系统运行的可行方案。</p><p>当时研究这些技术都带着浓厚的UNIX设计风格，有一个预设的重要原则是使分布式环境中的服务调用、资源访问、数据存储等操作尽可能透明化、简单化，使开发人员不必过于关注他们访问的方法或其他资源是位于本地还是远程。</p><p>但是“调用远程方法”与“调用本地方法”两者的复杂度就完全不可同日而语，一旦要考虑性能上的差异，那远程和本地的鸿沟是无比深刻的，两者的速度往往有着数量级上的差距，完全不可调和。</p><p>在那个时代的机器硬件条件下，为了让程序在运行效率上可被用户接受，开发者在某些场景只能被迫将几个原本毫无关系的方法打包到一个方法体内，一块进行远程调用，以提升性能。这本身与期望的分布式相矛盾，另外开发者需要时刻注意是在编写分布式程序。最终导致设计向性能做出的妥协，本地与远程无论是编码、设计、部署还是运行效率角度上看，都有着天壤之别。</p><blockquote><p>原始分布式时代的教训：<br>某个功能能够进行分布式，并不意味着它就应该进行分布式，强行追求透明的分布式操作，只会自寻苦果。</p></blockquote><p>以上结论是有违UNIX设计哲学的，却是当时现实情况下不得不做出的让步。摆在计算机科学面前有两条通往更大规模软件系统的道路，一条是尽快提升单机的处理能力，以避免分布式带来的种种问题；另一条路是找到更完美的解决如何构筑分布式系统的解决方案。</p><p>20世纪80年代正是摩尔定律开始稳定发挥作用的黄金时期，硬件算力束缚软件规模的链条很快变得松动，信息系统进入了以单台或少量几台计算机即可作为服务器来支撑大型信息系统运作的单体时代，且在很长的一段时间内，单体都将是软件架构的绝对主流。</p><h2 id="单体系统时代"><a href="#单体系统时代" class="headerlink" title="单体系统时代"></a>单体系统时代</h2><blockquote><p>单体意味着自包含。单体应用描述了一种由同一技术平台的不同组件构成的单层软件。</p></blockquote><p>单体架构是出现时间最早、应用范围最广、使用人数最多、统治历史最长的一种架构风格。但“单体”这个名称，却是从微服务开始流行之后，才“事后追认”所形成的概念。在这之前，并没有多少人会把“单体”看成一种架构。</p><p>优点：</p><ul><li>易于开发、易于测试、易于部署</li><li>进程内的高效交互</li></ul><p>缺点：</p><ul><li>性能要求难以超越单机</li><li>开发人员规模难以超过“2 Pizza Teams”</li><li>所有代码运行在同一个进程空间之内，某一个功能一旦出问题（内存泄漏、线程爆炸、阻塞、死循环等），都将会影响到整个程序的运行</li><li>代码无法隔离，无法做到单独停止、更新、升级某一部分代码</li><li>无法技术异构（技术异构是说允许系统的每个模块，自由选择不一样的程序语言、不一样的编程框架等技术栈去实现）</li></ul><p>单体系统的真正缺陷实际上并不在于要如何拆分，而在于拆分之后，它会存在隔离与自治能力上的欠缺。</p><p>单体架构并不会消失，因其架构简单，易于开发测试和部署，适用于项目初始阶段，便于业务的快速上线。</p><h2 id="SOA时代"><a href="#SOA时代" class="headerlink" title="SOA时代"></a>SOA时代</h2><p>SOA架构模式之前，三种有代表性服务拆分架构模式</p><ol><li>烟筒式架构：系统独立，信息孤岛</li><li>微内核架构：共享公共主数据，子系统无法直接互通</li><li>事件驱动架构：建立事件队列管道，子系统通过管道解耦交互</li></ol><p>“面向服务的架构”（Service Oriented Architecture，SOA）的概念最早1994年提出，2006成立OSOA联盟来联合制定和推进 SOA 相关行业标准，2007在OASIS的倡议与支持下，共同新成立了Open CSA组织，管理制定SOA的行业标准。</p><p>SOA最根本的目标，就是希望能够总结出一套自上而下的软件研发方法论，它有完善的理论和工具，让企业只需要跟着它的思路，就能够一揽子解决掉软件开发过程中的全套问题。如真如此可以大幅提升整个社会实施信息化的效率。</p><p>但遗憾的是，因为SOA架构过于严谨精密的流程与理论，给架构带来了过度的复杂性，需要有懂得复杂概念的专业人员才能够驾驭。它可以实现多个异构大型系统之间的复杂集成交互，却很难作为一种具有广泛普适性的软件架构风格来推广。</p><h2 id="微服务时代"><a href="#微服务时代" class="headerlink" title="微服务时代"></a>微服务时代</h2><blockquote><p>“Micro-Web-Service”，指的是一种专注于单一职责的、与语言无关的、细粒度的 Web 服务。</p></blockquote><p>微服务是一种通过多个小型服务的组合，来构建单个应用的架构风格，这些服务会围绕业务能力而非特定的技术标准来构建。各个服务可以采用不同的编程语言、不同的数据存储技术、运行在不同的进程之中。服务会采取轻量级的通讯机制和自动化的部署机制，来实现通讯与运维。</p><p>微服务的九个核心的业务与技术特征</p><ol><li>围绕业务能力构建：康威定律(有怎样的结构、规模和能力的团队，就会产生出对应结构、规模、能力的产品)</li><li>分散治理：谁家孩子谁来管，技术异构</li><li>通过服务来实现独立自治的组件：独立、自治</li><li>产品化思维：把服务看做持续改进、提升的产品</li><li>数据去中心化：数据应该按领域来分散管理、更新、维护和存储</li><li>轻量级通讯机制：处理事务、一致性、认证授权等一系列工作应该在服务自己的Endpoint上解决</li><li>容错性设计：接受服务总会出错的现实</li><li>演进式设计：承认服务会被报废淘汰</li><li>基础设施自动化：CI/CD，大大降低了构建、发布、运维工作的复杂性</li></ol><p>微服务追求的是更加自由的架构风格，它摒弃了SOA中几乎所有可以抛弃的约束和规定，提倡以“实践标准”代替“规范标准”。</p><p>服务的注册发现、跟踪治理、负载均衡、故障隔离、认证授权、伸缩扩展、传输通讯、事务处理等问题，在微服务中，都不再会有统一的解决方案。</p><p>Spring Cloud这样的胶水式的全家桶工具集，通过一致的接口、声明和配置，进一步屏蔽了源自于具体工具、框架的复杂性，降低了在不同工具、框架之间切换的成本。</p><h2 id="后微服务时代-云原生时代"><a href="#后微服务时代-云原生时代" class="headerlink" title="后微服务时代/云原生时代"></a>后微服务时代/云原生时代</h2><p>微服务时代，注册发现、跟踪治理、负载均衡、传输通讯等，这些问题我们都需要在应用服务层面处理，而不是基础设施层面去解决这些分布式问题，完全是因为由硬件构成的基础设施，跟不上由软件构成的应用服务的灵活性。随着虚拟化和容器化技术的发展，这些问题好像都可以解决了。</p><p>针对同一个分布式服务的问题，对比下 Spring Cloud 中提供的应用层面的解决方案，以及 Kubernetes 中提供的基础设施层面的解决方案<br><img src="https://static001.geekbang.org/resource/image/bb/d6/bb53ddc9eec69bd1cd175aa50d64d7d6.jpg"></p><p>Kubernetes 的确提供了一条全新的、前途更加广阔的解题思路。</p><p>当虚拟化的基础设施，开始从单个服务的容器发展到由多个容器构成的服务集群，以及集群所需的所有通讯、存储设施的时候，软件与硬件的界限就开始模糊了。<br>原来只能从软件层面解决的分布式架构问题，于是有了另外一种解法：应用代码与基础设施软硬一体，合力应对。</p><h2 id="无服务时代"><a href="#无服务时代" class="headerlink" title="无服务时代"></a>无服务时代</h2><p>“无服务“与“微服务”和“云原生”并没有继承替代关系，“无服务比微服务更加先进“是的错误想法。</p><p>无服务架构简单，分为两块内容</p><ul><li>后端设施：是指数据库、消息队列、日志、存储等这一类用于支撑业务逻辑运行，但本身无业务含义的技术组件。这些后端设施都运行在云中，也就是无服务中的“后端即服务”（Backend as a Service，BaaS）</li><li>函数：业务逻辑代码。这里函数的概念与粒度，都已经和程序编码角度的函数非常接近了，区别就在于，无服务中的函数运行在云端，不必考虑算力问题和容量规划</li></ul><p>无服务的愿景是让开发者只需要纯粹地关注业务</p><ol><li>不用考虑技术组件，因为后端的技术组件是现成的，可以直接取用，没有采购、版权和选型的烦恼</li><li>不需要考虑如何部署，因为部署过程完全是托管到云端的，由云端自动完成</li><li>不需要考虑算力，因为有整个数据中心的支撑，算力可以认为是无限的</li><li>不需要操心运维，维护系统持续地平稳运行是云服务商的责任，而不再是开发者的责任</li></ol><p>无服务中短期内的发展局限性</p><ul><li>与单体架构、微服务架构不同，无服务架构天生的一些特点，比如冷启动、 无状态、运行时间有限制等等，决定了它不是一种具有普适性的架构模式</li><li>擅长短链接、无状态、适合事件驱动的交互形式，不适用于具有业务逻辑复杂、依赖服务端状态、响应速度要求较高、需要长连接等特征的应用</li></ul><p>如果说微服务架构是分布式系统这条路当前所能做到的极致，那无服务架构，也许就是“不分布式”的云端系统这条路的起点。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;周志明《凤凰架构：构建可靠的大型分布式系统》&lt;br&gt;&lt;a href=&quot;https://icyfenix.cn/&quot;&gt;https://icyfenix.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;架构演进，原始分布式时代-&amp;gt;单体系统时代-&amp;gt;SOA时代-&amp;gt;微服务时代-&amp;gt;后微服务时代-&amp;gt;无服务时代&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="技术" scheme="http://www.lights8080.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="凤凰架构" scheme="http://www.lights8080.com/tags/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
</feed>
